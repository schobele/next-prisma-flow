#!/usr/bin/env node

import fs from "node:fs/promises";
import path from "node:path";
import { type GeneratorOptions, generatorHandler } from "@prisma/generator-helper";

import { parseGeneratorConfig, validateConfig } from "./src/config.js";
import {
	FileSystemError,
	FlowGeneratorError,
	ModelNotFoundError,
	TemplateGenerationError,
	handleGeneratorError,
} from "./src/errors.js";
import { generateServerActions } from "./src/templates/actions.js";
import { generateJotaiAtoms } from "./src/templates/atoms.js";
import { generateEnhancedBarrelExports } from "./src/templates/enhanced-barrel.js";
import { generateEnhancedReactHooks } from "./src/templates/enhanced-hooks.js";
import { generateFormProviders } from "./src/templates/form-providers.js";
import { generateNamespaceExports } from "./src/templates/namespace.js";
import { generateApiRoutes } from "./src/templates/routes.js";
import { generateSmartFormHook } from "./src/templates/smart-form-hook.js";
import { generateTypes } from "./src/templates/types.js";
import type { GeneratorContext } from "./src/types.js";
import { capitalize, createGeneratorContext, pluralize } from "./src/utils.js";
import { ZodGenerationError } from "./src/zod-generator.js";
import { generateZodSchemas } from "./src/zod-generator.js";

async function generateSharedPrismaClient(context: GeneratorContext): Promise<void> {
	const template = `// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: ${new Date().toISOString()}

import { PrismaClient } from '@prisma/client';

// Create shared Prisma client instance
export const prisma = new PrismaClient();
`;

	const filePath = path.join(context.outputDir, "prisma-client.ts");
	await fs.writeFile(filePath, template, "utf-8");
}

generatorHandler({
	onManifest() {
		return {
			version: "1.0.0",
			defaultOutput: "./generated/flow",
			prettyName: "Next Prisma Flow Generator",
			requiresGenerators: ["prisma-client-js"],
		};
	},

	async onGenerate(options: GeneratorOptions) {
		try {
			console.log("üöÄ Starting Next Prisma Flow Generator...");

			// Parse and validate configuration
			const config = parseGeneratorConfig(options);
			const modelNames = options.dmmf.datamodel.models.map((m) => m.name);
			validateConfig(config, modelNames);

			// Create generator context
			const context = createGeneratorContext(config, options.dmmf, config.output);

			// Ensure output directory exists
			try {
				await fs.mkdir(context.outputDir, { recursive: true });
			} catch (error) {
				throw new FileSystemError("create directory", context.outputDir, error);
			}

			// Generate Zod schemas first using zod-prisma-types
			try {
				await generateZodSchemas(options, context.outputDir, config.models);
			} catch (error) {
				throw new TemplateGenerationError("zod schemas", "all models", error);
			}

			// Generate shared prisma client if using default @prisma/client
			if (context.prismaImport === "@prisma/client") {
				try {
					await generateSharedPrismaClient(context);
				} catch (error) {
					throw new TemplateGenerationError("shared prisma client", "all models", error);
				}
			}

			// Generate code for each model
			for (const modelName of config.models) {
				console.log(`üìù Generating code for model: ${modelName}`);

				const model = options.dmmf.datamodel.models.find((m) => m.name === modelName);
				if (!model) {
					throw new ModelNotFoundError(modelName);
				}

				const lowerModelName = modelName.toLowerCase();
				const modelConfig = config[lowerModelName] || {};
				const pluralName = capitalize(pluralize(modelName));
				const lowerPluralName = pluralize(lowerModelName);

				const modelInfo = {
					name: modelName,
					lowerName: lowerModelName,
					pluralName,
					lowerPluralName,
					config: modelConfig,
					model,
					selectFields:
						modelConfig.select || model.fields.filter((f) => f.kind === "scalar" || f.kind === "enum").map((f) => f.name),
				};

				// Create model-specific directory
				const modelDir = path.join(context.outputDir, lowerModelName);
				try {
					await fs.mkdir(modelDir, { recursive: true });
				} catch (error) {
					throw new FileSystemError("create directory", modelDir, error);
				}

				// Generate all template files for this model
				try {
					await Promise.all([
						generateApiRoutes(modelInfo, context, modelDir).catch((error) => {
							throw new TemplateGenerationError("routes", modelName, error);
						}),
						generateServerActions(modelInfo, context, modelDir).catch((error) => {
							throw new TemplateGenerationError("actions", modelName, error);
						}),
						generateJotaiAtoms(modelInfo, context, modelDir).catch((error) => {
							throw new TemplateGenerationError("atoms", modelName, error);
						}),
						generateEnhancedReactHooks(modelInfo, context, modelDir).catch((error) => {
							throw new TemplateGenerationError("hooks", modelName, error);
						}),
						generateFormProviders(modelInfo, context, modelDir).catch((error) => {
							throw new TemplateGenerationError("form-providers", modelName, error);
						}),
						generateSmartFormHook(modelInfo, context, modelDir).catch((error) => {
							throw new TemplateGenerationError("smart-form", modelName, error);
						}),
						generateTypes(modelInfo, context, modelDir).catch((error) => {
							throw new TemplateGenerationError("types", modelName, error);
						}),
						generateNamespaceExports(modelInfo, context, modelDir).catch((error) => {
							throw new TemplateGenerationError("namespace", modelName, error);
						}),
					]);
				} catch (error) {
					if (error instanceof TemplateGenerationError) {
						throw error;
					}
					throw new TemplateGenerationError("unknown", modelName, error);
				}
			}

			// Generate barrel exports
			try {
				await generateEnhancedBarrelExports(config, context);
			} catch (error) {
				throw new TemplateGenerationError("barrel exports", "all models", error);
			}

			console.log("‚úÖ Next Prisma Flow Generator completed successfully!");
		} catch (error) {
			if (error instanceof FlowGeneratorError) {
				console.error(`‚ùå ${error.name}: ${error.message}`);
				if (error.cause) {
					console.error(`Caused by: ${error.cause}`);
				}
			} else {
				console.error(`‚ùå Unexpected error: ${error}`);
			}
			throw error;
		}
	},
});
