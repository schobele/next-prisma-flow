// @generated by next-prisma-flow-state-engine
// file: client/composables.ts

"use client";

import { useState, useCallback, useRef, useEffect } from "react";
import {
  type UseFormReturn,
  type Path,
  type PathValue,
  useWatch,
} from "react-hook-form";
import { type UseMutationResult } from "@tanstack/react-query";
import type {
  FlowList,
  FlowListCreate,
  FlowListUpdate,
} from "../types/schemas";

// Autosave functionality for forms
export function useListFormAutosave<T extends FlowListCreate | FlowListUpdate>(
  form: UseFormReturn<T>,
  mutation: UseMutationResult<FlowList, Error, any>,
  options?: {
    enabled?: boolean;
    debounceMs?: number;
    fields?: string[];
    onFieldSave?: (field: string, value: any) => void;
    onFieldError?: (field: string, error: Error) => void;
  },
) {
  const {
    enabled = true,
    debounceMs = 1000,
    fields,
    onFieldSave,
    onFieldError,
  } = options || {};
  const [fieldSaveStates, setFieldSaveStates] = useState<
    Record<string, "idle" | "saving" | "saved" | "error">
  >({});
  const debounceTimers = useRef<Record<string, NodeJS.Timeout>>({});
  const lastSavedValues = useRef<Record<string, any>>({});
  const isSystemUpdate = useRef(false);
  const isSaving = useRef<Set<string>>(new Set());
  const saveFieldRef = useRef<(fieldName: string, value: any) => void>();

  const saveField = useCallback(
    async (fieldName: string, value: any) => {
      console.log("[List Autosave] saveField called:", {
        fieldName,
        value,
        enabled,
        isSystemUpdate: isSystemUpdate.current,
      });
      if (!enabled) return;
      if (fields && !fields.includes(fieldName)) return;
      if (isSystemUpdate.current) return;
      if (isSaving.current.has(fieldName)) return;

      // Check if value actually changed from last saved
      if (lastSavedValues.current[fieldName] === value) {
        console.log("[List Autosave] Value unchanged, skipping save");
        return;
      }

      // Clear existing timer
      if (debounceTimers.current[fieldName]) {
        clearTimeout(debounceTimers.current[fieldName]);
      }

      console.log(
        "[List Autosave] Setting debounce timer for",
        fieldName,
        "with delay",
        debounceMs,
      );
      debounceTimers.current[fieldName] = setTimeout(async () => {
        console.log("[List Autosave] Debounce timer fired for", fieldName);
        // Double-check value hasn't changed while debouncing
        const currentValue = form.getValues(fieldName as Path<T>);
        if (lastSavedValues.current[fieldName] === currentValue) {
          console.log(
            "[List Autosave] Value unchanged after debounce, skipping",
          );
          return;
        }

        const isValid = await form.trigger(fieldName as Path<T>);
        if (!isValid) {
          console.log("[List Autosave] Field validation failed");
          setFieldSaveStates((prev) => ({ ...prev, [fieldName]: "error" }));
          return;
        }

        isSaving.current.add(fieldName);
        setFieldSaveStates((prev) => ({ ...prev, [fieldName]: "saving" }));

        try {
          console.log("[List Autosave] Calling mutation with:", {
            [fieldName]: currentValue,
          });
          // Temporarily disable autosave during mutation
          isSystemUpdate.current = true;
          await mutation.mutateAsync({ [fieldName]: currentValue } as any);
          console.log("[List Autosave] Mutation successful");
          lastSavedValues.current[fieldName] = currentValue;
          setFieldSaveStates((prev) => ({ ...prev, [fieldName]: "saved" }));
          onFieldSave?.(fieldName, currentValue);

          setTimeout(() => {
            setFieldSaveStates((prev) => ({ ...prev, [fieldName]: "idle" }));
          }, 2000);
        } catch (error) {
          console.error("[List Autosave] Mutation failed:", error);
          setFieldSaveStates((prev) => ({ ...prev, [fieldName]: "error" }));
          onFieldError?.(fieldName, error as Error);
        } finally {
          isSaving.current.delete(fieldName);
          // Re-enable autosave after a small delay to prevent immediate retrigger
          setTimeout(() => {
            isSystemUpdate.current = false;
          }, 100);
        }
      }, debounceMs);
    },
    [enabled, fields, form, mutation, debounceMs, onFieldSave, onFieldError],
  );

  // Store saveField in ref to prevent effect re-runs
  useEffect(() => {
    saveFieldRef.current = saveField;
  }, [saveField]);

  // Initialize last saved values
  useEffect(() => {
    if (enabled) {
      const formValues = form.getValues();
      Object.keys(formValues).forEach((key) => {
        lastSavedValues.current[key] = (formValues as any)[key];
      });
    }
  }, [enabled, form]);

  // Watch for changes
  useEffect(() => {
    console.log(
      "[List Autosave] Setting up watch subscription, enabled:",
      enabled,
    );
    if (!enabled) return;

    const subscription = form.watch((value, { name, type }) => {
      console.log("[List Autosave] Form change detected:", {
        name,
        type,
        isSystemUpdate: isSystemUpdate.current,
      });
      // Only trigger on actual field changes, not on form reset
      if (name && type === "change" && !isSystemUpdate.current) {
        const fieldValue = (value as any)[name];
        console.log(
          "[List Autosave] Triggering saveField for:",
          name,
          "with value:",
          fieldValue,
        );
        // Use ref to avoid stale closure
        saveFieldRef.current?.(name, fieldValue);
      }
    });

    return () => {
      console.log("[List Autosave] Cleaning up watch subscription");
      subscription.unsubscribe();
      // Clear all timers on unmount
      Object.values(debounceTimers.current).forEach((timer) =>
        clearTimeout(timer),
      );
    };
  }, [enabled, form]); // Keep form as dep but not saveField

  // Pause autosave during bulk updates
  const pauseAutosave = useCallback(
    (callback: () => void) => {
      isSystemUpdate.current = true;
      callback();
      setTimeout(() => {
        isSystemUpdate.current = false;
        // Update last saved values after bulk update
        const formValues = form.getValues();
        Object.keys(formValues).forEach((key) => {
          lastSavedValues.current[key] = (formValues as any)[key];
        });
      }, 100);
    },
    [form],
  );

  return {
    fieldSaveStates,
    isAutosaving: Object.values(fieldSaveStates).some(
      (state) => state === "saving",
    ),
    clearSaveStates: () => setFieldSaveStates({}),
    pauseAutosave,
  };
}

// Field tracking and state management
export function useListFormFieldTracking<
  T extends FlowListCreate | FlowListUpdate,
>(form: UseFormReturn<T>, original?: FlowList) {
  const getFieldState = useCallback(
    (name: Path<T>) => {
      const fieldState = form.getFieldState(name);
      const currentValue = form.getValues(name);
      const originalValue = original?.[name as keyof FlowList];

      return {
        isDirty: fieldState.isDirty,
        isTouched: fieldState.isTouched,
        error: fieldState.error,
        current: currentValue,
        original: originalValue,
        hasChanged: original
          ? currentValue !== originalValue
          : fieldState.isDirty,
      };
    },
    [form, original],
  );

  const getDirtyFields = useCallback(() => {
    const dirtyFields: Array<{ field: string; original?: any; current: any }> =
      [];

    Object.keys(form.formState.dirtyFields).forEach((key) => {
      if ((form.formState.dirtyFields as any)[key]) {
        dirtyFields.push({
          field: key,
          original: original?.[key as keyof FlowList],
          current: form.getValues(key as Path<T>),
        });
      }
    });

    return dirtyFields;
  }, [form, original]);

  const resetField = useCallback(
    (name: Path<T>) => {
      if (original) {
        form.setValue(name, (original as any)[name]);
      } else {
        form.resetField(name);
      }
      form.clearErrors(name);
    },
    [form, original],
  );

  return {
    getFieldState,
    getDirtyFields,
    resetField,
    hasChanges: form.formState.isDirty,
  };
}

// Form history for undo/redo
export function useListFormHistory<T extends FlowListCreate | FlowListUpdate>(
  form: UseFormReturn<T>,
  options?: {
    maxHistorySize?: number;
  },
) {
  const { maxHistorySize = 50 } = options || {};
  const [history, setHistory] = useState<
    Array<{ field: string; oldValue: any; newValue: any; timestamp: number }>
  >([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  const previousValues = useRef<Record<string, any>>({});

  // Track changes
  useEffect(() => {
    const subscription = form.watch((value, { name, type }) => {
      if (name && type === "change") {
        const oldValue = previousValues.current[name];
        const newValue = (value as any)[name];

        if (oldValue !== newValue) {
          const change = {
            field: name,
            oldValue,
            newValue,
            timestamp: Date.now(),
          };

          setHistory((prev) => {
            const newHistory = [...prev.slice(0, historyIndex + 1), change];
            return newHistory.slice(-maxHistorySize);
          });

          setHistoryIndex((prev) => Math.min(prev + 1, maxHistorySize - 1));
          previousValues.current[name] = newValue;
        }
      }
    });

    return () => subscription.unsubscribe();
  }, [form, historyIndex, maxHistorySize]);

  const undo = useCallback(() => {
    if (historyIndex >= 0 && history[historyIndex]) {
      const change = history[historyIndex];
      form.setValue(change.field as Path<T>, change.oldValue);
      previousValues.current[change.field] = change.oldValue;
      setHistoryIndex((prev) => prev - 1);
    }
  }, [history, historyIndex, form]);

  const redo = useCallback(() => {
    if (historyIndex < history.length - 1) {
      const change = history[historyIndex + 1];
      form.setValue(change.field as Path<T>, change.newValue);
      previousValues.current[change.field] = change.newValue;
      setHistoryIndex((prev) => prev + 1);
    }
  }, [history, historyIndex, form]);

  const clearHistory = useCallback(() => {
    setHistory([]);
    setHistoryIndex(-1);
    previousValues.current = {};
  }, []);

  return {
    history,
    canUndo: historyIndex >= 0,
    canRedo: historyIndex < history.length - 1,
    undo,
    redo,
    clearHistory,
  };
}

// Individual field hook for granular control
export function useListFieldDirect<T extends FlowListCreate | FlowListUpdate>(
  name: Path<T>,
  form: UseFormReturn<T>,
) {
  const value = useWatch({ control: form.control, name });
  const fieldState = form.getFieldState(name);

  const setValue = useCallback(
    (value: PathValue<T, typeof name>) => {
      form.setValue(name, value);
    },
    [form, name],
  );

  const reset = useCallback(() => {
    form.resetField(name);
  }, [form, name]);

  const validate = useCallback(() => {
    return form.trigger(name);
  }, [form, name]);

  return {
    value,
    error: fieldState.error,
    isDirty: fieldState.isDirty,
    isTouched: fieldState.isTouched,
    isInvalid: !!fieldState.error,
    setValue,
    reset,
    validate,
  };
}
