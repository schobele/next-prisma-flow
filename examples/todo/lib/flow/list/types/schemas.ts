// @generated by next-prisma-flow-state-engine
// file: types/schemas.ts

import { z } from "zod";

// Scalar fields only
export const ListScalarSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional().nullable(),
  color: z.string(),
  icon: z.string(),
  orderIndex: z.number().int(),
  isDefault: z.boolean(),
  createdAt: z.date(),
  updatedAt: z.date(),
  userId: z.string(),
});

// Relation schemas
export const ListTodosUserSchema = z.object({
  id: z.string(),
  email: z.string(),
  name: z.string().optional().nullable(),
  avatar: z.string().optional().nullable(),
  createdAt: z.date(),
});

export const ListTodosParentSchema = z.object({
  id: z.string(),
  title: z.string(),
  description: z.string().optional().nullable(),
  status: z.string(),
  priority: z.string(),
  dueDate: z.date().optional().nullable(),
  completedAt: z.date().optional().nullable(),
  orderIndex: z.number().int(),
  isArchived: z.boolean(),
  createdAt: z.date(),
  updatedAt: z.date(),
});

export const ListTodosSubtasksSchema = z.object({
  id: z.string(),
  title: z.string(),
  description: z.string().optional().nullable(),
  status: z.string(),
  priority: z.string(),
  dueDate: z.date().optional().nullable(),
  completedAt: z.date().optional().nullable(),
  orderIndex: z.number().int(),
  isArchived: z.boolean(),
  createdAt: z.date(),
  updatedAt: z.date(),
});

export const ListTodosTagsSchema = z.object({
  id: z.string(),
  name: z.string(),
  color: z.string(),
  createdAt: z.date(),
});

export const ListUserTodosSchema = z.object({
  id: z.string(),
  title: z.string(),
  description: z.string().optional().nullable(),
  status: z.string(),
  priority: z.string(),
  dueDate: z.date().optional().nullable(),
  completedAt: z.date().optional().nullable(),
  orderIndex: z.number().int(),
  isArchived: z.boolean(),
  createdAt: z.date(),
  updatedAt: z.date(),
});

export const ListTodosSchema = z.object({
  id: z.string(),
  title: z.string(),
  description: z.string().optional().nullable(),
  status: z.string(),
  priority: z.string(),
  dueDate: z.date().optional().nullable(),
  completedAt: z.date().optional().nullable(),
  orderIndex: z.number().int(),
  isArchived: z.boolean(),
  createdAt: z.date(),
  updatedAt: z.date(),
  user: ListTodosUserSchema.optional(),
  parent: ListTodosParentSchema.optional(),
  subtasks: z.array(ListTodosSubtasksSchema).optional(),
  tags: z.array(ListTodosTagsSchema).optional(),
});

export const ListUserSchema = z.object({
  id: z.string(),
  email: z.string(),
  name: z.string().optional().nullable(),
  avatar: z.string().optional().nullable(),
  createdAt: z.date(),
  todos: z.array(ListUserTodosSchema).optional(),
});

// Main schema with relations
export const ListSchema = ListScalarSchema.extend({
  todos: z.array(ListTodosSchema).optional(),
  user: ListUserSchema.optional(),
});

// Input schemas for create operations
const ListCreateTodosInputSchema = z.object({
  id: z.string().optional(),
  title: z.string(),
  description: z.string().optional().nullable(),
  status: z.string().optional(),
  priority: z.string().optional(),
  dueDate: z.date().optional().nullable(),
  completedAt: z.date().optional().nullable(),
  orderIndex: z.number().int().optional(),
  isArchived: z.boolean().optional(),
  createdAt: z.date().optional(),
  list: z
    .object({
      connect: z.object({ id: z.string() }).optional(),
    })
    .optional(),
  user: z
    .object({
      connect: z.object({ id: z.string() }).optional(),
    })
    .optional(),
  parent: z
    .object({
      connect: z.object({ id: z.string() }).optional(),
    })
    .optional(),
  subtasks: z
    .object({
      connect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
    })
    .optional(),
  tags: z
    .object({
      connect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
    })
    .optional(),
});

const ListCreateUserInputSchema = z.object({
  id: z.string().optional(),
  email: z.string(),
  name: z.string().optional().nullable(),
  avatar: z.string().optional().nullable(),
  createdAt: z.date().optional(),
  lists: z
    .object({
      connect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
    })
    .optional(),
  todos: z
    .object({
      connect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
    })
    .optional(),
});

export const ListCreateSchema = z.object({
  id: z.string().optional(),
  name: z.string(),
  description: z.string().optional().nullable(),
  color: z.string().optional(),
  icon: z.string().optional(),
  orderIndex: z.number().int().optional(),
  isDefault: z.boolean().optional(),
  createdAt: z.date().optional(),
  userId: z.string(),
  user: z
    .object({
      create: ListCreateUserInputSchema.optional(),
      connect: z.object({ id: z.string() }).optional(),
      connectOrCreate: z
        .object({
          where: z.object({ id: z.string() }),
          create: ListCreateUserInputSchema,
        })
        .optional(),
    })
    .optional(),
  todos: z
    .object({
      create: z
        .union([
          ListCreateTodosInputSchema,
          z.array(ListCreateTodosInputSchema),
        ])
        .optional(),
      connect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.object({
            where: z.object({ id: z.string() }),
            create: ListCreateTodosInputSchema,
          }),
          z.array(
            z.object({
              where: z.object({ id: z.string() }),
              create: ListCreateTodosInputSchema,
            }),
          ),
        ])
        .optional(),
    })
    .optional(),
});

export const ListCreateManyInputSchema = z.object({
  id: z.string().optional(),
  name: z.string(),
  description: z.string().optional().nullable(),
  color: z.string().optional(),
  icon: z.string().optional(),
  orderIndex: z.number().int().optional(),
  isDefault: z.boolean().optional(),
  createdAt: z.date().optional(),
});

// Input schemas for update operations
const ListUpdateTodosInputSchema = z.object({
  title: z.string().optional(),
  description: z.string().optional().nullable(),
  status: z.string().optional(),
  priority: z.string().optional(),
  dueDate: z.date().optional().nullable(),
  completedAt: z.date().optional().nullable(),
  orderIndex: z.number().int().optional(),
  isArchived: z.boolean().optional(),
  createdAt: z.date().optional(),
  list: z
    .object({
      connect: z.object({ id: z.string() }).optional(),
    })
    .optional(),
  user: z
    .object({
      connect: z.object({ id: z.string() }).optional(),
    })
    .optional(),
  parent: z
    .object({
      connect: z.object({ id: z.string() }).optional(),
      disconnect: z.boolean().optional(),
    })
    .optional(),
  subtasks: z
    .object({
      connect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
      disconnect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
      set: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
    })
    .optional(),
  tags: z
    .object({
      connect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
      disconnect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
      set: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
    })
    .optional(),
});

const ListUpdateUserInputSchema = z.object({
  email: z.string().optional(),
  name: z.string().optional().nullable(),
  avatar: z.string().optional().nullable(),
  createdAt: z.date().optional(),
  lists: z
    .object({
      connect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
      disconnect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
      set: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
    })
    .optional(),
  todos: z
    .object({
      connect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
      disconnect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
      set: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
    })
    .optional(),
});

export const ListUpdateSchema = z.object({
  name: z.string().optional(),
  description: z.string().optional().nullable(),
  color: z.string().optional(),
  icon: z.string().optional(),
  orderIndex: z.number().int().optional(),
  isDefault: z.boolean().optional(),
  createdAt: z.date().optional(),
  userId: z.string().optional(),
  user: z
    .object({
      create: ListCreateUserInputSchema.optional(),
      connect: z.object({ id: z.string() }).optional(),
      connectOrCreate: z
        .object({
          where: z.object({ id: z.string() }),
          create: ListCreateUserInputSchema,
        })
        .optional(),
      update: z
        .object({
          where: z.object({ id: z.string() }).optional(),
          data: ListUpdateUserInputSchema,
        })
        .optional(),
      upsert: z
        .object({
          where: z.object({ id: z.string() }),
          update: ListUpdateUserInputSchema,
          create: ListCreateUserInputSchema,
        })
        .optional(),
    })
    .optional(),
  todos: z
    .object({
      create: z
        .union([
          ListCreateTodosInputSchema,
          z.array(ListCreateTodosInputSchema),
        ])
        .optional(),
      connect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.object({
            where: z.object({ id: z.string() }),
            create: ListCreateTodosInputSchema,
          }),
          z.array(
            z.object({
              where: z.object({ id: z.string() }),
              create: ListCreateTodosInputSchema,
            }),
          ),
        ])
        .optional(),
      set: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
      disconnect: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
      update: z
        .union([
          z.object({
            where: z.object({ id: z.string() }),
            data: ListUpdateTodosInputSchema,
          }),
          z.array(
            z.object({
              where: z.object({ id: z.string() }),
              data: ListUpdateTodosInputSchema,
            }),
          ),
        ])
        .optional(),
      updateMany: z
        .object({
          where: z.any().optional(),
          data: ListUpdateTodosInputSchema,
        })
        .optional(),
      upsert: z
        .union([
          z.object({
            where: z.object({ id: z.string() }),
            update: ListUpdateTodosInputSchema,
            create: ListCreateTodosInputSchema,
          }),
          z.array(
            z.object({
              where: z.object({ id: z.string() }),
              update: ListUpdateTodosInputSchema,
              create: ListCreateTodosInputSchema,
            }),
          ),
        ])
        .optional(),
      delete: z
        .union([
          z.object({ id: z.string() }),
          z.array(z.object({ id: z.string() })),
        ])
        .optional(),
      deleteMany: z.any().optional(),
    })
    .optional(),
});

export const ListUpdateManyInputSchema = z.object({
  name: z.string().optional().nullable(),
  description: z.string().optional().nullable(),
  color: z.string().optional().nullable(),
  icon: z.string().optional().nullable(),
  orderIndex: z.number().int().optional().nullable(),
  isDefault: z.boolean().optional().nullable(),
  createdAt: z.date().optional().nullable(),
});

export const ListUpsertInputSchema = z.object({
  create: ListCreateSchema,
  update: ListUpdateSchema,
});

// Filter and where schemas
// Relation where schemas
export const ListUserFilterSchema = z.object({
  id: z
    .union([
      z.string(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  email: z
    .union([
      z.string(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  name: z
    .union([
      z.string().optional().nullable(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  avatar: z
    .union([
      z.string().optional().nullable(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  createdAt: z
    .union([
      z.date(),
      z.object({
        equals: z.date().optional(),
        lt: z.date().optional(),
        lte: z.date().optional(),
        gt: z.date().optional(),
        gte: z.date().optional(),
        in: z.array(z.date()).optional(),
        notIn: z.array(z.date()).optional(),
        not: z.date().optional(),
      }),
    ])
    .optional(),
  AND: z.array(z.any()).optional(),
  OR: z.array(z.any()).optional(),
  NOT: z.any().optional(),
});

export const ListTodosFilterSchema = z.object({
  id: z
    .union([
      z.string(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  title: z
    .union([
      z.string(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  description: z
    .union([
      z.string().optional().nullable(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  status: z
    .union([
      z.string(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  priority: z
    .union([
      z.string(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  dueDate: z
    .union([
      z.date().optional().nullable(),
      z.object({
        equals: z.date().optional(),
        lt: z.date().optional(),
        lte: z.date().optional(),
        gt: z.date().optional(),
        gte: z.date().optional(),
        in: z.array(z.date()).optional(),
        notIn: z.array(z.date()).optional(),
        not: z.date().optional(),
      }),
    ])
    .optional(),
  completedAt: z
    .union([
      z.date().optional().nullable(),
      z.object({
        equals: z.date().optional(),
        lt: z.date().optional(),
        lte: z.date().optional(),
        gt: z.date().optional(),
        gte: z.date().optional(),
        in: z.array(z.date()).optional(),
        notIn: z.array(z.date()).optional(),
        not: z.date().optional(),
      }),
    ])
    .optional(),
  orderIndex: z
    .union([
      z.number().int(),
      z.object({
        equals: z.number().int().optional(),
        lt: z.number().int().optional(),
        lte: z.number().int().optional(),
        gt: z.number().int().optional(),
        gte: z.number().int().optional(),
        in: z.array(z.number().int()).optional(),
        notIn: z.array(z.number().int()).optional(),
        not: z.number().int().optional(),
      }),
    ])
    .optional(),
  isArchived: z
    .union([
      z.boolean(),
      z.object({
        equals: z.boolean().optional(),
        not: z.boolean().optional(),
      }),
    ])
    .optional(),
  createdAt: z
    .union([
      z.date(),
      z.object({
        equals: z.date().optional(),
        lt: z.date().optional(),
        lte: z.date().optional(),
        gt: z.date().optional(),
        gte: z.date().optional(),
        in: z.array(z.date()).optional(),
        notIn: z.array(z.date()).optional(),
        not: z.date().optional(),
      }),
    ])
    .optional(),
  updatedAt: z
    .union([
      z.date(),
      z.object({
        equals: z.date().optional(),
        lt: z.date().optional(),
        lte: z.date().optional(),
        gt: z.date().optional(),
        gte: z.date().optional(),
        in: z.array(z.date()).optional(),
        notIn: z.array(z.date()).optional(),
        not: z.date().optional(),
      }),
    ])
    .optional(),
  AND: z.array(z.any()).optional(),
  OR: z.array(z.any()).optional(),
  NOT: z.any().optional(),
});

// Base filter schema
export const ListFilterBaseSchema = z.object({
  id: z
    .union([
      z.string(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  name: z
    .union([
      z.string(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  description: z
    .union([
      z.string().optional().nullable(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  color: z
    .union([
      z.string(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  icon: z
    .union([
      z.string(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  orderIndex: z
    .union([
      z.number().int(),
      z.object({
        equals: z.number().int().optional(),
        lt: z.number().int().optional(),
        lte: z.number().int().optional(),
        gt: z.number().int().optional(),
        gte: z.number().int().optional(),
        in: z.array(z.number().int()).optional(),
        notIn: z.array(z.number().int()).optional(),
        not: z.number().int().optional(),
      }),
    ])
    .optional(),
  isDefault: z
    .union([
      z.boolean(),
      z.object({
        equals: z.boolean().optional(),
        not: z.boolean().optional(),
      }),
    ])
    .optional(),
  createdAt: z
    .union([
      z.date(),
      z.object({
        equals: z.date().optional(),
        lt: z.date().optional(),
        lte: z.date().optional(),
        gt: z.date().optional(),
        gte: z.date().optional(),
        in: z.array(z.date()).optional(),
        notIn: z.array(z.date()).optional(),
        not: z.date().optional(),
      }),
    ])
    .optional(),
  user: z.union([ListUserFilterSchema, z.null()]).optional(),
  todos: z
    .object({
      every: ListTodosFilterSchema.optional(),
      some: ListTodosFilterSchema.optional(),
      none: ListTodosFilterSchema.optional(),
    })
    .optional(),
  AND: z.union([z.any(), z.array(z.any())]).optional(),
  OR: z.array(z.any()).optional(),
  NOT: z.union([z.any(), z.array(z.any())]).optional(),
});

// Extended filter schema with self-references
export const ListFilterSchema = ListFilterBaseSchema.extend({
  AND: z.array(ListFilterBaseSchema).optional(),
  OR: z.array(ListFilterBaseSchema).optional(),
  NOT: ListFilterBaseSchema.optional(),
});

// Alias for Prisma compatibility
export const ListWhereInputSchema = ListFilterSchema;

export const ListWhereUniqueInputSchema = z.object({
  id: z.string().optional(),
});

// Type exports
export type FlowList = z.infer<typeof ListSchema>;
export type FlowListCreate = z.infer<typeof ListCreateSchema>;
export type FlowListUpdate = z.infer<typeof ListUpdateSchema>;
export type FlowListFilter = z.infer<typeof ListFilterSchema>;
export type FlowListWhere = z.infer<typeof ListWhereInputSchema>;
export type FlowListWhereUnique = z.infer<typeof ListWhereUniqueInputSchema>;
