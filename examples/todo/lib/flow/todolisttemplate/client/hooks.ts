// @generated by next-prisma-flow-state-engine
// file: client/hooks.ts

"use client";

import {
  useQuery,
  useMutation,
  useQueryClient,
  UseQueryOptions,
  UseMutationOptions,
} from "@tanstack/react-query";
import { useState, useCallback } from "react";
import { keys } from "../../core/keys";
import { useFlowCtx } from "../../core/provider";
import type { TodoListTemplateListParams } from "../server/queries";
import type {
  FlowTodoListTemplate,
  FlowTodoListTemplateCreate,
  FlowTodoListTemplateUpdate,
} from "../types/schemas";

export function useTodoListTemplate(
  id: string,
  options?: Omit<
    UseQueryOptions<FlowTodoListTemplate | null>,
    "queryKey" | "queryFn"
  >,
) {
  const ctx = useFlowCtx();

  return useQuery({
    queryKey: keys.m("TodoListTemplate").byId(String(id)),
    queryFn: async () => {
      const { getTodoListTemplateById } = await import("../server/queries");
      return getTodoListTemplateById(id, ctx);
    },
    ...options,
  });
}

export function useTodoListTemplateList(
  params?: TodoListTemplateListParams,
  options?: Omit<
    UseQueryOptions<{ items: FlowTodoListTemplate[]; total: number }>,
    "queryKey" | "queryFn"
  >,
) {
  const ctx = useFlowCtx();
  const [localParams, setLocalParams] = useState(params || {});

  const query = useQuery({
    queryKey: keys.m("TodoListTemplate").list(localParams),
    queryFn: async () => {
      const { listTodoListTemplates } = await import("../server/queries");
      return listTodoListTemplates(localParams, ctx);
    },
    ...options,
  });

  return {
    ...query,
    params: localParams,
    setParams: setLocalParams,
    nextPage: useCallback(() => {
      if (query.data && localParams.take) {
        const skip = (localParams.skip || 0) + localParams.take;
        if (skip < query.data.total) {
          setLocalParams((prev) => ({ ...prev, skip }));
        }
      }
    }, [query.data, localParams]),
    previousPage: useCallback(() => {
      if (localParams.skip && localParams.take) {
        const skip = Math.max(0, localParams.skip - localParams.take);
        setLocalParams((prev) => ({ ...prev, skip }));
      }
    }, [localParams]),
  };
}

export function useCreateTodoListTemplate(
  options?: UseMutationOptions<
    FlowTodoListTemplate,
    Error,
    FlowTodoListTemplateCreate
  >,
) {
  const ctx = useFlowCtx();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: FlowTodoListTemplateCreate) => {
      const { createTodoListTemplate } = await import("../server/actions");
      return createTodoListTemplate(data, ctx);
    },
    onSuccess: (data, variables, context) => {
      queryClient.invalidateQueries({
        queryKey: [keys.m("TodoListTemplate").tag()],
      });
      options?.onSuccess?.(data, variables, context);
    },
    ...options,
  });
}

export function useUpdateTodoListTemplate(
  id: string,
  options?: UseMutationOptions<
    FlowTodoListTemplate,
    Error,
    FlowTodoListTemplateUpdate
  >,
) {
  const ctx = useFlowCtx();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: FlowTodoListTemplateUpdate) => {
      const { updateTodoListTemplate } = await import("../server/actions");
      return updateTodoListTemplate(id, data, ctx);
    },
    onMutate: async (newData) => {
      // Optimistic update
      await queryClient.cancelQueries({
        queryKey: keys.m("TodoListTemplate").byId(String(id)),
      });
      const previousData = queryClient.getQueryData(
        keys.m("TodoListTemplate").byId(String(id)),
      );

      queryClient.setQueryData(
        keys.m("TodoListTemplate").byId(String(id)),
        (old: any) => (old ? { ...old, ...newData } : old),
      );

      return { previousData };
    },
    onError: (err, newData, context: any) => {
      // Revert optimistic update on error
      if (context?.previousData) {
        queryClient.setQueryData(
          keys.m("TodoListTemplate").byId(String(id)),
          context.previousData,
        );
      }
      options?.onError?.(err, newData, context);
    },
    onSettled: () => {
      queryClient.invalidateQueries({
        queryKey: keys.m("TodoListTemplate").byId(String(id)),
      });
      queryClient.invalidateQueries({
        queryKey: [keys.m("TodoListTemplate").tag()],
      });
    },
    ...options,
  });
}

export function useDeleteTodoListTemplate(
  options?: UseMutationOptions<void, Error, string>,
) {
  const ctx = useFlowCtx();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (id: string) => {
      const { deleteTodoListTemplate } = await import("../server/actions");
      return deleteTodoListTemplate(id, ctx);
    },
    onSuccess: (data, id, context) => {
      queryClient.invalidateQueries({
        queryKey: keys.m("TodoListTemplate").byId(String(id)),
      });
      queryClient.invalidateQueries({
        queryKey: [keys.m("TodoListTemplate").tag()],
      });
      options?.onSuccess?.(data, id, context);
    },
    ...options,
  });
}

export function useTodoListTemplateMutation(options?: {
  mode: "create" | "update";
  id?: string;
  onSuccess?: (data: FlowTodoListTemplate) => void;
  onError?: (error: Error) => void;
}) {
  const { mode = "create", id, onSuccess, onError } = options || {};

  const createMutation = useCreateTodoListTemplate({
    onSuccess,
    onError,
  });

  const updateMutation = useUpdateTodoListTemplate(id!, {
    onSuccess,
    onError,
  });

  if (mode === "update" && id) {
    return updateMutation;
  }

  return createMutation as typeof createMutation;
}
