// @generated by next-prisma-flow-state-engine
// file: client/forms.ts

"use client";

import { useCallback, useEffect, useState, useRef } from "react";
import {
  useForm,
  type UseFormReturn,
  type UseFormProps,
  type Path,
  type PathValue,
  type FieldErrors,
} from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  TodoListTemplateCreateSchema,
  TodoListTemplateUpdateSchema,
} from "../types/schemas";
import type {
  FlowTodoListTemplate,
  FlowTodoListTemplateCreate,
  FlowTodoListTemplateUpdate,
} from "../types/schemas";
import {
  useTodoListTemplate,
  useCreateTodoListTemplate,
  useUpdateTodoListTemplate,
} from "./hooks";
import {
  useTodoListTemplateFormAutosave,
  useTodoListTemplateFormFieldTracking,
  useTodoListTemplateFormHistory,
} from "./composables";

export type TodoListTemplateFieldState = {
  isDirty: boolean;
  isTouched: boolean;
  error?: any;
  current: any;
  original?: any;
  hasChanged?: boolean;
};

export type TodoListTemplateDirtyField = {
  field: string;
  original?: any;
  current: any;
};

export type TodoListTemplateAutosaveConfig = {
  enabled: boolean;
  debounceMs?: number;
  fields?: string[];
  onFieldSave?: (field: string, value: any) => void;
  onFieldError?: (field: string, error: Error) => void;
};

export type TodoListTemplateFormFeatures = {
  autosave?: TodoListTemplateAutosaveConfig | boolean;
  tracking?: boolean;
  history?:
    | {
        enabled: boolean;
        maxHistorySize?: number;
      }
    | boolean;
};

// Create form options
export type TodoListTemplateCreateFormOptions = {
  defaultValues?: Partial<FlowTodoListTemplateCreate>;
  onSuccess?: (data: FlowTodoListTemplate) => void;
  onError?: (error: Error) => void;
  formOptions?: Omit<
    UseFormProps<FlowTodoListTemplateCreate>,
    "resolver" | "defaultValues"
  >;
  features?: TodoListTemplateFormFeatures;
};

export type TodoListTemplateUpdateFormOptions = {
  defaultValues?: Partial<FlowTodoListTemplateUpdate>;
  onSuccess?: (data: FlowTodoListTemplate) => void;
  onError?: (error: Error) => void;
  formOptions?: Omit<
    UseFormProps<FlowTodoListTemplateUpdate>,
    "resolver" | "defaultValues"
  >;
  features?: TodoListTemplateFormFeatures;
};

function extractScalarFields(data: any): any {
  const result: any = {};
  Object.keys(data).forEach((key) => {
    const value = data[key];
    if (
      value === null ||
      (typeof value !== "object" && !Array.isArray(value))
    ) {
      result[key] = value;
    }
  });
  return result;
}

export function useCreateTodoListTemplateForm(
  options?: TodoListTemplateCreateFormOptions,
) {
  const { defaultValues, onSuccess, onError, formOptions, features } =
    options || {};

  const form = useForm<FlowTodoListTemplateCreate>({
    ...formOptions,
    resolver: zodResolver(TodoListTemplateCreateSchema),
    defaultValues: defaultValues as FlowTodoListTemplateCreate,
  });

  const mutation = useCreateTodoListTemplate({
    onSuccess: (data) => {
      form.reset();
      onSuccess?.(data);
    },
    onError,
  });

  // Field operations
  const getFieldState = useCallback(
    (name: Path<FlowTodoListTemplateCreate>): TodoListTemplateFieldState => {
      const fieldState = form.getFieldState(name);
      return {
        isDirty: fieldState.isDirty,
        isTouched: fieldState.isTouched,
        error: fieldState.error,
        current: form.getValues(name),
        original: (form.formState.defaultValues as any)?.[name],
      };
    },
    [form],
  );

  const resetField = useCallback(
    (name: Path<FlowTodoListTemplateCreate>) => {
      form.resetField(name);
    },
    [form],
  );

  const setFieldValue = useCallback(
    <T extends Path<FlowTodoListTemplateCreate>>(
      name: T,
      value: PathValue<FlowTodoListTemplateCreate, T>,
      options?: {
        shouldValidate?: boolean;
        shouldDirty?: boolean;
        shouldTouch?: boolean;
      },
    ) => {
      form.setValue(name, value, options);
    },
    [form],
  );

  const validateField = useCallback(
    (name: Path<FlowTodoListTemplateCreate>) => {
      return form.trigger(name);
    },
    [form],
  );

  const clearFieldError = useCallback(
    (name: Path<FlowTodoListTemplateCreate>) => {
      form.clearErrors(name);
    },
    [form],
  );

  const batchUpdate = useCallback(
    (updates: Partial<FlowTodoListTemplateCreate>) => {
      Object.entries(updates).forEach(([key, value]) => {
        form.setValue(key as Path<FlowTodoListTemplateCreate>, value as any);
      });
    },
    [form],
  );

  const getDirtyFields = useCallback((): TodoListTemplateDirtyField[] => {
    const dirtyFields: TodoListTemplateDirtyField[] = [];
    Object.keys(form.formState.dirtyFields).forEach((key) => {
      if ((form.formState.dirtyFields as any)[key]) {
        dirtyFields.push({
          field: key,
          original: (form.formState.defaultValues as any)?.[key],
          current: form.getValues(key as Path<FlowTodoListTemplateCreate>),
        });
      }
    });
    return dirtyFields;
  }, [form]);

  // Submit handler
  const submit = useCallback(
    (data: FlowTodoListTemplateCreate) => {
      console.log("[TodoListTemplateCreateForm] Submitting:", data);
      return mutation.mutate(data);
    },
    [mutation],
  );

  const onInvalid = useCallback((errors: any) => {
    console.error("[TodoListTemplateCreateForm] Validation failed:", errors);
  }, []);

  // Always call composables (no conditional hooks)
  const autosaveConfig =
    typeof features?.autosave === "object"
      ? features.autosave
      : { enabled: !!features?.autosave };
  const autosave = useTodoListTemplateFormAutosave(
    form,
    mutation,
    autosaveConfig,
  );

  const tracking = useTodoListTemplateFormFieldTracking(form);

  const historyConfig =
    typeof features?.history === "object"
      ? features.history
      : { enabled: !!features?.history };
  const history = useTodoListTemplateFormHistory(form, historyConfig);

  return {
    form,
    mutation,
    submit: form.handleSubmit(submit, onInvalid),
    isSubmitting: mutation.isPending,
    error: mutation.error,
    isSuccess: mutation.isSuccess,
    reset: () => form.reset(),
    // Field operations
    getFieldState,
    resetField,
    setFieldValue,
    validateField,
    clearFieldError,
    batchUpdate,
    getDirtyFields,
    // Include features if enabled
    ...(autosaveConfig.enabled ? { autosave } : {}),
    ...(features?.tracking ? { tracking } : {}),
    ...(historyConfig.enabled ? { history } : {}),
  };
}

export function useUpdateTodoListTemplateForm(
  id: string,
  options?: TodoListTemplateUpdateFormOptions,
) {
  const { defaultValues, onSuccess, onError, formOptions, features } =
    options || {};

  const originalRef = useRef<FlowTodoListTemplate>();

  // Fetch existing data
  const { data: existingData } = useTodoListTemplate(id);

  // Initialize form
  const form = useForm<FlowTodoListTemplateUpdate>({
    ...formOptions,
    resolver: zodResolver(TodoListTemplateUpdateSchema),
    defaultValues: defaultValues as FlowTodoListTemplateUpdate,
  });

  // Track autosave ref to use in useEffect
  const autosaveRef =
    useRef<ReturnType<typeof useTodoListTemplateFormAutosave>>();

  // Update form when existing data loads
  useEffect(() => {
    if (existingData) {
      originalRef.current = existingData;
      const scalarData = extractScalarFields(existingData);
      console.log("[TodoListTemplateUpdateForm] Loading data:", scalarData);

      // Pause autosave during form reset to prevent loops
      if (autosaveRef.current?.pauseAutosave) {
        autosaveRef.current.pauseAutosave(() => {
          form.reset(scalarData as FlowTodoListTemplateUpdate, {
            keepDirtyValues: true,
            keepErrors: true,
          });
        });
      } else {
        form.reset(scalarData as FlowTodoListTemplateUpdate, {
          keepDirtyValues: true,
          keepErrors: true,
        });
      }
    }
  }, [existingData, form]);

  // Update mutation
  const mutation = useUpdateTodoListTemplate(id, {
    onSuccess,
    onError,
  });

  // Field operations with original comparison
  const getFieldState = useCallback(
    (name: Path<FlowTodoListTemplateUpdate>): TodoListTemplateFieldState => {
      const fieldState = form.getFieldState(name);
      const currentValue = form.getValues(name);
      const originalValue =
        originalRef.current?.[name as keyof FlowTodoListTemplate];
      return {
        isDirty: fieldState.isDirty,
        isTouched: fieldState.isTouched,
        error: fieldState.error,
        current: currentValue,
        original: originalValue,
        hasChanged: currentValue !== originalValue,
      };
    },
    [form],
  );

  const resetField = useCallback(
    (name: Path<FlowTodoListTemplateUpdate>) => {
      const originalValue =
        originalRef.current?.[name as keyof FlowTodoListTemplate];
      form.setValue(name, originalValue as any);
      form.clearErrors(name);
    },
    [form],
  );

  const setFieldValue = useCallback(
    <T extends Path<FlowTodoListTemplateUpdate>>(
      name: T,
      value: PathValue<FlowTodoListTemplateUpdate, T>,
      options?: {
        shouldValidate?: boolean;
        shouldDirty?: boolean;
        shouldTouch?: boolean;
      },
    ) => {
      form.setValue(name, value, options);
    },
    [form],
  );

  const validateField = useCallback(
    (name: Path<FlowTodoListTemplateUpdate>) => {
      return form.trigger(name);
    },
    [form],
  );

  const clearFieldError = useCallback(
    (name: Path<FlowTodoListTemplateUpdate>) => {
      form.clearErrors(name);
    },
    [form],
  );

  const batchUpdate = useCallback(
    (updates: Partial<FlowTodoListTemplateUpdate>) => {
      Object.entries(updates).forEach(([key, value]) => {
        form.setValue(key as Path<FlowTodoListTemplateUpdate>, value as any);
      });
    },
    [form],
  );

  const getDirtyFields = useCallback((): TodoListTemplateDirtyField[] => {
    const dirtyFields: TodoListTemplateDirtyField[] = [];
    Object.keys(form.formState.dirtyFields).forEach((key) => {
      if ((form.formState.dirtyFields as any)[key]) {
        dirtyFields.push({
          field: key,
          original: originalRef.current?.[key as keyof FlowTodoListTemplate],
          current: form.getValues(key as Path<FlowTodoListTemplateUpdate>),
        });
      }
    });
    return dirtyFields;
  }, [form]);

  // Submit handler
  const submit = useCallback(
    (data: FlowTodoListTemplateUpdate) => {
      console.log("[TodoListTemplateUpdateForm] Submitting:", data);
      return mutation.mutate(data);
    },
    [mutation],
  );

  const onInvalid = useCallback((errors: any) => {
    console.error("[TodoListTemplateUpdateForm] Validation failed:", errors);
  }, []);

  // Always call composables (no conditional hooks)
  const autosaveConfig =
    typeof features?.autosave === "object"
      ? features.autosave
      : { enabled: !!features?.autosave };
  const autosave = useTodoListTemplateFormAutosave(
    form,
    mutation,
    autosaveConfig,
  );

  // Store autosave ref for use in useEffect
  useEffect(() => {
    autosaveRef.current = autosave;
  }, [autosave]);

  const tracking = useTodoListTemplateFormFieldTracking(
    form,
    originalRef.current,
  );

  const historyConfig =
    typeof features?.history === "object"
      ? features.history
      : { enabled: !!features?.history };
  const history = useTodoListTemplateFormHistory(form, historyConfig);

  return {
    form,
    mutation,
    original: originalRef.current,
    submit: form.handleSubmit(submit, onInvalid),
    isSubmitting: mutation.isPending,
    error: mutation.error,
    isSuccess: mutation.isSuccess,
    reset: () => form.reset(extractScalarFields(originalRef.current || {})),
    // Field operations
    getFieldState,
    resetField,
    setFieldValue,
    validateField,
    clearFieldError,
    batchUpdate,
    getDirtyFields,
    // Include features if enabled
    ...(autosaveConfig.enabled ? { autosave } : {}),
    ...(features?.tracking ? { tracking } : {}),
    ...(historyConfig.enabled ? { history } : {}),
  };
}

export type TodoListTemplateCreateFormProps = {
  form: UseFormReturn<FlowTodoListTemplateCreate>;
  onSubmit: () => void;
  isSubmitting: boolean;
  error?: Error | null;
};

export type TodoListTemplateUpdateFormProps = {
  form: UseFormReturn<FlowTodoListTemplateUpdate>;
  onSubmit: () => void;
  isSubmitting: boolean;
  error?: Error | null;
  original?: FlowTodoListTemplate;
};
