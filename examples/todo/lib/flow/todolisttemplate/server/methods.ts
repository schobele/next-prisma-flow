// @generated by next-prisma-flow-state-engine
// file: server/methods.ts

"use server";

import { prisma } from "../../prisma";
import type { Prisma } from "../../prisma";
import { FlowCtx, FlowPolicyError, deepMergePrismaData } from "../../core";
import { canTodoListTemplate } from "../../policies";
import { TodoListTemplateSelect } from "./selects";
import type { FlowTodoListTemplate } from "../types/schemas";

export async function findUnique(
  args: Prisma.TodoListTemplateFindUniqueArgs,
  ctx: FlowCtx = {},
): Promise<FlowTodoListTemplate | null> {
  const policy = await canTodoListTemplate("read", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  return prisma.todoListTemplate.findUnique({
    select: TodoListTemplateSelect,
    ...args,
    where: { ...args.where, ...policy.where },
  }) as Promise<FlowTodoListTemplate | null>;
}

export async function findUniqueOrThrow(
  args: Prisma.TodoListTemplateFindUniqueOrThrowArgs,
  ctx: FlowCtx = {},
): Promise<FlowTodoListTemplate> {
  const policy = await canTodoListTemplate("read", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  return prisma.todoListTemplate.findUniqueOrThrow({
    select: TodoListTemplateSelect,
    ...args,
    where: { ...args.where, ...policy.where },
  }) as Promise<FlowTodoListTemplate>;
}

export async function findFirst(
  args?: Prisma.TodoListTemplateFindFirstArgs,
  ctx: FlowCtx = {},
): Promise<FlowTodoListTemplate | null> {
  const policy = await canTodoListTemplate("list", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  return prisma.todoListTemplate.findFirst({
    select: TodoListTemplateSelect,
    ...args,
    where: { ...args?.where, ...policy.where },
  }) as Promise<FlowTodoListTemplate | null>;
}

export async function findFirstOrThrow(
  args?: Prisma.TodoListTemplateFindFirstOrThrowArgs,
  ctx: FlowCtx = {},
): Promise<FlowTodoListTemplate> {
  const policy = await canTodoListTemplate("list", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  return prisma.todoListTemplate.findFirstOrThrow({
    select: TodoListTemplateSelect,
    ...args,
    where: { ...args?.where, ...policy.where },
  }) as Promise<FlowTodoListTemplate>;
}

export async function findMany(
  args?: Prisma.TodoListTemplateFindManyArgs,
  ctx: FlowCtx = {},
): Promise<FlowTodoListTemplate[]> {
  const policy = await canTodoListTemplate("list", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  return prisma.todoListTemplate.findMany({
    select: TodoListTemplateSelect,
    ...args,
    where: { ...args?.where, ...policy.where },
  }) as Promise<FlowTodoListTemplate[]>;
}

export async function create(
  args: Prisma.TodoListTemplateCreateArgs,
  ctx: FlowCtx = {},
): Promise<FlowTodoListTemplate> {
  const policy = await canTodoListTemplate("create", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  const result = (await prisma.todoListTemplate.create({
    select: TodoListTemplateSelect,
    ...args,
    data: deepMergePrismaData(args.data, policy.data || {}, "TodoListTemplate"),
  })) as FlowTodoListTemplate;

  return result;
}

export async function createMany(
  args: Prisma.TodoListTemplateCreateManyArgs,
  ctx: FlowCtx = {},
) {
  const policy = await canTodoListTemplate("create", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  // Apply policy data to each item using deep merge
  const data = Array.isArray(args.data)
    ? args.data.map((item) =>
        deepMergePrismaData(item, policy.data || {}, "TodoListTemplate"),
      )
    : deepMergePrismaData(args.data, policy.data || {});

  return prisma.todoListTemplate.createMany({
    ...args,
    data,
  });
}

export async function update(
  args: Prisma.TodoListTemplateUpdateArgs,
  ctx: FlowCtx = {},
): Promise<FlowTodoListTemplate> {
  const policy = await canTodoListTemplate("update", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  const result = (await prisma.todoListTemplate.update({
    select: TodoListTemplateSelect,
    ...args,
    where: { ...args.where, ...policy.where },
    data: deepMergePrismaData(args.data, policy.data || {}, "TodoListTemplate"),
  })) as FlowTodoListTemplate;

  return result;
}

export async function updateMany(
  args: Prisma.TodoListTemplateUpdateManyArgs,
  ctx: FlowCtx = {},
) {
  const policy = await canTodoListTemplate("update", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  return prisma.todoListTemplate.updateMany({
    ...args,
    where: { ...args.where, ...policy.where },
    data: deepMergePrismaData(args.data, policy.data || {}, "TodoListTemplate"),
  });
}

export async function upsert(
  args: Prisma.TodoListTemplateUpsertArgs,
  ctx: FlowCtx = {},
): Promise<FlowTodoListTemplate> {
  // Check both create and update policies
  const createPolicy = await canTodoListTemplate("create", ctx);
  const updatePolicy = await canTodoListTemplate("update", ctx);

  // Need both permissions for upsert
  if (!createPolicy.ok || !updatePolicy.ok) {
    throw new FlowPolicyError("Insufficient permissions for upsert");
  }

  return prisma.todoListTemplate.upsert({
    select: TodoListTemplateSelect,
    ...args,
    where: { ...args.where, ...updatePolicy.where },
    create: deepMergePrismaData(
      args.create,
      createPolicy.data || {},
      "TodoListTemplate",
    ),
    update: deepMergePrismaData(
      args.update,
      updatePolicy.data || {},
      "TodoListTemplate",
    ),
  }) as Promise<FlowTodoListTemplate>;
}

export async function deleteOne(
  args: Prisma.TodoListTemplateDeleteArgs,
  ctx: FlowCtx = {},
) {
  const policy = await canTodoListTemplate("delete", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  return prisma.todoListTemplate.delete({
    ...args,
    where: { ...args.where, ...policy.where },
  });
}

export async function deleteMany(
  args?: Prisma.TodoListTemplateDeleteManyArgs,
  ctx: FlowCtx = {},
) {
  const policy = await canTodoListTemplate("delete", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  return prisma.todoListTemplate.deleteMany({
    ...args,
    where: { ...args?.where, ...policy.where },
  });
}

export async function count(
  args?: Prisma.TodoListTemplateCountArgs,
  ctx: FlowCtx = {},
) {
  const policy = await canTodoListTemplate("list", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  return prisma.todoListTemplate.count({
    ...args,
    where: { ...args?.where, ...policy.where },
  });
}

export async function aggregate(
  args: Prisma.TodoListTemplateAggregateArgs,
  ctx: FlowCtx = {},
) {
  const policy = await canTodoListTemplate("list", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  return prisma.todoListTemplate.aggregate({
    ...args,
    where: { ...args.where, ...policy.where },
  });
}

export async function groupBy<
  T extends Prisma.TodoListTemplateGroupByArgs,
  HasSelectOrTake extends Prisma.Or<
    Prisma.Extends<"skip", Prisma.Keys<T>>,
    Prisma.Extends<"take", Prisma.Keys<T>>
  >,
  OrderByArg extends Prisma.True extends HasSelectOrTake
    ? { orderBy: Prisma.TodoListTemplateGroupByArgs["orderBy"] }
    : { orderBy?: Prisma.TodoListTemplateGroupByArgs["orderBy"] },
  OrderFields extends Prisma.ExcludeUnderscoreKeys<
    Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
  >,
  ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
  ByValid extends Prisma.Has<ByFields, OrderFields>,
  HavingFields extends Prisma.GetHavingFields<T["having"]>,
  HavingValid extends Prisma.Has<ByFields, HavingFields>,
  ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
  InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  "Field ",
                  P,
                  ` used in "having" needs to be provided in "by"`,
                ];
        }[HavingFields]
      : "take" extends Prisma.Keys<T>
        ? "orderBy" extends Prisma.Keys<T>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Prisma.Keys<T>
          ? "orderBy" extends Prisma.Keys<T>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields]
            : 'Error: If you provide "skip", you also need to provide "orderBy"'
          : ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
              }[OrderFields],
>(
  args: Prisma.SubsetIntersection<
    T,
    Prisma.TodoListTemplateGroupByArgs,
    OrderByArg
  > &
    InputErrors,
  ctx: FlowCtx = {},
): Promise<
  {} extends InputErrors
    ? Prisma.GetTodoListTemplateGroupByPayload<T>
    : InputErrors
> {
  const policy = await canTodoListTemplate("list", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  return prisma.todoListTemplate.groupBy({
    ...(args as any),
    where: { ...args.where, ...policy.where },
  } as any) as any;
}
