// @generated by next-prisma-flow-state-engine
// file: server/actions.ts

"use server";

import { prisma } from "../../prisma";
import {
  invalidateTags,
  keys,
  FlowCtx,
  FlowPolicyError,
  FlowValidationError,
  deepMergePrismaData,
} from "../../core";
import { canTodoListTemplate } from "../../policies";
import { TodoListTemplateSelect } from "./selects";
import {
  TodoListTemplateCreateSchema,
  TodoListTemplateUpdateSchema,
} from "../types/schemas";
import type {
  FlowTodoListTemplate,
  FlowTodoListTemplateCreate,
  FlowTodoListTemplateUpdate,
} from "../types/schemas";
import {
  transformTodoListTemplateCreate,
  transformTodoListTemplateUpdate,
} from "../types/transforms";

// Transform Prisma response to match FlowPost schema (null -> undefined for relations)
function transformResponse(item: any): any {
  if (!item) return item;
  const result = { ...item };
  return result;
}

export async function createTodoListTemplate(
  data: FlowTodoListTemplateCreate,
  ctx: FlowCtx = {},
): Promise<FlowTodoListTemplate> {
  const policy = await canTodoListTemplate("create", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  const parsed = TodoListTemplateCreateSchema.safeParse(data);
  if (!parsed.success) {
    throw new FlowValidationError(parsed.error.issues);
  }

  const createData = transformTodoListTemplateCreate(parsed.data as any);
  const item = (await prisma.todoListTemplate.create({
    data: deepMergePrismaData(
      createData,
      policy.data || {},
      "TodoListTemplate",
    ),
    select: TodoListTemplateSelect,
  })) as FlowTodoListTemplate;

  await invalidateTags([keys.m("TodoListTemplate").tag()]);
  return transformResponse(item) as FlowTodoListTemplate;
}

export async function updateTodoListTemplate(
  id: string,
  data: FlowTodoListTemplateUpdate,
  ctx: FlowCtx = {},
): Promise<FlowTodoListTemplate> {
  const policy = await canTodoListTemplate("update", ctx || {}, id);
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  const parsed = TodoListTemplateUpdateSchema.safeParse(data);
  if (!parsed.success) {
    throw new FlowValidationError(parsed.error.issues);
  }

  const updateData = transformTodoListTemplateUpdate(parsed.data as any);
  const item = (await prisma.todoListTemplate.update({
    where: { id: id, ...policy.where },
    data: deepMergePrismaData(
      updateData,
      policy.data || {},
      "TodoListTemplate",
    ),
    select: TodoListTemplateSelect,
  })) as FlowTodoListTemplate;

  await invalidateTags([
    keys.m("TodoListTemplate").tag(),
    keys.m("TodoListTemplate").tag(String(id)),
  ]);
  return transformResponse(item) as FlowTodoListTemplate;
}

export async function deleteTodoListTemplate(
  id: string,
  ctx?: FlowCtx,
): Promise<void> {
  const policy = await canTodoListTemplate("delete", ctx || {}, id);
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  await prisma.todoListTemplate.delete({
    where: { id: id, ...policy.where },
  });

  await invalidateTags([
    keys.m("TodoListTemplate").tag(),
    keys.m("TodoListTemplate").tag(String(id)),
  ]);
}
