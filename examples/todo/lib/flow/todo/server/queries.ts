// @generated by next-prisma-flow-state-engine
// file: server/queries.ts

"use server";

import { prisma } from "../../prisma";
import { cacheTagged, FlowCtx, FlowPolicyError } from "../../core";
import { canTodo } from "../../policies";
import { TodoSelect } from "./selects";
import type { Prisma } from "../../prisma";
import type { FlowTodo } from "../types/schemas";

// Transform Prisma response to match FlowTodo schema (null -> undefined for relations)
function transformResponse(item: any): any {
  if (!item) return item;
  const result = { ...item };
  if (result.parent === null) result.parent = undefined;
  return result;
}

function transformResponseList(items: any[]): any[] {
  return items.map(transformResponse);
}

export const getTodoById = cacheTagged(async function (
  id: string,
  ctx: FlowCtx = {},
): Promise<FlowTodo | null> {
  const policy = await canTodo("read", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  const item = (await prisma.todo.findUnique({
    where: { id: id, ...policy.where },
    select: TodoSelect,
  })) as FlowTodo | null;

  return transformResponse(item) as FlowTodo | null;
});

export type TodoListParams = {
  where?: Prisma.TodoWhereInput;
  orderBy?:
    | Prisma.TodoOrderByWithRelationInput
    | Prisma.TodoOrderByWithRelationInput[];
  skip?: number;
  take?: number;
  cursor?: Prisma.TodoWhereUniqueInput;
};

export const listTodos = cacheTagged(async function (
  params: TodoListParams = {},
  ctx: FlowCtx = {},
): Promise<{ items: FlowTodo[]; total: number }> {
  const policy = await canTodo("list", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  const where = { ...params.where, ...policy.where };

  const [items, total] = await Promise.all([
    prisma.todo.findMany({
      where,
      orderBy: params.orderBy,
      skip: params.skip,
      take: params.take || 50,
      cursor: params.cursor,
      select: TodoSelect,
    }) as Promise<FlowTodo[]>,
    prisma.todo.count({ where }),
  ]);

  return { items: transformResponseList(items) as FlowTodo[], total };
});

export const searchTodos = cacheTagged(async function (
  query: string,
  params: Omit<TodoListParams, "where"> = {},
  ctx: FlowCtx = {},
): Promise<{ items: FlowTodo[]; total: number }> {
  const policy = await canTodo("list", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  const where = {
    AND: [
      policy.where,
      {
        OR: [
          { title: { contains: query, mode: "insensitive" as const } },
          { description: { contains: query, mode: "insensitive" as const } },
          { status: { contains: query, mode: "insensitive" as const } },
          { priority: { contains: query, mode: "insensitive" as const } },
          { companyId: { contains: query, mode: "insensitive" as const } },
          { listId: { contains: query, mode: "insensitive" as const } },
          { userId: { contains: query, mode: "insensitive" as const } },
          { parentId: { contains: query, mode: "insensitive" as const } },
        ],
      },
    ],
  };

  const [items, total] = await Promise.all([
    prisma.todo.findMany({
      where,
      orderBy: params.orderBy,
      skip: params.skip,
      take: params.take || 50,
      cursor: params.cursor,
      select: TodoSelect,
    }) as Promise<FlowTodo[]>,
    prisma.todo.count({ where }),
  ]);

  return { items: transformResponseList(items) as FlowTodo[], total };
});
