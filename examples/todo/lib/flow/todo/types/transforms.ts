// @generated by next-prisma-flow-state-engine
// file: types/transforms.ts

import type { Prisma } from "../../prisma";
import type { FlowTodoCreate, FlowTodoUpdate } from "./schemas";

export function transformTodoCreate(
  input: FlowTodoCreate,
): Prisma.TodoCreateInput {
  const result: any = {};

  result.title = input.title;
  if ("description" in input && input.description !== undefined) {
    result.description = input.description;
  }
  if ("status" in input && input.status !== undefined) {
    result.status = input.status;
  }
  if ("priority" in input && input.priority !== undefined) {
    result.priority = input.priority;
  }
  if ("dueDate" in input && input.dueDate !== undefined) {
    result.dueDate = input.dueDate;
  }
  if ("completedAt" in input && input.completedAt !== undefined) {
    result.completedAt = input.completedAt;
  }
  if ("orderIndex" in input && input.orderIndex !== undefined) {
    result.orderIndex = input.orderIndex;
  }
  if ("isArchived" in input && input.isArchived !== undefined) {
    result.isArchived = input.isArchived;
  }
  if ("createdAt" in input && input.createdAt !== undefined) {
    result.createdAt = input.createdAt;
  }
  if (input.company !== undefined) {
    const companyData = input.company;
    if (companyData) {
      if ("connect" in companyData && companyData.connect) {
        result.company = { connect: companyData.connect };
      } else if ("create" in companyData && companyData.create) {
        result.company = { create: companyData.create as any };
      } else if (
        "connectOrCreate" in companyData &&
        companyData.connectOrCreate
      ) {
        result.company = {
          connectOrCreate: companyData.connectOrCreate as any,
        };
      }
    }
  }
  // Handle foreign key field when relation is not provided
  if (input.company === undefined && "companyId" in input && input.companyId) {
    result.company = { connect: { id: input.companyId } };
  }
  if (input.list !== undefined) {
    const listData = input.list;
    if (listData) {
      if ("connect" in listData && listData.connect) {
        result.list = { connect: listData.connect };
      } else if ("create" in listData && listData.create) {
        result.list = { create: listData.create as any };
      } else if ("connectOrCreate" in listData && listData.connectOrCreate) {
        result.list = {
          connectOrCreate: listData.connectOrCreate as any,
        };
      }
    }
  }
  // Handle foreign key field when relation is not provided
  if (input.list === undefined && "listId" in input && input.listId) {
    result.list = { connect: { id: input.listId } };
  }
  if (input.user !== undefined) {
    const userData = input.user;
    if (userData) {
      if ("connect" in userData && userData.connect) {
        result.user = { connect: userData.connect };
      } else if ("create" in userData && userData.create) {
        result.user = { create: userData.create as any };
      } else if ("connectOrCreate" in userData && userData.connectOrCreate) {
        result.user = {
          connectOrCreate: userData.connectOrCreate as any,
        };
      }
    }
  }
  // Handle foreign key field when relation is not provided
  if (input.user === undefined && "userId" in input && input.userId) {
    result.user = { connect: { id: input.userId } };
  }
  if (input.parent !== undefined) {
    const parentData = input.parent;
    if (parentData) {
      if ("connect" in parentData && parentData.connect) {
        result.parent = { connect: parentData.connect };
      } else if ("create" in parentData && parentData.create) {
        result.parent = { create: parentData.create as any };
      } else if (
        "connectOrCreate" in parentData &&
        parentData.connectOrCreate
      ) {
        result.parent = {
          connectOrCreate: parentData.connectOrCreate as any,
        };
      }
    }
  }
  // Handle foreign key field when relation is not provided
  if (input.parent === undefined && "parentId" in input && input.parentId) {
    result.parent = { connect: { id: input.parentId } };
  }
  if (input.subtasks !== undefined) {
    const subtasksData = input.subtasks;
    if (subtasksData) {
      if ("connect" in subtasksData && subtasksData.connect) {
        result.subtasks = { connect: subtasksData.connect };
      } else if ("create" in subtasksData && subtasksData.create) {
        result.subtasks = {
          create: subtasksData.create as any,
        };
      } else if ("createMany" in subtasksData && subtasksData.createMany) {
      } else if (
        "connectOrCreate" in subtasksData &&
        subtasksData.connectOrCreate
      ) {
        result.subtasks = {
          connectOrCreate: subtasksData.connectOrCreate as any,
        };
      }
    }
  }
  if (input.tags !== undefined) {
    const tagsData = input.tags;
    if (tagsData) {
      if ("connect" in tagsData && tagsData.connect) {
        result.tags = { connect: tagsData.connect };
      } else if ("create" in tagsData && tagsData.create) {
        result.tags = {
          create: tagsData.create as any,
        };
      } else if ("createMany" in tagsData && tagsData.createMany) {
      } else if ("connectOrCreate" in tagsData && tagsData.connectOrCreate) {
        result.tags = {
          connectOrCreate: tagsData.connectOrCreate as any,
        };
      }
    }
  }

  return result;
}

export function transformTodoUpdate(
  input: FlowTodoUpdate,
): Prisma.TodoUpdateInput {
  const result: any = {};

  const titleValue = input.title;
  if (titleValue !== undefined && titleValue !== null) {
    result.title = titleValue;
  }
  const descriptionValue = input.description;
  if (descriptionValue !== undefined) {
    result.description = descriptionValue;
  }
  const statusValue = input.status;
  if (statusValue !== undefined && statusValue !== null) {
    result.status = statusValue;
  }
  const priorityValue = input.priority;
  if (priorityValue !== undefined && priorityValue !== null) {
    result.priority = priorityValue;
  }
  const dueDateValue = input.dueDate;
  if (dueDateValue !== undefined) {
    result.dueDate = dueDateValue;
  }
  const completedAtValue = input.completedAt;
  if (completedAtValue !== undefined) {
    result.completedAt = completedAtValue;
  }
  const orderIndexValue = input.orderIndex;
  if (orderIndexValue !== undefined && orderIndexValue !== null) {
    result.orderIndex = orderIndexValue;
  }
  const isArchivedValue = input.isArchived;
  if (isArchivedValue !== undefined && isArchivedValue !== null) {
    result.isArchived = isArchivedValue;
  }
  const createdAtValue = input.createdAt;
  if (createdAtValue !== undefined && createdAtValue !== null) {
    result.createdAt = createdAtValue;
  }
  if (input.company !== undefined) {
    const companyData = input.company;
    if (companyData) {
      result.company = companyData as any;
    }
  }
  if (input.list !== undefined) {
    const listData = input.list;
    if (listData) {
      result.list = listData as any;
    }
  }
  if (input.user !== undefined) {
    const userData = input.user;
    if (userData) {
      result.user = userData as any;
    }
  }
  if (input.parent !== undefined) {
    const parentData = input.parent;
    if (parentData) {
      result.parent = parentData as any;
    }
  }
  if (input.subtasks !== undefined) {
    const subtasksData = input.subtasks;
    if (subtasksData) {
      result.subtasks = subtasksData as any;
    }
  }
  if (input.tags !== undefined) {
    const tagsData = input.tags;
    if (tagsData) {
      result.tags = tagsData as any;
    }
  }

  return result;
}
