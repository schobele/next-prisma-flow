// @generated by next-prisma-flow-state-engine
// file: policies.ts

import type { FlowCtx } from "./core";

/**
 * Policy result that controls data access
 * - ok: Whether the operation is allowed
 * - message: Error message if denied
 * - where: Additional conditions for queries
 * - data: Data to merge into mutations (uses deep merge for nested operations)
 */
type PolicyResult = {
  ok: boolean;
  message?: string;
  where?: any;
  data?: any;
};

type PolicyAction = "list" | "read" | "create" | "update" | "delete";

/**
 * Multi-tenancy configuration
 * Tenant field: companyId
 * Tenant model: Company
 *
 * The policy data is deeply merged with operation data, ensuring
 * tenant isolation even for nested creates and updates.
 *
 * Example: When creating a Todo with a nested List creation,
 * both the Todo AND the nested List will receive the tenant connection.
 */

export async function canCompany(
  action: PolicyAction,
  ctx: FlowCtx,
  id?: string,
): Promise<PolicyResult> {
  // Default: allow all for authenticated users
  if (!ctx.userId) {
    return { ok: false, message: "Authentication required" };
  }

  switch (action) {
    case "list":
    case "read":
      // Tenant filtering if model has tenant field
      return { ok: true, where: {} };

    case "create":
      return { ok: true, data: {} };

    case "update":
      // For update, provide both where (for filtering) and data (for nested creates)
      return { ok: true, where: {}, data: {} };

    case "delete":
      // Ownership check could be added here
      return { ok: true, where: {} };

    default:
      return { ok: false, message: "Unknown action" };
  }
}

export async function canUser(
  action: PolicyAction,
  ctx: FlowCtx,
  id?: string,
): Promise<PolicyResult> {
  // Default: allow all for authenticated users
  if (!ctx.userId) {
    return { ok: false, message: "Authentication required" };
  }

  switch (action) {
    case "list":
    case "read":
      // Tenant filtering if model has tenant field
      return {
        ok: true,
        where: ctx.tenantId ? { companyId: ctx.tenantId } : {},
      };

    case "create":
      // Tenant connection will be deep-merged into nested creates as well
      return {
        ok: true,
        data: ctx.tenantId
          ? { company: { connect: { id: ctx.tenantId } } }
          : {},
      };

    case "update":
      // For update, provide both where (for filtering) and data (for nested creates)
      return {
        ok: true,
        where: ctx.tenantId ? { companyId: ctx.tenantId } : {},
        data: ctx.tenantId
          ? { company: { connect: { id: ctx.tenantId } } }
          : {},
      };

    case "delete":
      // Ownership check could be added here
      return {
        ok: true,
        where: ctx.tenantId ? { companyId: ctx.tenantId } : {},
      };

    default:
      return { ok: false, message: "Unknown action" };
  }
}

export async function canList(
  action: PolicyAction,
  ctx: FlowCtx,
  id?: string,
): Promise<PolicyResult> {
  // Default: allow all for authenticated users
  if (!ctx.userId) {
    return { ok: false, message: "Authentication required" };
  }

  switch (action) {
    case "list":
    case "read":
      // Tenant filtering if model has tenant field
      return {
        ok: true,
        where: ctx.tenantId ? { companyId: ctx.tenantId } : {},
      };

    case "create":
      // Tenant connection will be deep-merged into nested creates as well
      return {
        ok: true,
        data: ctx.tenantId
          ? { company: { connect: { id: ctx.tenantId } } }
          : {},
      };

    case "update":
      // For update, provide both where (for filtering) and data (for nested creates)
      return {
        ok: true,
        where: ctx.tenantId ? { companyId: ctx.tenantId } : {},
        data: ctx.tenantId
          ? { company: { connect: { id: ctx.tenantId } } }
          : {},
      };

    case "delete":
      // Ownership check could be added here
      return {
        ok: true,
        where: ctx.tenantId ? { companyId: ctx.tenantId } : {},
      };

    default:
      return { ok: false, message: "Unknown action" };
  }
}

export async function canTodo(
  action: PolicyAction,
  ctx: FlowCtx,
  id?: string,
): Promise<PolicyResult> {
  // Default: allow all for authenticated users
  if (!ctx.userId) {
    return { ok: false, message: "Authentication required" };
  }

  switch (action) {
    case "list":
    case "read":
      // Tenant filtering if model has tenant field
      return {
        ok: true,
        where: ctx.tenantId ? { companyId: ctx.tenantId } : {},
      };

    case "create":
      // Tenant connection will be deep-merged into nested creates as well
      return {
        ok: true,
        data: ctx.tenantId
          ? { company: { connect: { id: ctx.tenantId } } }
          : {},
      };

    case "update":
      // For update, provide both where (for filtering) and data (for nested creates)
      return {
        ok: true,
        where: ctx.tenantId ? { companyId: ctx.tenantId } : {},
        data: ctx.tenantId
          ? { company: { connect: { id: ctx.tenantId } } }
          : {},
      };

    case "delete":
      // Ownership check could be added here
      return {
        ok: true,
        where: ctx.tenantId ? { companyId: ctx.tenantId } : {},
      };

    default:
      return { ok: false, message: "Unknown action" };
  }
}

export async function canTag(
  action: PolicyAction,
  ctx: FlowCtx,
  id?: string,
): Promise<PolicyResult> {
  // Default: allow all for authenticated users
  if (!ctx.userId) {
    return { ok: false, message: "Authentication required" };
  }

  switch (action) {
    case "list":
    case "read":
      // Tenant filtering if model has tenant field
      return {
        ok: true,
        where: ctx.tenantId ? { companyId: ctx.tenantId } : {},
      };

    case "create":
      // Tenant connection will be deep-merged into nested creates as well
      return {
        ok: true,
        data: ctx.tenantId
          ? { company_relation: { connect: { id: ctx.tenantId } } }
          : {},
      };

    case "update":
      // For update, provide both where (for filtering) and data (for nested creates)
      return {
        ok: true,
        where: ctx.tenantId ? { companyId: ctx.tenantId } : {},
        data: ctx.tenantId
          ? { company_relation: { connect: { id: ctx.tenantId } } }
          : {},
      };

    case "delete":
      // Ownership check could be added here
      return {
        ok: true,
        where: ctx.tenantId ? { companyId: ctx.tenantId } : {},
      };

    default:
      return { ok: false, message: "Unknown action" };
  }
}

export async function canTodoListTemplate(
  action: PolicyAction,
  ctx: FlowCtx,
  id?: string,
): Promise<PolicyResult> {
  // Default: allow all for authenticated users
  if (!ctx.userId) {
    return { ok: false, message: "Authentication required" };
  }

  switch (action) {
    case "list":
    case "read":
      // Tenant filtering if model has tenant field
      return { ok: true, where: {} };

    case "create":
      return { ok: true, data: {} };

    case "update":
      // For update, provide both where (for filtering) and data (for nested creates)
      return { ok: true, where: {}, data: {} };

    case "delete":
      // Ownership check could be added here
      return { ok: true, where: {} };

    default:
      return { ok: false, message: "Unknown action" };
  }
}
