// @generated by next-prisma-flow-state-engine
// file: core/field-wrapper.tsx

"use client";

import * as React from "react";
import {
  Controller,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form";

/**
 * Extended controller props with Flow-specific features
 */
export interface FlowFieldProps<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> extends ControllerProps<TFieldValues, TName> {
  /**
   * Transform value before setting in form
   */
  transform?: {
    input?: (value: any) => any;
    output?: (value: any) => any;
  };

  /**
   * Whether to trigger autosave on this field
   */
  autosave?: boolean;

  /**
   * Debounce delay for this specific field (overrides global setting)
   */
  debounceMs?: number;
}

/**
 * Enhanced field wrapper that extends react-hook-form's Controller
 * with Flow-specific features while maintaining compatibility with shadcn/ui
 */
export function FlowField<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  transform,
  autosave = true,
  debounceMs,
  render,
  ...props
}: FlowFieldProps<TFieldValues, TName>) {
  const form = useFormContext<TFieldValues>();

  // Create enhanced render function that applies transforms
  const enhancedRender = React.useCallback<NonNullable<typeof render>>(
    ({ field, fieldState, formState }) => {
      // Apply input transform to displayed value
      const transformedField = {
        ...field,
        value: transform?.input ? transform.input(field.value) : field.value,
        onChange: (value: any) => {
          // Apply output transform before setting in form
          const transformedValue = transform?.output
            ? transform.output(value)
            : value;
          field.onChange(transformedValue);
        },
      };

      // Call original render with transformed field
      return render!({ field: transformedField, fieldState, formState });
    },
    [render, transform],
  );

  return <Controller {...props} render={enhancedRender} />;
}

/**
 * Field metadata that can be provided by model-specific components
 */
export interface FlowFieldMeta {
  label?: string;
  description?: string;
  placeholder?: string;
  required?: boolean;
  disabled?: boolean;
  type?:
    | "text"
    | "email"
    | "password"
    | "number"
    | "tel"
    | "url"
    | "date"
    | "datetime-local"
    | "time"
    | "checkbox"
    | "radio"
    | "select"
    | "textarea";
  min?: number | string;
  max?: number | string;
  step?: number;
  pattern?: string;
  options?: Array<{ value: string; label: string; disabled?: boolean }>;
}

const FlowFieldMetaContext = React.createContext<FlowFieldMeta | null>(null);

/**
 * Provider for field metadata
 */
export function FlowFieldMetaProvider({
  children,
  value,
}: {
  children: React.ReactNode;
  value: FlowFieldMeta;
}) {
  return (
    <FlowFieldMetaContext.Provider value={value}>
      {children}
    </FlowFieldMetaContext.Provider>
  );
}

/**
 * Hook to access field metadata
 */
export function useFlowFieldMeta() {
  return React.useContext(FlowFieldMetaContext);
}

/**
 * Hook to get field state and helpers
 */
export function useFlowField<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>(name: TName) {
  const form = useFormContext<TFieldValues>();
  const meta = useFlowFieldMeta();

  const fieldState = form.getFieldState(name);
  const value = form.watch(name);

  return {
    // Form methods
    setValue: (value: any) => form.setValue(name, value),
    getValue: () => form.getValues(name),
    reset: () => form.resetField(name),
    trigger: () => form.trigger(name),
    setError: (error: any) => form.setError(name, error),
    clearErrors: () => form.clearErrors(name),

    // Field state
    fieldState,
    value,

    // Metadata
    meta,

    // Computed properties
    isDirty: fieldState.isDirty,
    isTouched: fieldState.isTouched,
    isValid: !fieldState.invalid,
    error: fieldState.error,
  };
}

/**
 * Common transform functions for field values
 */
export const FlowFieldTransforms = {
  /**
   * Transform empty strings to null
   */
  emptyToNull: {
    output: (value: any) => (value === "" ? null : value),
    input: (value: any) => (value === null ? "" : value),
  },

  /**
   * Transform strings to numbers
   */
  stringToNumber: {
    output: (value: any) => {
      const num = Number(value);
      return isNaN(num) ? value : num;
    },
    input: (value: any) => String(value),
  },

  /**
   * Transform boolean to checkbox value
   */
  booleanToCheckbox: {
    output: (value: any) => Boolean(value),
    input: (value: any) => Boolean(value),
  },

  /**
   * Transform Date to ISO string
   */
  dateToISO: {
    output: (value: any) => {
      if (!value) return null;
      const date = value instanceof Date ? value : new Date(value);
      return date.toISOString();
    },
    input: (value: any) => {
      if (!value) return "";
      const date = value instanceof Date ? value : new Date(value);
      return date.toISOString().split("T")[0];
    },
  },

  /**
   * Trim whitespace from strings
   */
  trim: {
    output: (value: any) => (typeof value === "string" ? value.trim() : value),
    input: (value: any) => value,
  },
};
