// @generated by next-prisma-flow-state-engine
// file: core/field-registry.tsx

"use client";

import type React from "react";
import { type FlowFieldRenderProps } from "./field-wrapper";

// Type for field renderer components
export type FlowFieldRenderer = React.ComponentType<FlowFieldRenderProps>;

// Registry for custom field renderers
export class FlowFieldRegistry {
  private static renderers = new Map<string, FlowFieldRenderer>();
  private static typeMap = new Map<string, string>();

  // Register a renderer for a field type
  static register(type: string, renderer: FlowFieldRenderer) {
    this.renderers.set(type, renderer);
  }

  // Register multiple renderers at once
  static registerMany(renderers: Record<string, FlowFieldRenderer>) {
    Object.entries(renderers).forEach(([type, renderer]) => {
      this.register(type, renderer);
    });
  }

  // Map a field name to a specific type
  static mapFieldType(fieldName: string, type: string) {
    this.typeMap.set(fieldName, type);
  }

  // Map multiple fields at once
  static mapFieldTypes(mappings: Record<string, string>) {
    Object.entries(mappings).forEach(([fieldName, type]) => {
      this.mapFieldType(fieldName, type);
    });
  }

  // Get a renderer by type
  static get(type: string): FlowFieldRenderer | undefined {
    return this.renderers.get(type);
  }

  // Get renderer for a specific field
  static getForField(
    fieldName: string,
    defaultType: string = "text",
  ): FlowFieldRenderer | undefined {
    const type = this.typeMap.get(fieldName) || defaultType;
    return this.get(type);
  }

  // Unregister a renderer
  static unregister(type: string) {
    this.renderers.delete(type);
  }

  // Clear all registrations
  static clear() {
    this.renderers.clear();
    this.typeMap.clear();
  }

  // Get all registered types
  static getTypes(): string[] {
    return Array.from(this.renderers.keys());
  }

  // Check if a type is registered
  static has(type: string): boolean {
    return this.renderers.has(type);
  }
}

// Auto field component that uses registered renderers
export interface FlowAutoFieldProps {
  name: string;
  type?: string;
  fallback?: FlowFieldRenderer;
  [key: string]: any;
}

export function FlowAutoField({
  name,
  type,
  fallback,
  ...props
}: FlowAutoFieldProps) {
  const Renderer = type
    ? FlowFieldRegistry.get(type)
    : FlowFieldRegistry.getForField(name);

  if (!Renderer) {
    if (fallback) {
      const Fallback = fallback;
      return <Fallback {...props} />;
    }

    console.warn(
      `No renderer registered for field "${name}" with type "${type || "auto"}"`,
    );
    return null;
  }

  return <Renderer {...props} />;
}

// Default field renderer components
export const DefaultFieldRenderers = {
  text: ({ field, fieldState, meta, error }: FlowFieldRenderProps) => (
    <div>
      {meta.label && <label htmlFor={field.name}>{meta.label}</label>}
      <input
        {...field}
        type="text"
        id={field.name}
        placeholder={meta.placeholder}
        aria-invalid={!!error}
        aria-describedby={error ? `${field.name}-error` : undefined}
      />
      {error && (
        <span id={`${field.name}-error`} role="alert">
          {error.message}
        </span>
      )}
    </div>
  ),

  textarea: ({ field, fieldState, meta, error }: FlowFieldRenderProps) => (
    <div>
      {meta.label && <label htmlFor={field.name}>{meta.label}</label>}
      <textarea
        {...field}
        id={field.name}
        placeholder={meta.placeholder}
        aria-invalid={!!error}
        aria-describedby={error ? `${field.name}-error` : undefined}
      />
      {error && (
        <span id={`${field.name}-error`} role="alert">
          {error.message}
        </span>
      )}
    </div>
  ),

  select: ({ field, fieldState, meta, error }: FlowFieldRenderProps) => (
    <div>
      {meta.label && <label htmlFor={field.name}>{meta.label}</label>}
      <select
        {...field}
        id={field.name}
        aria-invalid={!!error}
        aria-describedby={error ? `${field.name}-error` : undefined}
      >
        {meta.placeholder && (
          <option value="" disabled>
            {meta.placeholder}
          </option>
        )}
        {meta.options?.map((option) => (
          <option key={option.value} value={option.value}>
            {option.label}
          </option>
        ))}
      </select>
      {error && (
        <span id={`${field.name}-error`} role="alert">
          {error.message}
        </span>
      )}
    </div>
  ),

  checkbox: ({ field, fieldState, meta, error }: FlowFieldRenderProps) => (
    <div>
      <label>
        <input
          {...field}
          type="checkbox"
          checked={field.value}
          aria-invalid={!!error}
          aria-describedby={error ? `${field.name}-error` : undefined}
        />
        {meta.label}
      </label>
      {error && (
        <span id={`${field.name}-error`} role="alert">
          {error.message}
        </span>
      )}
    </div>
  ),

  number: ({ field, fieldState, meta, error }: FlowFieldRenderProps) => (
    <div>
      {meta.label && <label htmlFor={field.name}>{meta.label}</label>}
      <input
        {...field}
        type="number"
        id={field.name}
        placeholder={meta.placeholder}
        min={meta.min}
        max={meta.max}
        aria-invalid={!!error}
        aria-describedby={error ? `${field.name}-error` : undefined}
      />
      {error && (
        <span id={`${field.name}-error`} role="alert">
          {error.message}
        </span>
      )}
    </div>
  ),

  date: ({ field, fieldState, meta, error }: FlowFieldRenderProps) => (
    <div>
      {meta.label && <label htmlFor={field.name}>{meta.label}</label>}
      <input
        {...field}
        type="date"
        id={field.name}
        min={meta.min}
        max={meta.max}
        aria-invalid={!!error}
        aria-describedby={error ? `${field.name}-error` : undefined}
      />
      {error && (
        <span id={`${field.name}-error`} role="alert">
          {error.message}
        </span>
      )}
    </div>
  ),
};
