// @generated by next-prisma-flow-state-engine
// file: core/form-provider.tsx

"use client";

import * as React from "react";
import {
  FormProvider,
  useFormContext as useRHFContext,
  useFormState,
  useWatch,
} from "react-hook-form";
import type {
  UseFormReturn,
  Path,
  PathValue,
  FieldValues,
} from "react-hook-form";

/**
 * Autosave configuration for forms
 */
export interface FlowFormAutosaveConfig {
  enabled: boolean;
  debounceMs?: number;
  fields?: string[];
  onSave?: (data: any) => Promise<void>;
  onFieldSave?: (field: string, value: any) => Promise<void>;
  onError?: (error: Error) => void;
}

/**
 * Form mode - determines behavior and data handling
 */
export type FlowFormMode = "create" | "update" | "view";

/**
 * Form features configuration
 */
export interface FlowFormFeatures {
  autosave?: FlowFormAutosaveConfig | boolean;
  optimisticUpdates?: boolean;
  dirtyFieldTracking?: boolean;
  fieldValidation?: {
    onChange?: boolean;
    onBlur?: boolean;
    onSubmit?: boolean;
    onTouched?: boolean;
  };
}

/**
 * Extended form context with Flow-specific features
 */
export interface FlowFormContextValue<
  TFieldValues extends FieldValues = FieldValues,
> {
  // Core form instance from react-hook-form
  form: UseFormReturn<TFieldValues>;

  // Form metadata
  mode: FlowFormMode;
  modelName: string;

  // State
  isSubmitting: boolean;
  isSaving: boolean;
  hasUnsavedChanges: boolean;

  // Features
  features: FlowFormFeatures;

  // Actions
  submit: (e?: React.BaseSyntheticEvent) => Promise<void>;
  save: () => Promise<void>;
  reset: () => void;
  setFieldValue: <TFieldName extends Path<TFieldValues>>(
    name: TFieldName,
    value: PathValue<TFieldValues, TFieldName>,
    options?: {
      shouldValidate?: boolean;
      shouldDirty?: boolean;
      shouldTouch?: boolean;
    },
  ) => void;

  // Autosave
  autosave?: {
    isPending: boolean;
    lastSaved?: Date;
    error?: Error;
    trigger: () => void;
  };
}

const FlowFormContext = React.createContext<FlowFormContextValue | null>(null);

/**
 * Hook to access the Flow form context
 * @throws {Error} If used outside of a FlowFormProvider
 */
export function useFlowFormContext<
  TFieldValues extends FieldValues = FieldValues,
>(): FlowFormContextValue<TFieldValues> {
  const context = React.useContext(FlowFormContext);
  if (!context) {
    throw new Error(
      "useFlowFormContext must be used within a FlowFormProvider. " +
        "Make sure your component is wrapped with a Flow[Model]Form component.",
    );
  }
  return context as FlowFormContextValue<TFieldValues>;
}

/**
 * Re-export react-hook-form's useFormContext for convenience
 */
export { useRHFContext as useFormContext };

/**
 * Internal component to handle autosave without causing re-renders
 */
function AutosaveWatcher<TFieldValues extends FieldValues = FieldValues>({
  enabled,
  onSave,
  debounceMs = 1000,
  onError,
  onSuccess,
}: {
  enabled: boolean;
  onSave?: (data: Partial<TFieldValues>) => Promise<void>;
  debounceMs?: number;
  onError?: (error: Error) => void;
  onSuccess?: () => void;
}) {
  const form = useRHFContext<TFieldValues>();
  const { dirtyFields } = useFormState({ control: form.control });
  const watchedValues = useWatch({ control: form.control });
  const timeoutRef = React.useRef<NodeJS.Timeout>();

  React.useEffect(() => {
    if (!enabled || !onSave) return;

    clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(async () => {
      try {
        // Only save dirty fields
        const dataToSave: any = {};
        Object.keys(dirtyFields).forEach((key) => {
          if (dirtyFields[key as keyof typeof dirtyFields]) {
            dataToSave[key] =
              watchedValues?.[key as keyof typeof watchedValues] ??
              form.getValues(key as Path<TFieldValues>);
          }
        });

        if (Object.keys(dataToSave).length > 0) {
          await onSave(dataToSave as Partial<TFieldValues>);
          onSuccess?.();
        }
      } catch (error) {
        onError?.(error as Error);
      }
    }, debounceMs);

    return () => {
      clearTimeout(timeoutRef.current);
    };
  }, [
    watchedValues,
    dirtyFields,
    enabled,
    onSave,
    debounceMs,
    form,
    onError,
    onSuccess,
  ]);

  return null;
}

export interface FlowFormProviderProps<
  TFieldValues extends FieldValues = FieldValues,
> {
  children: React.ReactNode;
  form: UseFormReturn<TFieldValues>;
  mode: FlowFormMode;
  modelName: string;
  features?: FlowFormFeatures;
  onSubmit: (data: TFieldValues) => Promise<void>;
  onSave?: (data: Partial<TFieldValues>) => Promise<void>;
}

/**
 * Flow Form Provider - Wraps react-hook-form with additional features
 */
export function FlowFormProvider<
  TFieldValues extends FieldValues = FieldValues,
>({
  children,
  form,
  mode,
  modelName,
  features = {},
  onSubmit,
  onSave,
}: FlowFormProviderProps<TFieldValues>) {
  const [isSubmitting, setIsSubmitting] = React.useState(false);
  const [isSaving, setIsSaving] = React.useState(false);
  const [lastSaved, setLastSaved] = React.useState<Date>();
  const [autosaveError, setAutosaveError] = React.useState<Error>();

  // Parse features
  const autosaveConfig = React.useMemo(() => {
    if (!features.autosave) return null;
    if (typeof features.autosave === "boolean") {
      return { enabled: true, debounceMs: 1000 };
    }
    return features.autosave;
  }, [features.autosave]);

  // Autosave is now handled by the AutosaveWatcher component

  // Form submission
  const handleSubmit = React.useCallback(
    async (e?: React.BaseSyntheticEvent) => {
      e?.preventDefault();

      try {
        setIsSubmitting(true);
        await form.handleSubmit(async (data) => {
          await onSubmit(data);
        })(e);
      } catch (error) {
        console.error("Form submission error:", error);
        throw error;
      } finally {
        setIsSubmitting(false);
      }
    },
    [form, onSubmit],
  );

  // Manual save
  const handleSave = React.useCallback(async () => {
    if (!onSave) return;

    try {
      setIsSaving(true);
      const values = form.getValues();
      await onSave(values);
      setLastSaved(new Date());
    } catch (error) {
      console.error("Save error:", error);
      throw error;
    } finally {
      setIsSaving(false);
    }
  }, [form, onSave]);

  // Reset form
  const handleReset = React.useCallback(() => {
    form.reset();
    setLastSaved(undefined);
    setAutosaveError(undefined);
  }, [form]);

  // Set field value with proper typing
  const setFieldValue = React.useCallback(
    <TFieldName extends Path<TFieldValues>>(
      name: TFieldName,
      value: PathValue<TFieldValues, TFieldName>,
      options?: {
        shouldValidate?: boolean;
        shouldDirty?: boolean;
        shouldTouch?: boolean;
      },
    ) => {
      form.setValue(name, value, options);
    },
    [form],
  );

  // Build context value
  const contextValue = React.useMemo<FlowFormContextValue<TFieldValues>>(
    () => ({
      // Core
      form,
      mode,
      modelName,

      // State
      isSubmitting,
      isSaving,
      hasUnsavedChanges: false, // This is now tracked separately to avoid re-renders

      // Features
      features,

      // Actions
      submit: handleSubmit,
      save: handleSave,
      reset: handleReset,
      setFieldValue,

      // Autosave
      ...(autosaveConfig?.enabled
        ? {
            autosave: {
              isPending: isSaving,
              lastSaved,
              error: autosaveError,
              trigger: () => {}, // Trigger is now handled by AutosaveWatcher
            },
          }
        : {}),
    }),
    [
      form,
      mode,
      modelName,
      isSubmitting,
      isSaving,
      features,
      handleSubmit,
      handleSave,
      handleReset,
      setFieldValue,
      autosaveConfig?.enabled,
      lastSaved,
      autosaveError,
    ],
  );

  return (
    <FormProvider {...form}>
      <FlowFormContext.Provider value={contextValue}>
        {children}
        {autosaveConfig?.enabled && (
          <AutosaveWatcher
            enabled={autosaveConfig.enabled}
            onSave={onSave}
            debounceMs={autosaveConfig.debounceMs}
            onError={autosaveConfig.onError}
            onSuccess={() => setLastSaved(new Date())}
          />
        )}
      </FlowFormContext.Provider>
    </FormProvider>
  );
}

/**
 * Hook to get form submission state with proper subscriptions
 */
export function useFlowFormState() {
  const { isSubmitting, isSaving, form } = useFlowFormContext();
  const { isDirty, dirtyFields } = useFormState({ control: form.control });
  const hasUnsavedChanges = isDirty || Object.keys(dirtyFields).length > 0;
  return { isSubmitting, isSaving, hasUnsavedChanges };
}

/**
 * Hook to get autosave state
 */
export function useFlowFormAutosave() {
  const { autosave } = useFlowFormContext();
  return autosave;
}

/**
 * Hook to get form actions
 */
export function useFlowFormActions() {
  const { submit, save, reset, setFieldValue } = useFlowFormContext();
  return { submit, save, reset, setFieldValue };
}
