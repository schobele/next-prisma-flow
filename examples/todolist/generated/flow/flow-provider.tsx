// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-07T12:32:18.080Z

'use client';

import React, { createContext, useContext, useEffect, useMemo, useRef, useImperativeHandle, forwardRef } from 'react';
import { Provider as JotaiProvider, createStore } from 'jotai';
import { DevTools } from 'jotai-devtools';
import {
  baseUsersAtom,
  usersLoadingAtom,
  usersErrorAtom,
} from './user/atoms';
import {
  baseCategoriesAtom,
  categoriesLoadingAtom,
  categoriesErrorAtom,
} from './category/atoms';
import {
  baseTodosAtom,
  todosLoadingAtom,
  todosErrorAtom,
} from './todo/atoms';
import type { FlowConfig, FlowContextValue, FlowState, FlowErrorBoundaryRef } from './flow-config';

// ============================================================================
// PROVIDER PROPS & CONTEXT
// ============================================================================

export interface FlowProviderProps {
  children: React.ReactNode;
  
  // SSR/Initial state support
  initialData?: Partial<FlowState>;
  
  // Global configuration
  config?: Partial<FlowConfig>;
  
  // Auth/User context
  user?: any | null;
  
  // Global event handlers
  onError?: (error: Error, context: string, modelName?: string) => void;
  onLoading?: (isLoading: boolean, modelName?: string) => void;
  
  // Store customization (for testing/SSR)
  store?: ReturnType<typeof createStore>;
}

const FlowContext = createContext<FlowContextValue | null>(null);

// ============================================================================
// FLOW PROVIDER COMPONENT
// ============================================================================

export function FlowProvider({
  children,
  initialData,
  config: userConfig,
  user,
  onError,
  onLoading,
  store: externalStore,
}: FlowProviderProps) {
  // Create or use provided store
  const store = useMemo(() => {
    const storeInstance = externalStore || createStore();
    
  // Initialize User state
  if (initialData?.users) {
    store.set(baseUsersAtom, initialData.users);
  }
  // Initialize Category state
  if (initialData?.categories) {
    store.set(baseCategoriesAtom, initialData.categories);
  }
  // Initialize Todo state
  if (initialData?.todos) {
    store.set(baseTodosAtom, initialData.todos);
  }
    
    return storeInstance;
  }, [externalStore, initialData]);

  // Merge user config with defaults
  const config = useMemo((): FlowConfig => ({
    errorBoundary: true,
    devTools: process.env.NODE_ENV === 'development',
    autoRefresh: false,
    refreshInterval: 30000,
    ssrSafe: true,
    batchUpdates: true,
    optimisticUpdates: true,
    ...userConfig,
  }), [userConfig]);

  // Error boundary ref for programmatic error handling
  const errorBoundaryRef = useRef<FlowErrorBoundaryRef | null>(null);

  // Global error handler
  const handleError = useMemo(() => (error: Error, context: string, modelName?: string) => {
    console.error(`[Flow Error] ${context}${modelName ? ` (${modelName})` : ''}`, error);
    
    if (onError) {
      onError(error, context, modelName);
    }
    
    // You could also report to error tracking service here
    // reportError(error, { context, modelName, user: user?.id });
  }, [onError, user]);

  // Context value
  const contextValue = useMemo((): FlowContextValue => ({
    config,
    user,
    store,
    onError: handleError,
    onLoading,
    errorBoundaryRef,
    // Utility methods
    clearAllData: () => {
      store.set(baseUsersAtom, {});
      store.set(usersLoadingAtom, false);
      store.set(usersErrorAtom, null);
      store.set(baseCategoriesAtom, {});
      store.set(categoriesLoadingAtom, false);
      store.set(categoriesErrorAtom, null);
      store.set(baseTodosAtom, {});
      store.set(todosLoadingAtom, false);
      store.set(todosErrorAtom, null);
    },
    getDebugInfo: () => ({
      config,
      user: user ? { id: user.id, email: user.email } : null,
      hasErrors: Object.values({
        user: store.get(usersErrorAtom),
        category: store.get(categoriesErrorAtom),
        todo: store.get(todosErrorAtom),
      }).some(Boolean),
      isLoading: Object.values({
        user: store.get(usersLoadingAtom),
        category: store.get(categoriesLoadingAtom),
        todo: store.get(todosLoadingAtom),
      }).some(Boolean),
      timestamp: new Date().toISOString(),
    }),
  }), [config, user, store, handleError, onLoading]);

  // Development helpers
  useEffect(() => {
    if (config.devTools && typeof window !== 'undefined') {
      // Expose debug utilities to window for development
      (window as any).__FLOW_DEBUG__ = {
        store,
        context: contextValue,
        atoms: {
    user: {
      data: baseUsersAtom,
      loading: usersLoadingAtom,
      error: usersErrorAtom,
    },
    category: {
      data: baseCategoriesAtom,
      loading: categoriesLoadingAtom,
      error: categoriesErrorAtom,
    },
    todo: {
      data: baseTodosAtom,
      loading: todosLoadingAtom,
      error: todosErrorAtom,
    },
        },
      };
      
      console.log('ðŸŒŠ Flow Provider initialized with debug tools');
      console.log('Available at: window.__FLOW_DEBUG__');
    }
  }, [config.devTools, store, contextValue]);

  return (
    <FlowContext.Provider value={contextValue}>
      <JotaiProvider store={store}>
        {config.errorBoundary ? (
          <FlowErrorBoundary 
            ref={errorBoundaryRef}
            onError={handleError}
            fallback={config.errorFallback}
          >
            {config.devTools && <DevTools />}
            {children}
          </FlowErrorBoundary>
        ) : (
          <>
            {config.devTools && <DevTools />}
            {children}
          </>
        )}
      </JotaiProvider>
    </FlowContext.Provider>
  );
}

// ============================================================================
// ERROR BOUNDARY
// ============================================================================

interface FlowErrorBoundaryProps {
  children: React.ReactNode;
  onError: (error: Error, context: string) => void;
  fallback?: React.ComponentType<{ error: Error; reset: () => void }>;
}

const FlowErrorBoundary = forwardRef<FlowErrorBoundaryRef, FlowErrorBoundaryProps>(
  function FlowErrorBoundary(props, ref) {
    const [state, setState] = React.useState<{ hasError: boolean; error: Error | null }>({
      hasError: false,
      error: null,
    });

    const reset = React.useCallback(() => {
      setState({ hasError: false, error: null });
    }, []);

    useImperativeHandle(ref, () => ({
      reset,
    }), [reset]);

    React.useEffect(() => {
      const handleError = (event: ErrorEvent) => {
        setState({ hasError: true, error: new Error(event.message) });
        props.onError(new Error(event.message), 'Global Error Handler');
      };

      const handleUnhandledRejection = (event: PromiseRejectionEvent) => {
        const error = event.reason instanceof Error ? event.reason : new Error(String(event.reason));
        setState({ hasError: true, error });
        props.onError(error, 'Unhandled Promise Rejection');
      };

      window.addEventListener('error', handleError);
      window.addEventListener('unhandledrejection', handleUnhandledRejection);

      return () => {
        window.removeEventListener('error', handleError);
        window.removeEventListener('unhandledrejection', handleUnhandledRejection);
      };
    }, [props]);

    if (state.hasError && state.error) {
      const FallbackComponent = props.fallback || DefaultErrorFallback;
      return React.createElement(FallbackComponent, { error: state.error, reset });
    }

    return React.createElement(React.Fragment, null, props.children);
  }
);

// Default error fallback component
function DefaultErrorFallback({ error, reset }: { error: Error; reset: () => void }) {
  return (
    <div style={{
      padding: '2rem',
      margin: '1rem',
      border: '2px solid #ef4444',
      borderRadius: '0.5rem',
      backgroundColor: '#fef2f2',
      color: '#dc2626'
    }}>
      <h2 style={{ margin: '0 0 1rem 0', fontSize: '1.25rem', fontWeight: 'bold' }}>
        Something went wrong
      </h2>
      <details style={{ marginBottom: '1rem' }}>
        <summary style={{ cursor: 'pointer', marginBottom: '0.5rem' }}>
          Error details
        </summary>
        <pre style={{ 
          fontSize: '0.875rem', 
          overflow: 'auto', 
          padding: '0.5rem',
          backgroundColor: '#fee2e2',
          borderRadius: '0.25rem'
        }}>
          {error.message}
        </pre>
      </details>
      <button
        onClick={reset}
        style={{
          padding: '0.5rem 1rem',
          backgroundColor: '#dc2626',
          color: 'white',
          border: 'none',
          borderRadius: '0.25rem',
          cursor: 'pointer'
        }}
      >
        Try again
      </button>
    </div>
  );
}

// ============================================================================
// CONTEXT HOOKS
// ============================================================================

export function useFlowContext(): FlowContextValue {
  const context = useContext(FlowContext);
  if (!context) {
    throw new Error('useFlowContext must be used within a FlowProvider');
  }
  return context;
}

export function useFlowConfig(): FlowConfig {
  return useFlowContext().config;
}

export function useFlowUser<T = any>(): T | null {
  return useFlowContext().user;
}

export function useFlowStore() {
  return useFlowContext().store;
}

export function useFlowErrorBoundary() {
  const { errorBoundaryRef, onError } = useFlowContext();
  
  return {
    reset: () => errorBoundaryRef.current?.reset?.(),
    reportError: (error: Error, context: string) => onError(error, context),
  };
}

// Development helper hook
export function useFlowDebug() {
  const context = useFlowContext();
  
  return {
    getDebugInfo: context.getDebugInfo,
    clearAllData: context.clearAllData,
    store: context.store,
    config: context.config,
  };
}
