// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-01T20:58:43.459Z

'use client';

import { useAtom, useAtomValue, useSetAtom } from 'jotai';
import { useCallback, useEffect, useRef } from 'react';
import {
  baseTodosAtom,
  todoListAtom,
  todosLoadingAtom,
  todoCreatingAtom,
  todoUpdatingAtom,
  todoDeletingAtom,
  todosErrorAtom,
  refreshTodosAtom,
  todoByIdAtom,
  optimisticCreateTodoAtom,
  optimisticUpdateTodoAtom,
  optimisticDeleteTodoAtom,
  todoCountAtom,
  isTodosEmptyAtom,
} from './atoms';
import type { Todo } from './types';
import * as TodoActions from './actions';

export interface UseTodosResult {
  todos: Todo[];
  loading: boolean;
  creating: boolean;
  error: string | null;
  count: number;
  isEmpty: boolean;
  refresh: () => void;
}

export function useTodos(autoFetch = true): UseTodosResult {
  const todos = useAtomValue(todoListAtom);
  const loading = useAtomValue(todosLoadingAtom);
  const creating = useAtomValue(todoCreatingAtom);
  const error = useAtomValue(todosErrorAtom);
  const count = useAtomValue(todoCountAtom);
  const isEmpty = useAtomValue(isTodosEmptyAtom);
  const refresh = useSetAtom(refreshTodosAtom);
  
  // Track if we've already attempted to auto-fetch to prevent infinite loops
  const hasFetchedRef = useRef(false);

  // Auto-fetch on mount if enabled and no data exists (only once)
  useEffect(() => {
    if (autoFetch && isEmpty && !loading && !hasFetchedRef.current) {
      hasFetchedRef.current = true;
      refresh();
    }
  }, [autoFetch, isEmpty, loading, refresh]);

  return {
    todos,
    loading,
    creating,
    error,
    count,
    isEmpty,
    refresh: useCallback(() => refresh(), [refresh]),
  };
}

export interface UseTodoResult {
  todo: Todo | null;
  loading: boolean;
  updating: boolean;
  deleting: boolean;
  error: string | null;
}

export function useTodo(id: string): UseTodoResult {
  const todo = useAtomValue(todoByIdAtom(id));
  const loading = useAtomValue(todosLoadingAtom);
  const updatingStates = useAtomValue(todoUpdatingAtom);
  const deletingStates = useAtomValue(todoDeletingAtom);
  const error = useAtomValue(todosErrorAtom);

  return {
    todo,
    loading,
    updating: updatingStates[id] || false,
    deleting: deletingStates[id] || false,
    error,
  };
}

export interface UseCreateTodoResult {
  createTodo: (data: Parameters<typeof TodoActions.createTodo>[0]) => Promise<Todo>;
  creating: boolean;
  error: string | null;
}

export function useCreateTodo(): UseCreateTodoResult {
  const creating = useAtomValue(todoCreatingAtom);
  const error = useAtomValue(todosErrorAtom);
  const createTodo = useSetAtom(optimisticCreateTodoAtom);

  return {
    createTodo: useCallback(
      async (data: Parameters<typeof TodoActions.createTodo>[0]) => {
        return await createTodo(data);
      },
      [createTodo]
    ),
    creating,
    error,
  };
}

export interface UseUpdateTodoResult {
  updateTodo: (id: string, data: Parameters<typeof TodoActions.updateTodo>[1]) => Promise<Todo>;
  updating: (id: string) => boolean;
  error: string | null;
}

export function useUpdateTodo(): UseUpdateTodoResult {
  const updatingStates = useAtomValue(todoUpdatingAtom);
  const error = useAtomValue(todosErrorAtom);
  const updateTodo = useSetAtom(optimisticUpdateTodoAtom);

  return {
    updateTodo: useCallback(
      async (id: string, data: Parameters<typeof TodoActions.updateTodo>[1]) => {
        return await updateTodo({ id, data });
      },
      [updateTodo]
    ),
    updating: useCallback((id: string) => updatingStates[id] || false, [updatingStates]),
    error,
  };
}

export interface UseDeleteTodoResult {
  deleteTodo: (id: string) => Promise<void>;
  deleting: (id: string) => boolean;
  error: string | null;
}

export function useDeleteTodo(): UseDeleteTodoResult {
  const deletingStates = useAtomValue(todoDeletingAtom);
  const error = useAtomValue(todosErrorAtom);
  const deleteTodo = useSetAtom(optimisticDeleteTodoAtom);

  return {
    deleteTodo: useCallback(
      async (id: string) => {
        await deleteTodo(id);
      },
      [deleteTodo]
    ),
    deleting: useCallback((id: string) => deletingStates[id] || false, [deletingStates]),
    error,
  };
}

// Combined mutation hook for convenience
export interface UseTodoMutationsResult {
  createTodo: (data: Parameters<typeof TodoActions.createTodo>[0]) => Promise<Todo>;
  updateTodo: (id: string, data: Parameters<typeof TodoActions.updateTodo>[1]) => Promise<Todo>;
  deleteTodo: (id: string) => Promise<void>;
  creating: boolean;
  updating: (id: string) => boolean;
  deleting: (id: string) => boolean;
  error: string | null;
}

export function useTodoMutations(): UseTodoMutationsResult {
  const { createTodo, creating } = useCreateTodo();
  const { updateTodo, updating } = useUpdateTodo();
  const { deleteTodo, deleting } = useDeleteTodo();
  const error = useAtomValue(todosErrorAtom);

  return {
    createTodo,
    updateTodo,
    deleteTodo,
    creating,
    updating,
    deleting,
    error,
  };
}

// Batch operations hooks
export interface UseBatchTodoOperationsResult {
  createManyTodos: (data: Parameters<typeof TodoActions.createManyTodos>[0]) => Promise<{ count: number }>;
  deleteManyTodos: (ids: string[]) => Promise<{ count: number }>;
  processing: boolean;
  error: string | null;
}

export function useBatchTodoOperations(): UseBatchTodoOperationsResult {
  const [processing, setProcessing] = useAtom(todosLoadingAtom);
  const error = useAtomValue(todosErrorAtom);
  const refresh = useSetAtom(refreshTodosAtom);

  const createManyTodos = useCallback(
    async (data: Parameters<typeof TodoActions.createManyTodos>[0]) => {
      setProcessing(true);
      try {
        const result = await TodoActions.createManyTodos(data);
        refresh(); // Refresh the list after batch create
        return result;
      } finally {
        setProcessing(false);
      }
    },
    [setProcessing, refresh]
  );

  const deleteManyTodos = useCallback(
    async (ids: string[]) => {
      setProcessing(true);
      try {
        const result = await TodoActions.deleteManyTodos(ids);
        refresh(); // Refresh the list after batch delete
        return result;
      } finally {
        setProcessing(false);
      }
    },
    [setProcessing, refresh]
  );

  return {
    createManyTodos,
    deleteManyTodos,
    processing,
    error,
  };
}

// Utility hook for todo existence check
export function useTodoExists(id: string): boolean {
  const todo = useAtomValue(todoByIdAtom(id));
  return !!todo;
}
