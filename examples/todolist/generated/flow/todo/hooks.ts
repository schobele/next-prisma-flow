// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-05T08:52:12.055Z

'use client';

import { useAtom, useAtomValue, useSetAtom } from 'jotai';
import { useCallback, useEffect, useRef, useState, useMemo } from 'react';
import {
  baseTodosAtom,
  todoListAtom,
  todosLoadingAtom,
  todoCreatingAtom,
  todoUpdatingAtom,
  todoDeletingAtom,
  todosErrorAtom,
  refreshTodosAtom,
  todoByIdAtom,
  optimisticCreateTodoAtom,
  optimisticUpdateTodoAtom,
  optimisticDeleteTodoAtom,
  todoCountAtom,
  isTodosEmptyAtom,
} from './atoms';
import type { 
  Todo, 
  TodoCreateInput, 
  TodoUpdateInput,
  TodoFormData,
  TodoFieldConfig
} from './types';
import { TodoCreateInputSchema, TodoUpdateInputSchema } from './types';
import * as TodoActions from './actions';

// ============================================================================
// ENHANCED UNIFIED HOOKS - Everything you need in one hook
// ============================================================================

export interface UseTodosResult {
  // Data
  data: Todo[];
  loading: boolean;
  error: string | null;
  count: number;
  isEmpty: boolean;
  
  // CRUD operations
  createTodo: (data: TodoCreateInput) => Promise<Todo>;
  updateTodo: (id: string, data: TodoUpdateInput) => Promise<Todo>;
  deleteTodo: (id: string) => Promise<void>;
  
  // Batch operations
  createMany: (data: TodoCreateInput[]) => Promise<{ count: number }>;
  deleteMany: (ids: string[]) => Promise<{ count: number }>;
  
  // State management
  refresh: () => void;
  
  // Loading states for individual operations
  isCreating: boolean;
  isUpdating: (id: string) => boolean;
  isDeleting: (id: string) => boolean;
  
  // Optimistic updates info
  optimisticUpdates: Record<string, boolean>;
}

export function useTodos(autoFetch = true): UseTodosResult {
  const data = useAtomValue(todoListAtom);
  const loading = useAtomValue(todosLoadingAtom);
  const creating = useAtomValue(todoCreatingAtom);
  const updatingStates = useAtomValue(todoUpdatingAtom);
  const deletingStates = useAtomValue(todoDeletingAtom);
  const error = useAtomValue(todosErrorAtom);
  const count = useAtomValue(todoCountAtom);
  const isEmpty = useAtomValue(isTodosEmptyAtom);
  const refresh = useSetAtom(refreshTodosAtom);
  
  // Action atoms for optimistic updates
  const createTodo = useSetAtom(optimisticCreateTodoAtom);
  const updateTodo = useSetAtom(optimisticUpdateTodoAtom);
  const deleteTodo = useSetAtom(optimisticDeleteTodoAtom);
  
  // Track if we've already attempted to auto-fetch to prevent infinite loops
  const hasFetchedRef = useRef(false);

  // Auto-fetch on mount if enabled and no data exists (only once)
  useEffect(() => {
    if (autoFetch && isEmpty && !loading && !hasFetchedRef.current) {
      hasFetchedRef.current = true;
      refresh();
    }
  }, [autoFetch, isEmpty, loading, refresh]);

  // Batch operations
  const createMany = useCallback(
    async (inputs: TodoCreateInput[]) => {
      return await TodoActions.createManyTodos(inputs);
    },
    []
  );

  const deleteMany = useCallback(
    async (ids: string[]) => {
      return await TodoActions.deleteManyTodos(ids);
    },
    []
  );

  return {
    data,
    loading,
    error,
    count,
    isEmpty,
    createTodo: useCallback(
      async (data: TodoCreateInput) => await createTodo(data),
      [createTodo]
    ),
    updateTodo: useCallback(
      async (id: string, data: TodoUpdateInput) => 
        await updateTodo({ id, data }),
      [updateTodo]
    ),
    deleteTodo: useCallback(
      async (id: string) => await deleteTodo(id),
      [deleteTodo]
    ),
    createMany,
    deleteMany,
    refresh: useCallback(() => refresh(), [refresh]),
    isCreating: creating,
    isUpdating: useCallback((id: string) => updatingStates[id] || false, [updatingStates]),
    isDeleting: useCallback((id: string) => deletingStates[id] || false, [deletingStates]),
    optimisticUpdates: updatingStates,
  };
}

// ============================================================================
// ENHANCED INDIVIDUAL ITEM HOOK - Smart item management with form integration
// ============================================================================

export interface UseTodoResult {
  // Data
  data: Todo | null;
  loading: boolean;
  error: string | null;
  
  // Operations
  update: (data: TodoUpdateInput) => Promise<Todo>;
  delete: () => Promise<void>;
  
  // State
  isUpdating: boolean;
  isDeleting: boolean;
  isOptimistic: boolean;
  
  // Form integration
  form: UseUpdateTodoFormResult;
}

export function useTodo(id: string): UseTodoResult {
  const data = useAtomValue(todoByIdAtom(id));
  const loading = useAtomValue(todosLoadingAtom);
  const updatingStates = useAtomValue(todoUpdatingAtom);
  const deletingStates = useAtomValue(todoDeletingAtom);
  const error = useAtomValue(todosErrorAtom);
  
  const updateTodo = useSetAtom(optimisticUpdateTodoAtom);
  const deleteTodo = useSetAtom(optimisticDeleteTodoAtom);
  
  // Filter data to only include update input fields (remove relations and computed fields)
  const filteredData = data ? Object.fromEntries(
    Object.entries(data).filter(([key]) => 
      // Exclude common relational and computed fields
      !['user', 'category', 'todos', 'posts', 'comments', 'profile'].includes(key)
    )
  ) : undefined;
  
  const form = useUpdateTodoForm(id, filteredData);

  return {
    data,
    loading,
    error,
    update: useCallback(
      async (updateData: TodoUpdateInput) => 
        await updateTodo({ id, data: updateData }),
      [updateTodo, id]
    ),
    delete: useCallback(
      async () => await deleteTodo(id),
      [deleteTodo, id]
    ),
    isUpdating: updatingStates[id] || false,
    isDeleting: deletingStates[id] || false,
    isOptimistic: !!(updatingStates[id] || deletingStates[id]),
    form,
  };
}


// ============================================================================
// SPECIALIZED FORM HOOKS - Dedicated hooks for create and update operations
// ============================================================================

export interface UseCreateTodoFormResult {
  // Form state
  data: Partial<TodoCreateInput>;
  isValid: boolean;
  isDirty: boolean;
  errors: Record<string, string>;
  
  // Field helpers with auto-validation
  field: (name: keyof TodoCreateInput) => TodoFieldConfig;
  
  // Form operations
  submit: () => Promise<Todo | null>;
  reset: () => void;
  setData: (data: Partial<TodoCreateInput>) => void;
  
  // Loading states
  loading: boolean;
  error: Error | null;
  
  // Validation
  validate: () => boolean;
  validateField: (field: keyof TodoCreateInput) => boolean;
  
  // Auto-save capabilities
  enableAutoSave: (debounceMs?: number) => void;
  disableAutoSave: () => void;
}

export function useCreateTodoForm(initialData?: Partial<TodoCreateInput>): UseCreateTodoFormResult {
  const [data, setFormData] = useState<Partial<TodoCreateInput>>(initialData || {});
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [touched, setTouched] = useState<Record<string, boolean>>({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [autoSaveEnabled, setAutoSaveEnabled] = useState(false);
  const [autoSaveTimeout, setAutoSaveTimeout] = useState<NodeJS.Timeout | null>(null);
  
  const createTodo = useSetAtom(optimisticCreateTodoAtom);
  
  // Check if form is dirty
  const isDirty = useMemo(() => {
    if (!initialData) return Object.keys(data).length > 0;
    return JSON.stringify(data) !== JSON.stringify(initialData);
  }, [data, initialData]);
  
  // Validate individual field
  const validateField = useCallback((fieldName: keyof TodoCreateInput): boolean => {
    try {
      const value = data[fieldName];
      if (value !== undefined && value !== null && value !== '') {
        setErrors(prev => {
          const newErrors = { ...prev };
          delete newErrors[fieldName as string];
          return newErrors;
        });
        return true;
      }
      return true;
    } catch (err: any) {
      setErrors(prev => ({
        ...prev,
        [fieldName as string]: err.errors?.[0]?.message || 'Invalid value'
      }));
      return false;
    }
  }, [data]);
  
  // Validate entire form
  const validate = useCallback((): boolean => {
    try {
      TodoCreateInputSchema.parse(data);
      setErrors({});
      return true;
    } catch (err: any) {
      const newErrors: Record<string, string> = {};
      err.errors?.forEach((error: any) => {
        if (error.path?.length > 0) {
          newErrors[error.path[0]] = error.message;
        }
      });
      setErrors(newErrors);
      return false;
    }
  }, [data]);
  
  // Check if form is valid
  const isValid = useMemo(() => {
    try {
      TodoCreateInputSchema.parse(data);
      return true;
    } catch {
      return false;
    }
  }, [data]);
  
  // Memoized field helpers to prevent unnecessary re-renders
  const fieldConfigs = useMemo(() => {
    const configs: Record<string, TodoFieldConfig> = {};
    return configs;
  }, []);

  // Field helper function with internal memoization
  const field = useCallback((name: keyof TodoCreateInput): TodoFieldConfig => {
    const cacheKey = `${name}-${data[name]}-${errors[name as string]}-${touched[name as string]}`;
    
    if (!fieldConfigs[cacheKey]) {
      fieldConfigs[cacheKey] = {
        name: name as string,
        value: data[name] ?? '',
        onChange: (value: any) => {
          setFormData(prev => ({ ...prev, [name]: value }));
          
          // Auto-save logic
          if (autoSaveEnabled && autoSaveTimeout) {
            clearTimeout(autoSaveTimeout);
          }
          if (autoSaveEnabled) {
            const timeout = setTimeout(() => {
              if (isValid) {
                submit();
              }
            }, 1000);
            setAutoSaveTimeout(timeout);
          }
        },
        onBlur: () => {
          setTouched(prev => ({ ...prev, [name]: true }));
          validateField(name);
        },
        error: touched[name as string] ? errors[name as string] : undefined,
        required: true, // TODO: Determine from schema
      };
    }
    
    return fieldConfigs[cacheKey];
  }, [data, errors, touched, validateField, autoSaveEnabled, autoSaveTimeout, isValid, fieldConfigs]);
  
  // Submit form
  const submit = useCallback(async (): Promise<Todo | null> => {
    if (!validate()) {
      return null;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const result = await createTodo(data as TodoCreateInput);
      
      // Reset form on successful create
      setFormData({});
      setTouched({});
      setErrors({});
      
      return result;
    } catch (err: any) {
      setError(err);
      return null;
    } finally {
      setLoading(false);
    }
  }, [data, validate, createTodo]);
  
  // Reset form
  const reset = useCallback(() => {
    setFormData(initialData || {});
    setErrors({});
    setTouched({});
    setError(null);
  }, [initialData]);
  
  // Set form data
  const setData = useCallback((newData: Partial<TodoCreateInput>) => {
    setFormData(newData);
  }, []);
  
  // Auto-save functionality
  const enableAutoSave = useCallback((debounceMs = 1000) => {
    setAutoSaveEnabled(true);
  }, []);
  
  const disableAutoSave = useCallback(() => {
    setAutoSaveEnabled(false);
    if (autoSaveTimeout) {
      clearTimeout(autoSaveTimeout);
      setAutoSaveTimeout(null);
    }
  }, [autoSaveTimeout]);
  
  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (autoSaveTimeout) {
        clearTimeout(autoSaveTimeout);
      }
    };
  }, [autoSaveTimeout]);

  return {
    data,
    isValid,
    isDirty,
    errors,
    field,
    submit,
    reset,
    setData,
    loading,
    error,
    validate,
    validateField,
    enableAutoSave,
    disableAutoSave,
  };
}

export interface UseUpdateTodoFormResult {
  // Form state
  data: Partial<TodoUpdateInput>;
  isValid: boolean;
  isDirty: boolean;
  errors: Record<string, string>;
  
  // Field helpers with auto-validation
  field: (name: keyof TodoUpdateInput) => TodoFieldConfig;
  
  // Form operations
  submit: () => Promise<Todo | null>;
  reset: () => void;
  setData: (data: Partial<TodoUpdateInput>) => void;
  
  // Loading states
  loading: boolean;
  error: Error | null;
  
  // Validation
  validate: () => boolean;
  validateField: (field: keyof TodoUpdateInput) => boolean;
  
  // Auto-save capabilities
  enableAutoSave: (debounceMs?: number) => void;
  disableAutoSave: () => void;
  
  // ID for update operations
  id: string;
}

export function useUpdateTodoForm(id: string, initialData?: Partial<TodoUpdateInput>): UseUpdateTodoFormResult {
  const [data, setFormData] = useState<Partial<TodoUpdateInput>>(initialData || {});
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [touched, setTouched] = useState<Record<string, boolean>>({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [autoSaveEnabled, setAutoSaveEnabled] = useState(false);
  const [autoSaveTimeout, setAutoSaveTimeout] = useState<NodeJS.Timeout | null>(null);
  
  const updateTodo = useSetAtom(optimisticUpdateTodoAtom);
  
  // Check if form is dirty
  const isDirty = useMemo(() => {
    if (!initialData) return Object.keys(data).length > 0;
    return JSON.stringify(data) !== JSON.stringify(initialData);
  }, [data, initialData]);
  
  // Validate individual field
  const validateField = useCallback((fieldName: keyof TodoUpdateInput): boolean => {
    try {
      const value = data[fieldName];
      if (value !== undefined && value !== null && value !== '') {
        setErrors(prev => {
          const newErrors = { ...prev };
          delete newErrors[fieldName as string];
          return newErrors;
        });
        return true;
      }
      return true;
    } catch (err: any) {
      setErrors(prev => ({
        ...prev,
        [fieldName as string]: err.errors?.[0]?.message || 'Invalid value'
      }));
      return false;
    }
  }, [data]);
  
  // Validate entire form
  const validate = useCallback((): boolean => {
    try {
      TodoUpdateInputSchema.parse(data);
      setErrors({});
      return true;
    } catch (err: any) {
      const newErrors: Record<string, string> = {};
      err.errors?.forEach((error: any) => {
        if (error.path?.length > 0) {
          newErrors[error.path[0]] = error.message;
        }
      });
      setErrors(newErrors);
      return false;
    }
  }, [data]);
  
  // Check if form is valid
  const isValid = useMemo(() => {
    try {
      TodoUpdateInputSchema.parse(data);
      return true;
    } catch {
      return false;
    }
  }, [data]);
  
  // Memoized field helpers to prevent unnecessary re-renders
  const updateFieldConfigs = useMemo(() => {
    const configs: Record<string, TodoFieldConfig> = {};
    return configs;
  }, []);

  // Field helper function with internal memoization
  const field = useCallback((name: keyof TodoUpdateInput): TodoFieldConfig => {
    const cacheKey = `${name}-${data[name]}-${errors[name as string]}-${touched[name as string]}`;
    
    if (!updateFieldConfigs[cacheKey]) {
      updateFieldConfigs[cacheKey] = {
        name: name as string,
        value: data[name] ?? '',
        onChange: (value: any) => {
          setFormData(prev => ({ ...prev, [name]: value }));
          
          // Auto-save logic
          if (autoSaveEnabled && autoSaveTimeout) {
            clearTimeout(autoSaveTimeout);
          }
          if (autoSaveEnabled) {
            const timeout = setTimeout(() => {
              if (isValid) {
                submit();
              }
            }, 1000);
            setAutoSaveTimeout(timeout);
          }
        },
        onBlur: () => {
          setTouched(prev => ({ ...prev, [name]: true }));
          validateField(name);
        },
        error: touched[name as string] ? errors[name as string] : undefined,
        required: false, // Update fields are typically optional
      };
    }
    
    return updateFieldConfigs[cacheKey];
  }, [data, errors, touched, validateField, autoSaveEnabled, autoSaveTimeout, isValid, updateFieldConfigs]);
  
  // Submit form
  const submit = useCallback(async (): Promise<Todo | null> => {
    if (!validate()) {
      return null;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const result = await updateTodo({ id, data: data as TodoUpdateInput });
      return result;
    } catch (err: any) {
      setError(err);
      return null;
    } finally {
      setLoading(false);
    }
  }, [data, validate, updateTodo, id]);
  
  // Reset form
  const reset = useCallback(() => {
    setFormData(initialData || {});
    setErrors({});
    setTouched({});
    setError(null);
  }, [initialData]);
  
  // Set form data
  const setData = useCallback((newData: Partial<TodoUpdateInput>) => {
    setFormData(newData);
  }, []);
  
  // Auto-save functionality
  const enableAutoSave = useCallback((debounceMs = 1000) => {
    setAutoSaveEnabled(true);
  }, []);
  
  const disableAutoSave = useCallback(() => {
    setAutoSaveEnabled(false);
    if (autoSaveTimeout) {
      clearTimeout(autoSaveTimeout);
      setAutoSaveTimeout(null);
    }
  }, [autoSaveTimeout]);
  
  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (autoSaveTimeout) {
        clearTimeout(autoSaveTimeout);
      }
    };
  }, [autoSaveTimeout]);

  return {
    data,
    isValid,
    isDirty,
    errors,
    field,
    submit,
    reset,
    setData,
    loading,
    error,
    validate,
    validateField,
    enableAutoSave,
    disableAutoSave,
    id,
  };
}

// ============================================================================
// UTILITY HOOKS
// ============================================================================

export function useTodoExists(id: string): boolean {
  const todo = useAtomValue(todoByIdAtom(id));
  return !!todo;
}

