// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-02T07:09:53.471Z

import { atom } from 'jotai';
import { atomWithImmer } from 'jotai-immer';
import type { Todo } from './types';
import * as TodoActions from './actions';

// Base atom to store all todos by ID for efficient updates
export const baseTodosAtom = atomWithImmer<Record<string, Todo>>({});

// Derived atom for the list of todos
export const todoListAtom = atom((get) => {
  const todosMap = get(baseTodosAtom);
  return Object.values(todosMap);
});

// Loading state atoms
export const todosLoadingAtom = atom<boolean>(false);
export const todoCreatingAtom = atom<boolean>(false);
export const todoUpdatingAtom = atom<Record<string, boolean>>({});
export const todoDeletingAtom = atom<Record<string, boolean>>({});

// Error state atoms
export const todosErrorAtom = atom<string | null>(null);

// Refresh action atom - when written to, fetches fresh data
export const refreshTodosAtom = atom(
  null,
  async (_get, set) => {
    set(todosLoadingAtom, true);
    set(todosErrorAtom, null);
    
    try {
      const todos = await TodoActions.getAllTodos();
      const todosMap = Object.fromEntries(
        todos.map(todo => [todo.id, todo])
      );
      set(baseTodosAtom, todosMap);
    } catch (error) {
      set(todosErrorAtom, error instanceof Error ? error.message : 'Failed to fetch todos');
    } finally {
      set(todosLoadingAtom, false);
    }
  }
);

// Individual todo atom by ID
export const todoByIdAtom = (id: string) => atom((get) => {
  const todosMap = get(baseTodosAtom);
  return todosMap[id] || null;
});

// Optimistic create atom
export const optimisticCreateTodoAtom = atom(
  null,
  async (get, set, todoData: Parameters<typeof TodoActions.createTodo>[0]) => {
    const tempId = `temp-${Date.now()}-${Math.random()}`;
    
    // Create optimistic model with defaults for required fields
    const scalarFields = Object.fromEntries(
      Object.entries(todoData).filter(([key, value]) => 
        typeof value !== 'object' || value instanceof Date || value === null
      )
    );
    
    const optimisticTodo = { 
      ...scalarFields,
      id: tempId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as any; // Will be replaced with server response
    
    // Optimistic update
    set(baseTodosAtom, (draft) => {
      draft[tempId] = optimisticTodo as Todo;
    });
    set(todoCreatingAtom, true);
    set(todosErrorAtom, null);
    
    try {
      const createdTodo = await TodoActions.createTodo(todoData);
      
      // Replace optimistic entry with real data
      set(baseTodosAtom, (draft) => {
        delete draft[tempId];
        draft[createdTodo.id] = createdTodo;
      });
      
      return createdTodo;
    } catch (error) {
      // Rollback optimistic update
      set(baseTodosAtom, (draft) => {
        delete draft[tempId];
      });
      set(todosErrorAtom, error instanceof Error ? error.message : 'Failed to create todo');
      throw error;
    } finally {
      set(todoCreatingAtom, false);
    }
  }
);

// Optimistic update atom
export const optimisticUpdateTodoAtom = atom(
  null,
  async (get, set, { id, data }: { id: string; data: Parameters<typeof TodoActions.updateTodo>[1] }) => {
    const currentTodo = get(baseTodosAtom)[id];
    if (!currentTodo) {
      throw new Error('Todo not found');
    }
    
    // Set loading state
    set(todoUpdatingAtom, (prev) => ({ ...prev, [id]: true }));
    set(todosErrorAtom, null);
    
    try {
      const updatedTodo = await TodoActions.updateTodo(id, data);
      
      // Update with server response
      set(baseTodosAtom, (draft) => {
        draft[id] = updatedTodo;
      });
      
      return updatedTodo;
    } catch (error) {
      set(todosErrorAtom, error instanceof Error ? error.message : 'Failed to update todo');
      throw error;
    } finally {
      set(todoUpdatingAtom, (prev) => {
        const { [id]: _, ...rest } = prev;
        return rest;
      });
    }
  }
);

// Optimistic delete atom
export const optimisticDeleteTodoAtom = atom(
  null,
  async (get, set, id: string) => {
    const todoToDelete = get(baseTodosAtom)[id];
    if (!todoToDelete) {
      throw new Error('Todo not found');
    }
    
    // Optimistic removal
    set(baseTodosAtom, (draft) => {
      delete draft[id];
    });
    set(todoDeletingAtom, (prev) => ({ ...prev, [id]: true }));
    set(todosErrorAtom, null);
    
    try {
      await TodoActions.deleteTodo(id);
    } catch (error) {
      // Rollback: restore the deleted item
      set(baseTodosAtom, (draft) => {
        draft[id] = todoToDelete;
      });
      set(todosErrorAtom, error instanceof Error ? error.message : 'Failed to delete todo');
      throw error;
    } finally {
      set(todoDeletingAtom, (prev) => {
        const { [id]: _, ...rest } = prev;
        return rest;
      });
    }
  }
);

// Utility atoms for computed state
export const todoCountAtom = atom((get) => {
  const todos = get(todoListAtom);
  return todos.length;
});

export const isTodosEmptyAtom = atom((get) => {
  const count = get(todoCountAtom);
  return count === 0;
});
