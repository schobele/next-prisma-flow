// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-06T18:13:19.633Z

"use client";

import type React from "react";
import { createContext, useContext, useMemo, useCallback } from "react";
import {
	useCreateTodoForm,
	useUpdateTodoForm,
	type UseCreateTodoFormResult,
	type UseUpdateTodoFormResult,
} from "./hooks";
import type { Todo, TodoCreateInput, TodoUpdateInput, TodoFieldConfig } from "./types";

// ============================================================================
// SMART FORM PROVIDER - Handles create/update logic with optimized field access
// ============================================================================

interface TodoFormContextValue {
	// Mode detection
	isCreateMode: boolean;
	isUpdateMode: boolean;

	// Form state (unified interface)
	data: Partial<TodoCreateInput | TodoUpdateInput>;
	isValid: boolean;
	isDirty: boolean;
	errors: Record<string, string>;
	loading: boolean;
	error: Error | null;

	// Optimized field accessors (memoized internally)
	fields: {
		[K in keyof TodoCreateInput]: () => TodoFieldConfig;
	};

	// Actions
	submit: () => Promise<Todo | null>;
	reset: () => void;
	setData: (data: Partial<TodoCreateInput | TodoUpdateInput>) => void;

	// Auto-save
	enableAutoSave: (debounceMs?: number) => void;
	disableAutoSave: () => void;

	// Form-specific data (when in update mode)
	id?: string;
}

const TodoFormContext = createContext<TodoFormContextValue | null>(null);

export interface TodoFormProviderProps {
	children: React.ReactNode;
	mode?: "create" | "update";
	initialData?: Partial<Todo> | Todo;
	id?: string;
	autoDetectMode?: boolean; // Default true - detect mode from initialData
}

export function TodoFormProvider({ children, mode, initialData, id, autoDetectMode = true }: TodoFormProviderProps) {
	// Smart mode detection
	const detectedMode = useMemo(() => {
		if (mode) return mode;
		if (autoDetectMode && initialData && "id" in initialData && initialData.id) {
			return "update";
		}
		return "create";
	}, [mode, initialData, autoDetectMode]);

	const isCreateMode = detectedMode === "create";
	const isUpdateMode = detectedMode === "update";

	// Filter initial data to remove read-only fields
	const filteredInitialData = useMemo(() => {
		if (!initialData) return undefined;

		// Remove read-only and relational fields
		const { createdAt, updatedAt, user, category, todos, posts, comments, profile, ...cleanData } = initialData as any;

		return cleanData;
	}, [initialData]);

	// Get the ID for update operations
	const updateId = useMemo(() => {
		if (id) return id;
		if (initialData && "id" in initialData) return initialData.id as string;
		return "temp-id"; // Fallback for hooks
	}, [id, initialData]);

	// Always call both hooks (Rules of Hooks compliance)
	const createForm = useCreateTodoForm(isCreateMode ? filteredInitialData : undefined);

	const updateForm = useUpdateTodoForm(updateId, isUpdateMode ? filteredInitialData : undefined);

	// Select the active form
	const activeForm = isUpdateMode ? updateForm : createForm;

	// Memoized field accessors to prevent unnecessary re-renders
	const fields = useMemo(() => {
		// Create a proxy that generates field accessors on demand
		return new Proxy(
			{},
			{
				get: (target: any, fieldName: string | symbol) => {
					if (typeof fieldName === "string") {
						return () => activeForm.field(fieldName as keyof TodoCreateInput);
					}
					return undefined;
				},
			},
		) as { [K in keyof TodoCreateInput]: () => TodoFieldConfig };
	}, [activeForm]);

	// Unified submit that works for both create and update
	const submit = useCallback(async () => {
		return await activeForm.submit();
	}, [activeForm.submit]);

	// Unified reset
	const reset = useCallback(() => {
		activeForm.reset();
	}, [activeForm.reset]);

	// Unified setData with type safety
	const setData = useCallback(
		(newData: Partial<TodoCreateInput | TodoUpdateInput>) => {
			activeForm.setData(newData as any);
		},
		[activeForm.setData],
	);

	const contextValue: TodoFormContextValue = {
		isCreateMode,
		isUpdateMode,
		data: activeForm.data,
		isValid: activeForm.isValid,
		isDirty: activeForm.isDirty,
		errors: activeForm.errors,
		loading: activeForm.loading,
		error: activeForm.error,
		fields,
		submit,
		reset,
		setData,
		enableAutoSave: activeForm.enableAutoSave,
		disableAutoSave: activeForm.disableAutoSave,
		id: isUpdateMode ? updateId : undefined,
	};

	return <TodoFormContext.Provider value={contextValue}>{children}</TodoFormContext.Provider>;
}

// ============================================================================
// HOOK FOR CONSUMING FORM CONTEXT
// ============================================================================

export function useTodoFormContext(): TodoFormContextValue {
	const context = useContext(TodoFormContext);
	if (!context) {
		throw new Error("useTodoFormContext must be used within a TodoFormProvider");
	}
	return context;
}

// ============================================================================
// OPTIMIZED FIELD HOOK - Returns stable field configs
// ============================================================================

export function useTodoField(fieldName: keyof TodoCreateInput): TodoFieldConfig {
	const context = useTodoFormContext();
	const { isUpdateMode } = context;

	// Get the active form directly from hooks
	const createForm = useCreateTodoForm(!isUpdateMode ? (context.data as Partial<TodoCreateInput>) : undefined);
	const updateForm = useUpdateTodoForm(
		context.id || "temp-id",
		isUpdateMode ? (context.data as Partial<TodoUpdateInput>) : undefined,
	);

	const activeForm = isUpdateMode ? updateForm : createForm;

	// Return the field configuration with internal memoization from hooks
	return useMemo(
		() => activeForm.field(fieldName),
		[activeForm.data[fieldName], activeForm.errors[fieldName as string], fieldName],
	);
}

// ============================================================================
// CONVENIENCE HOOKS FOR COMMON PATTERNS
// ============================================================================

export function useTodoFormSubmit() {
	const { submit, loading, isValid } = useTodoFormContext();

	return {
		submit,
		loading,
		isValid,
		canSubmit: isValid && !loading,
	};
}

export function useTodoFormState() {
	const { data, isValid, isDirty, errors, loading, error, isCreateMode, isUpdateMode } = useTodoFormContext();

	return {
		data,
		isValid,
		isDirty,
		errors,
		loading,
		error,
		isCreateMode,
		isUpdateMode,
	};
}
