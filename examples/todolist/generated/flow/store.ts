// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-05T08:52:12.056Z

// Enhanced store setup for all Flow atoms
// Provides utilities for global state management and debugging

import { createStore } from 'jotai';
import {
  baseUsersAtom,
  usersLoadingAtom,
  usersErrorAtom,
} from './user/atoms';
import {
  baseCategoriesAtom,
  categoriesLoadingAtom,
  categoriesErrorAtom,
} from './category/atoms';
import {
  baseTodosAtom,
  todosLoadingAtom,
  todosErrorAtom,
} from './todo/atoms';

// Create a store instance for SSR/testing if needed
export const flowStore = createStore();

// Organized atom access by model
export const flowAtoms = {
  user: {
    data: baseUsersAtom,
    loading: usersLoadingAtom,
    error: usersErrorAtom,
  },
  category: {
    data: baseCategoriesAtom,
    loading: categoriesLoadingAtom,
    error: categoriesErrorAtom,
  },
  todo: {
    data: baseTodosAtom,
    loading: todosLoadingAtom,
    error: todosErrorAtom,
  },
};

// Utility function to clear all data (useful for logout, testing, etc.)
export function clearAllFlowData() {
  flowStore.set(baseUsersAtom, {});
  flowStore.set(usersLoadingAtom, false);
  flowStore.set(usersErrorAtom, null);
  flowStore.set(baseCategoriesAtom, {});
  flowStore.set(categoriesLoadingAtom, false);
  flowStore.set(categoriesErrorAtom, null);
  flowStore.set(baseTodosAtom, {});
  flowStore.set(todosLoadingAtom, false);
  flowStore.set(todosErrorAtom, null);
}

// Utility function to check if any data is loading
export function isAnyFlowDataLoading(): boolean {
  return Object.values(flowAtoms).some(model => 
    flowStore.get(model.loading)
  );
}

// Utility function to get all errors
export function getAllFlowErrors(): Record<string, string | null> {
  return Object.fromEntries(
    Object.entries(flowAtoms).map(([modelName, atoms]) => [
      modelName,
      flowStore.get(atoms.error)
    ])
  );
}

// Enhanced debugging utilities
export function getFlowDebugInfo() {
  const errors = getAllFlowErrors();
  const isLoading = isAnyFlowDataLoading();
  const hasErrors = Object.values(errors).some(Boolean);
  
  return {
    isLoading,
    hasErrors,
    errors,
    models: Object.keys(flowAtoms),
    timestamp: new Date().toISOString(),
  };
}

// Development helpers
export function logFlowState() {
  if (process.env.NODE_ENV === 'development') {
    console.group('ðŸŒŠ Flow State Debug');
    console.log('Debug Info:', getFlowDebugInfo());
    console.log('Store:', flowStore);
    console.groupEnd();
  }
}

// Type for the complete state shape
export interface FlowState {
  users: ReturnType<typeof baseUsersAtom['read']>;
  usersLoading: boolean;
  usersError: string | null;
  categories: ReturnType<typeof baseCategoriesAtom['read']>;
  categoriesLoading: boolean;
  categoriesError: string | null;
  todos: ReturnType<typeof baseTodosAtom['read']>;
  todosLoading: boolean;
  todosError: string | null;
}

// Utility to get complete state snapshot
export function getFlowSnapshot(): FlowState {
  return {
    users: flowStore.get(baseUsersAtom),
    usersLoading: flowStore.get(usersLoadingAtom),
    usersError: flowStore.get(usersErrorAtom),
    categories: flowStore.get(baseCategoriesAtom),
    categoriesLoading: flowStore.get(categoriesLoadingAtom),
    categoriesError: flowStore.get(categoriesErrorAtom),
    todos: flowStore.get(baseTodosAtom),
    todosLoading: flowStore.get(todosLoadingAtom),
    todosError: flowStore.get(todosErrorAtom),
  };
}

// React DevTools integration (if available)
if (typeof window !== 'undefined' && (window as any).__REACT_DEVTOOLS_GLOBAL_HOOK__) {
  (window as any).__FLOW_DEBUG__ = {
    store: flowStore,
    atoms: flowAtoms,
    getState: getFlowSnapshot,
    getDebugInfo: getFlowDebugInfo,
    clearAll: clearAllFlowData,
  };
}
