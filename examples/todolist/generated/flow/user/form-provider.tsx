// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-07T12:32:18.076Z

'use client';

import React, { createContext, useContext, useMemo, useCallback } from 'react';
import { 
  useCreateUserForm, 
  useUpdateUserForm,
  type UseCreateUserFormResult,
  type UseUpdateUserFormResult,
} from './hooks';
import type { 
  User,
  UserCreateInput,
  UserUpdateInput,
  UserFieldConfig
} from './types';

// ============================================================================
// SMART FORM PROVIDER - Handles create/update logic with optimized field access
// ============================================================================

interface UserFormContextValue {
  // Mode detection
  isCreateMode: boolean;
  isUpdateMode: boolean;
  
  // Form state (unified interface)
  data: Partial<UserCreateInput | UserUpdateInput>;
  isValid: boolean;
  isDirty: boolean;
  errors: Record<string, string>;
  loading: boolean;
  error: Error | null;
  
  // Optimized field accessors (memoized internally)
  fields: {
    [K in keyof UserCreateInput]: () => UserFieldConfig;
  };
  
  // Actions
  submit: () => Promise<User | null>;
  reset: () => void;
  setData: (data: Partial<UserCreateInput | UserUpdateInput>) => void;
  
  // Auto-save
  enableAutoSave: (debounceMs?: number) => void;
  disableAutoSave: () => void;
  
  // Form-specific data (when in update mode)
  id?: string;
}

const UserFormContext = createContext<UserFormContextValue | null>(null);

export interface UserFormProviderProps {
  children: React.ReactNode;
  mode?: 'create' | 'update';
  initialData?: Partial<User> | User;
  id?: string;
  autoDetectMode?: boolean; // Default true - detect mode from initialData
}

export function UserFormProvider({
  children,
  mode,
  initialData,
  id,
  autoDetectMode = true,
}: UserFormProviderProps) {
  // Smart mode detection
  const detectedMode = useMemo(() => {
    if (mode) return mode;
    if (autoDetectMode && initialData && 'id' in initialData && initialData.id) {
      return 'update';
    }
    return 'create';
  }, [mode, initialData, autoDetectMode]);

  const isCreateMode = detectedMode === 'create';
  const isUpdateMode = detectedMode === 'update';

  // Filter initial data to remove read-only fields
  const filteredInitialData = useMemo(() => {
    if (!initialData) return undefined;
    
    // Remove read-only and relational fields
    const { 
      createdAt, 
      updatedAt, 
      user, 
      category, 
      todos, 
      posts, 
      comments, 
      profile,
      ...cleanData 
    } = initialData as any;
    
    return cleanData;
  }, [initialData]);

  // Get the ID for update operations
  const updateId = useMemo(() => {
    if (id) return id;
    if (initialData && 'id' in initialData) return initialData.id as string;
    return 'temp-id'; // Fallback for hooks
  }, [id, initialData]);

  // Always call both hooks (Rules of Hooks compliance)
  const createForm = useCreateUserForm(
    isCreateMode ? filteredInitialData : undefined
  );
  
  const updateForm = useUpdateUserForm(
    updateId,
    isUpdateMode ? filteredInitialData : undefined
  );

  // Select the active form
  const activeForm = isUpdateMode ? updateForm : createForm;

  // Memoized field accessors to prevent unnecessary re-renders
  const fields = useMemo(() => {
    // Create a proxy that generates field accessors on demand
    return new Proxy({}, {
      get: (target: any, fieldName: string | symbol) => {
        if (typeof fieldName === 'string') {
          return () => activeForm.field(fieldName as keyof UserCreateInput);
        }
        return undefined;
      }
    }) as { [K in keyof UserCreateInput]: () => UserFieldConfig };
  }, [activeForm]);

  // Unified submit that works for both create and update
  const submit = useCallback(async () => {
    return await activeForm.submit();
  }, [activeForm.submit]);

  // Unified reset
  const reset = useCallback(() => {
    activeForm.reset();
  }, [activeForm.reset]);

  // Unified setData with type safety
  const setData = useCallback((newData: Partial<UserCreateInput | UserUpdateInput>) => {
    activeForm.setData(newData as any);
  }, [activeForm.setData]);

  const contextValue: UserFormContextValue = {
    isCreateMode,
    isUpdateMode,
    data: activeForm.data,
    isValid: activeForm.isValid,
    isDirty: activeForm.isDirty,
    errors: activeForm.errors,
    loading: activeForm.loading,
    error: activeForm.error,
    fields,
    submit,
    reset,
    setData,
    enableAutoSave: activeForm.enableAutoSave,
    disableAutoSave: activeForm.disableAutoSave,
    id: isUpdateMode ? updateId : undefined,
  };

  return (
    <UserFormContext.Provider value={contextValue}>
      {children}
    </UserFormContext.Provider>
  );
}

// ============================================================================
// HOOK FOR CONSUMING FORM CONTEXT
// ============================================================================

export function useUserFormContext(): UserFormContextValue {
  const context = useContext(UserFormContext);
  if (!context) {
    throw new Error('useUserFormContext must be used within a UserFormProvider');
  }
  return context;
}

// ============================================================================
// OPTIMIZED FIELD HOOK - Returns stable field configs
// ============================================================================

export function useUserField(fieldName: keyof UserCreateInput): UserFieldConfig {
  const context = useUserFormContext();
  const { isUpdateMode } = context;
  
  // Get the active form directly from hooks
  const createForm = useCreateUserForm(
    !isUpdateMode ? context.data as Partial<UserCreateInput> : undefined
  );
  const updateForm = useUpdateUserForm(
    context.id || 'temp-id',
    isUpdateMode ? context.data as Partial<UserUpdateInput> : undefined
  );
  
  const activeForm = isUpdateMode ? updateForm : createForm;
  
  // Return the field configuration with internal memoization from hooks
  return useMemo(() => activeForm.field(fieldName), [
    activeForm.data[fieldName],
    activeForm.errors[fieldName as string],
    fieldName
  ]);
}

// ============================================================================
// CONVENIENCE HOOKS FOR COMMON PATTERNS
// ============================================================================

export function useUserFormSubmit() {
  const { submit, loading, isValid } = useUserFormContext();
  
  return {
    submit,
    loading,
    isValid,
    canSubmit: isValid && !loading,
  };
}

export function useUserFormState() {
  const { data, isValid, isDirty, errors, loading, error, isCreateMode, isUpdateMode } = useUserFormContext();
  
  return {
    data,
    isValid,
    isDirty,
    errors,
    loading,
    error,
    isCreateMode,
    isUpdateMode,
  };
}
