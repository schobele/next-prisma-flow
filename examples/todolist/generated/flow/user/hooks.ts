// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-02T19:40:55.320Z

'use client';

import { useAtom, useAtomValue, useSetAtom } from 'jotai';
import { useCallback, useEffect, useRef } from 'react';
import {
  baseUsersAtom,
  userListAtom,
  usersLoadingAtom,
  userCreatingAtom,
  userUpdatingAtom,
  userDeletingAtom,
  usersErrorAtom,
  refreshUsersAtom,
  userByIdAtom,
  optimisticCreateUserAtom,
  optimisticUpdateUserAtom,
  optimisticDeleteUserAtom,
  userCountAtom,
  isUsersEmptyAtom,
} from './atoms';
import type { User } from './types';
import * as UserActions from './actions';

export interface UseUsersResult {
  users: User[];
  loading: boolean;
  creating: boolean;
  error: string | null;
  count: number;
  isEmpty: boolean;
  refresh: () => void;
}

export function useUsers(autoFetch = true): UseUsersResult {
  const users = useAtomValue(userListAtom);
  const loading = useAtomValue(usersLoadingAtom);
  const creating = useAtomValue(userCreatingAtom);
  const error = useAtomValue(usersErrorAtom);
  const count = useAtomValue(userCountAtom);
  const isEmpty = useAtomValue(isUsersEmptyAtom);
  const refresh = useSetAtom(refreshUsersAtom);
  
  // Track if we've already attempted to auto-fetch to prevent infinite loops
  const hasFetchedRef = useRef(false);

  // Auto-fetch on mount if enabled and no data exists (only once)
  useEffect(() => {
    if (autoFetch && isEmpty && !loading && !hasFetchedRef.current) {
      hasFetchedRef.current = true;
      refresh();
    }
  }, [autoFetch, isEmpty, loading, refresh]);

  return {
    users,
    loading,
    creating,
    error,
    count,
    isEmpty,
    refresh: useCallback(() => refresh(), [refresh]),
  };
}

export interface UseUserResult {
  user: User | null;
  loading: boolean;
  updating: boolean;
  deleting: boolean;
  error: string | null;
}

export function useUser(id: string): UseUserResult {
  const user = useAtomValue(userByIdAtom(id));
  const loading = useAtomValue(usersLoadingAtom);
  const updatingStates = useAtomValue(userUpdatingAtom);
  const deletingStates = useAtomValue(userDeletingAtom);
  const error = useAtomValue(usersErrorAtom);

  return {
    user,
    loading,
    updating: updatingStates[id] || false,
    deleting: deletingStates[id] || false,
    error,
  };
}

export interface UseCreateUserResult {
  createUser: (data: Parameters<typeof UserActions.createUser>[0]) => Promise<User>;
  creating: boolean;
  error: string | null;
}

export function useCreateUser(): UseCreateUserResult {
  const creating = useAtomValue(userCreatingAtom);
  const error = useAtomValue(usersErrorAtom);
  const createUser = useSetAtom(optimisticCreateUserAtom);

  return {
    createUser: useCallback(
      async (data: Parameters<typeof UserActions.createUser>[0]) => {
        return await createUser(data);
      },
      [createUser]
    ),
    creating,
    error,
  };
}

export interface UseUpdateUserResult {
  updateUser: (id: string, data: Parameters<typeof UserActions.updateUser>[1]) => Promise<User>;
  updating: (id: string) => boolean;
  error: string | null;
}

export function useUpdateUser(): UseUpdateUserResult {
  const updatingStates = useAtomValue(userUpdatingAtom);
  const error = useAtomValue(usersErrorAtom);
  const updateUser = useSetAtom(optimisticUpdateUserAtom);

  return {
    updateUser: useCallback(
      async (id: string, data: Parameters<typeof UserActions.updateUser>[1]) => {
        return await updateUser({ id, data });
      },
      [updateUser]
    ),
    updating: useCallback((id: string) => updatingStates[id] || false, [updatingStates]),
    error,
  };
}

export interface UseDeleteUserResult {
  deleteUser: (id: string) => Promise<void>;
  deleting: (id: string) => boolean;
  error: string | null;
}

export function useDeleteUser(): UseDeleteUserResult {
  const deletingStates = useAtomValue(userDeletingAtom);
  const error = useAtomValue(usersErrorAtom);
  const deleteUser = useSetAtom(optimisticDeleteUserAtom);

  return {
    deleteUser: useCallback(
      async (id: string) => {
        await deleteUser(id);
      },
      [deleteUser]
    ),
    deleting: useCallback((id: string) => deletingStates[id] || false, [deletingStates]),
    error,
  };
}

// Combined mutation hook for convenience
export interface UseUserMutationsResult {
  createUser: (data: Parameters<typeof UserActions.createUser>[0]) => Promise<User>;
  updateUser: (id: string, data: Parameters<typeof UserActions.updateUser>[1]) => Promise<User>;
  deleteUser: (id: string) => Promise<void>;
  creating: boolean;
  updating: (id: string) => boolean;
  deleting: (id: string) => boolean;
  error: string | null;
}

export function useUserMutations(): UseUserMutationsResult {
  const { createUser, creating } = useCreateUser();
  const { updateUser, updating } = useUpdateUser();
  const { deleteUser, deleting } = useDeleteUser();
  const error = useAtomValue(usersErrorAtom);

  return {
    createUser,
    updateUser,
    deleteUser,
    creating,
    updating,
    deleting,
    error,
  };
}

// Batch operations hooks
export interface UseBatchUserOperationsResult {
  createManyUsers: (data: Parameters<typeof UserActions.createManyUsers>[0]) => Promise<{ count: number }>;
  deleteManyUsers: (ids: string[]) => Promise<{ count: number }>;
  processing: boolean;
  error: string | null;
}

export function useBatchUserOperations(): UseBatchUserOperationsResult {
  const [processing, setProcessing] = useAtom(usersLoadingAtom);
  const error = useAtomValue(usersErrorAtom);
  const refresh = useSetAtom(refreshUsersAtom);

  const createManyUsers = useCallback(
    async (data: Parameters<typeof UserActions.createManyUsers>[0]) => {
      setProcessing(true);
      try {
        const result = await UserActions.createManyUsers(data);
        refresh(); // Refresh the list after batch create
        return result;
      } finally {
        setProcessing(false);
      }
    },
    [setProcessing, refresh]
  );

  const deleteManyUsers = useCallback(
    async (ids: string[]) => {
      setProcessing(true);
      try {
        const result = await UserActions.deleteManyUsers(ids);
        refresh(); // Refresh the list after batch delete
        return result;
      } finally {
        setProcessing(false);
      }
    },
    [setProcessing, refresh]
  );

  return {
    createManyUsers,
    deleteManyUsers,
    processing,
    error,
  };
}

// Utility hook for user existence check
export function useUserExists(id: string): boolean {
  const user = useAtomValue(userByIdAtom(id));
  return !!user;
}
