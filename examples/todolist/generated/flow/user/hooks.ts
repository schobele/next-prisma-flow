// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-06T18:13:19.631Z

"use client";

import { useAtom, useAtomValue, useSetAtom } from "jotai";
import { useCallback, useEffect, useRef, useState, useMemo } from "react";
import {
	baseUsersAtom,
	userListAtom,
	usersLoadingAtom,
	userCreatingAtom,
	userUpdatingAtom,
	userDeletingAtom,
	usersErrorAtom,
	refreshUsersAtom,
	userByIdAtom,
	optimisticCreateUserAtom,
	optimisticUpdateUserAtom,
	optimisticDeleteUserAtom,
	userCountAtom,
	isUsersEmptyAtom,
} from "./atoms";
import type { User, UserCreateInput, UserUpdateInput, UserFormData, UserFieldConfig } from "./types";
import { UserCreateInputSchema, UserUpdateInputSchema } from "./types";
import * as UserActions from "./actions";

// ============================================================================
// ENHANCED UNIFIED HOOKS - Everything you need in one hook
// ============================================================================

export interface UseUsersResult {
	// Data
	data: User[];
	loading: boolean;
	error: string | null;
	count: number;
	isEmpty: boolean;

	// CRUD operations
	createUser: (data: UserCreateInput) => Promise<User>;
	updateUser: (id: string, data: UserUpdateInput) => Promise<User>;
	deleteUser: (id: string) => Promise<void>;

	// Batch operations
	createMany: (data: UserCreateInput[]) => Promise<{ count: number }>;
	deleteMany: (ids: string[]) => Promise<{ count: number }>;

	// State management
	refresh: () => void;

	// Loading states for individual operations
	isCreating: boolean;
	isUpdating: (id: string) => boolean;
	isDeleting: (id: string) => boolean;

	// Optimistic updates info
	optimisticUpdates: Record<string, boolean>;
}

export function useUsers(autoFetch = true): UseUsersResult {
	const data = useAtomValue(userListAtom);
	const loading = useAtomValue(usersLoadingAtom);
	const creating = useAtomValue(userCreatingAtom);
	const updatingStates = useAtomValue(userUpdatingAtom);
	const deletingStates = useAtomValue(userDeletingAtom);
	const error = useAtomValue(usersErrorAtom);
	const count = useAtomValue(userCountAtom);
	const isEmpty = useAtomValue(isUsersEmptyAtom);
	const refresh = useSetAtom(refreshUsersAtom);

	// Action atoms for optimistic updates
	const createUser = useSetAtom(optimisticCreateUserAtom);
	const updateUser = useSetAtom(optimisticUpdateUserAtom);
	const deleteUser = useSetAtom(optimisticDeleteUserAtom);

	// Track if we've already attempted to auto-fetch to prevent infinite loops
	const hasFetchedRef = useRef(false);

	// Auto-fetch on mount if enabled and no data exists (only once)
	useEffect(() => {
		if (autoFetch && isEmpty && !loading && !hasFetchedRef.current) {
			hasFetchedRef.current = true;
			refresh();
		}
	}, [autoFetch, isEmpty, loading, refresh]);

	// Batch operations
	const createMany = useCallback(async (inputs: UserCreateInput[]) => {
		return await UserActions.createManyUsers(inputs);
	}, []);

	const deleteMany = useCallback(async (ids: string[]) => {
		return await UserActions.deleteManyUsers(ids);
	}, []);

	return {
		data,
		loading,
		error,
		count,
		isEmpty,
		createUser: useCallback(async (data: UserCreateInput) => await createUser(data), [createUser]),
		updateUser: useCallback(async (id: string, data: UserUpdateInput) => await updateUser({ id, data }), [updateUser]),
		deleteUser: useCallback(async (id: string) => await deleteUser(id), [deleteUser]),
		createMany,
		deleteMany,
		refresh: useCallback(() => refresh(), [refresh]),
		isCreating: creating,
		isUpdating: useCallback((id: string) => updatingStates[id] || false, [updatingStates]),
		isDeleting: useCallback((id: string) => deletingStates[id] || false, [deletingStates]),
		optimisticUpdates: updatingStates,
	};
}

// ============================================================================
// ENHANCED INDIVIDUAL ITEM HOOK - Smart item management with form integration
// ============================================================================

export interface UseUserResult {
	// Data
	data: User | null;
	loading: boolean;
	error: string | null;

	// Operations
	update: (data: UserUpdateInput) => Promise<User>;
	delete: () => Promise<void>;

	// State
	isUpdating: boolean;
	isDeleting: boolean;
	isOptimistic: boolean;

	// Form integration
	form: UseUpdateUserFormResult;
}

export function useUser(id: string): UseUserResult {
	const data = useAtomValue(userByIdAtom(id));
	const loading = useAtomValue(usersLoadingAtom);
	const updatingStates = useAtomValue(userUpdatingAtom);
	const deletingStates = useAtomValue(userDeletingAtom);
	const error = useAtomValue(usersErrorAtom);

	const updateUser = useSetAtom(optimisticUpdateUserAtom);
	const deleteUser = useSetAtom(optimisticDeleteUserAtom);

	// Filter data to only include update input fields (remove relations and computed fields)
	const filteredData = data
		? Object.fromEntries(
				Object.entries(data).filter(
					([key]) =>
						// Exclude common relational and computed fields
						!["user", "category", "todos", "posts", "comments", "profile"].includes(key),
				),
			)
		: undefined;

	const form = useUpdateUserForm(id, filteredData);

	return {
		data,
		loading,
		error,
		update: useCallback(
			async (updateData: UserUpdateInput) => await updateUser({ id, data: updateData }),
			[updateUser, id],
		),
		delete: useCallback(async () => await deleteUser(id), [deleteUser, id]),
		isUpdating: updatingStates[id] || false,
		isDeleting: deletingStates[id] || false,
		isOptimistic: !!(updatingStates[id] || deletingStates[id]),
		form,
	};
}

// ============================================================================
// SPECIALIZED FORM HOOKS - Dedicated hooks for create and update operations
// ============================================================================

export interface UseCreateUserFormResult {
	// Form state
	data: Partial<UserCreateInput>;
	isValid: boolean;
	isDirty: boolean;
	errors: Record<string, string>;

	// Field helpers with auto-validation
	field: (name: keyof UserCreateInput) => UserFieldConfig;

	// Form operations
	submit: () => Promise<User | null>;
	reset: () => void;
	setData: (data: Partial<UserCreateInput>) => void;

	// Loading states
	loading: boolean;
	error: Error | null;

	// Validation
	validate: () => boolean;
	validateField: (field: keyof UserCreateInput) => boolean;

	// Auto-save capabilities
	enableAutoSave: (debounceMs?: number) => void;
	disableAutoSave: () => void;
}

export function useCreateUserForm(initialData?: Partial<UserCreateInput>): UseCreateUserFormResult {
	const [data, setFormData] = useState<Partial<UserCreateInput>>(initialData || {});
	const [errors, setErrors] = useState<Record<string, string>>({});
	const [touched, setTouched] = useState<Record<string, boolean>>({});
	const [loading, setLoading] = useState(false);
	const [error, setError] = useState<Error | null>(null);
	const [autoSaveEnabled, setAutoSaveEnabled] = useState(false);
	const [autoSaveTimeout, setAutoSaveTimeout] = useState<NodeJS.Timeout | null>(null);

	const createUser = useSetAtom(optimisticCreateUserAtom);

	// Check if form is dirty
	const isDirty = useMemo(() => {
		if (!initialData) return Object.keys(data).length > 0;
		return JSON.stringify(data) !== JSON.stringify(initialData);
	}, [data, initialData]);

	// Validate individual field
	const validateField = useCallback(
		(fieldName: keyof UserCreateInput): boolean => {
			try {
				const value = data[fieldName];
				if (value !== undefined && value !== null && value !== "") {
					setErrors((prev) => {
						const newErrors = { ...prev };
						delete newErrors[fieldName as string];
						return newErrors;
					});
					return true;
				}
				return true;
			} catch (err: any) {
				setErrors((prev) => ({
					...prev,
					[fieldName as string]: err.errors?.[0]?.message || "Invalid value",
				}));
				return false;
			}
		},
		[data],
	);

	// Validate entire form
	const validate = useCallback((): boolean => {
		try {
			UserCreateInputSchema.parse(data);
			setErrors({});
			return true;
		} catch (err: any) {
			const newErrors: Record<string, string> = {};
			err.errors?.forEach((error: any) => {
				if (error.path?.length > 0) {
					newErrors[error.path[0]] = error.message;
				}
			});
			setErrors(newErrors);
			return false;
		}
	}, [data]);

	// Check if form is valid
	const isValid = useMemo(() => {
		try {
			UserCreateInputSchema.parse(data);
			return true;
		} catch {
			return false;
		}
	}, [data]);

	// Memoized field helpers to prevent unnecessary re-renders
	const fieldConfigs = useMemo(() => {
		const configs: Record<string, UserFieldConfig> = {};
		return configs;
	}, []);

	// Field helper function with internal memoization
	const field = useCallback(
		(name: keyof UserCreateInput): UserFieldConfig => {
			const cacheKey = `${name}-${data[name]}-${errors[name as string]}-${touched[name as string]}`;

			if (!fieldConfigs[cacheKey]) {
				fieldConfigs[cacheKey] = {
					name: name as string,
					value: data[name] ?? "",
					onChange: (value: any) => {
						setFormData((prev) => ({ ...prev, [name]: value }));

						// Auto-save logic
						if (autoSaveEnabled && autoSaveTimeout) {
							clearTimeout(autoSaveTimeout);
						}
						if (autoSaveEnabled) {
							const timeout = setTimeout(() => {
								if (isValid) {
									submit();
								}
							}, 1000);
							setAutoSaveTimeout(timeout);
						}
					},
					onBlur: () => {
						setTouched((prev) => ({ ...prev, [name]: true }));
						validateField(name);
					},
					error: touched[name as string] ? errors[name as string] : undefined,
					required: true, // TODO: Determine from schema
				};
			}

			return fieldConfigs[cacheKey];
		},
		[data, errors, touched, validateField, autoSaveEnabled, autoSaveTimeout, isValid, fieldConfigs],
	);

	// Submit form
	const submit = useCallback(async (): Promise<User | null> => {
		if (!validate()) {
			return null;
		}

		setLoading(true);
		setError(null);

		try {
			const result = await createUser(data as UserCreateInput);

			// Reset form on successful create
			setFormData({});
			setTouched({});
			setErrors({});

			return result;
		} catch (err: any) {
			setError(err);
			return null;
		} finally {
			setLoading(false);
		}
	}, [data, validate, createUser]);

	// Reset form
	const reset = useCallback(() => {
		setFormData(initialData || {});
		setErrors({});
		setTouched({});
		setError(null);
	}, [initialData]);

	// Set form data
	const setData = useCallback((newData: Partial<UserCreateInput>) => {
		setFormData(newData);
	}, []);

	// Auto-save functionality
	const enableAutoSave = useCallback((debounceMs = 1000) => {
		setAutoSaveEnabled(true);
	}, []);

	const disableAutoSave = useCallback(() => {
		setAutoSaveEnabled(false);
		if (autoSaveTimeout) {
			clearTimeout(autoSaveTimeout);
			setAutoSaveTimeout(null);
		}
	}, [autoSaveTimeout]);

	// Cleanup timeout on unmount
	useEffect(() => {
		return () => {
			if (autoSaveTimeout) {
				clearTimeout(autoSaveTimeout);
			}
		};
	}, [autoSaveTimeout]);

	return {
		data,
		isValid,
		isDirty,
		errors,
		field,
		submit,
		reset,
		setData,
		loading,
		error,
		validate,
		validateField,
		enableAutoSave,
		disableAutoSave,
	};
}

export interface UseUpdateUserFormResult {
	// Form state
	data: Partial<UserUpdateInput>;
	isValid: boolean;
	isDirty: boolean;
	errors: Record<string, string>;

	// Field helpers with auto-validation
	field: (name: keyof UserUpdateInput) => UserFieldConfig;

	// Form operations
	submit: () => Promise<User | null>;
	reset: () => void;
	setData: (data: Partial<UserUpdateInput>) => void;

	// Loading states
	loading: boolean;
	error: Error | null;

	// Validation
	validate: () => boolean;
	validateField: (field: keyof UserUpdateInput) => boolean;

	// Auto-save capabilities
	enableAutoSave: (debounceMs?: number) => void;
	disableAutoSave: () => void;

	// ID for update operations
	id: string;
}

export function useUpdateUserForm(id: string, initialData?: Partial<UserUpdateInput>): UseUpdateUserFormResult {
	const [data, setFormData] = useState<Partial<UserUpdateInput>>(initialData || {});
	const [errors, setErrors] = useState<Record<string, string>>({});
	const [touched, setTouched] = useState<Record<string, boolean>>({});
	const [loading, setLoading] = useState(false);
	const [error, setError] = useState<Error | null>(null);
	const [autoSaveEnabled, setAutoSaveEnabled] = useState(false);
	const [autoSaveTimeout, setAutoSaveTimeout] = useState<NodeJS.Timeout | null>(null);

	const updateUser = useSetAtom(optimisticUpdateUserAtom);

	// Check if form is dirty
	const isDirty = useMemo(() => {
		if (!initialData) return Object.keys(data).length > 0;
		return JSON.stringify(data) !== JSON.stringify(initialData);
	}, [data, initialData]);

	// Validate individual field
	const validateField = useCallback(
		(fieldName: keyof UserUpdateInput): boolean => {
			try {
				const value = data[fieldName];
				if (value !== undefined && value !== null && value !== "") {
					setErrors((prev) => {
						const newErrors = { ...prev };
						delete newErrors[fieldName as string];
						return newErrors;
					});
					return true;
				}
				return true;
			} catch (err: any) {
				setErrors((prev) => ({
					...prev,
					[fieldName as string]: err.errors?.[0]?.message || "Invalid value",
				}));
				return false;
			}
		},
		[data],
	);

	// Validate entire form
	const validate = useCallback((): boolean => {
		try {
			UserUpdateInputSchema.parse(data);
			setErrors({});
			return true;
		} catch (err: any) {
			const newErrors: Record<string, string> = {};
			err.errors?.forEach((error: any) => {
				if (error.path?.length > 0) {
					newErrors[error.path[0]] = error.message;
				}
			});
			setErrors(newErrors);
			return false;
		}
	}, [data]);

	// Check if form is valid
	const isValid = useMemo(() => {
		try {
			UserUpdateInputSchema.parse(data);
			return true;
		} catch {
			return false;
		}
	}, [data]);

	// Memoized field helpers to prevent unnecessary re-renders
	const updateFieldConfigs = useMemo(() => {
		const configs: Record<string, UserFieldConfig> = {};
		return configs;
	}, []);

	// Field helper function with internal memoization
	const field = useCallback(
		(name: keyof UserUpdateInput): UserFieldConfig => {
			const cacheKey = `${name}-${data[name]}-${errors[name as string]}-${touched[name as string]}`;

			if (!updateFieldConfigs[cacheKey]) {
				updateFieldConfigs[cacheKey] = {
					name: name as string,
					value: data[name] ?? "",
					onChange: (value: any) => {
						setFormData((prev) => ({ ...prev, [name]: value }));

						// Auto-save logic
						if (autoSaveEnabled && autoSaveTimeout) {
							clearTimeout(autoSaveTimeout);
						}
						if (autoSaveEnabled) {
							const timeout = setTimeout(() => {
								if (isValid) {
									submit();
								}
							}, 1000);
							setAutoSaveTimeout(timeout);
						}
					},
					onBlur: () => {
						setTouched((prev) => ({ ...prev, [name]: true }));
						validateField(name);
					},
					error: touched[name as string] ? errors[name as string] : undefined,
					required: false, // Update fields are typically optional
				};
			}

			return updateFieldConfigs[cacheKey];
		},
		[data, errors, touched, validateField, autoSaveEnabled, autoSaveTimeout, isValid, updateFieldConfigs],
	);

	// Submit form
	const submit = useCallback(async (): Promise<User | null> => {
		if (!validate()) {
			return null;
		}

		setLoading(true);
		setError(null);

		try {
			const result = await updateUser({ id, data: data as UserUpdateInput });
			return result;
		} catch (err: any) {
			setError(err);
			return null;
		} finally {
			setLoading(false);
		}
	}, [data, validate, updateUser, id]);

	// Reset form
	const reset = useCallback(() => {
		setFormData(initialData || {});
		setErrors({});
		setTouched({});
		setError(null);
	}, [initialData]);

	// Set form data
	const setData = useCallback((newData: Partial<UserUpdateInput>) => {
		setFormData(newData);
	}, []);

	// Auto-save functionality
	const enableAutoSave = useCallback((debounceMs = 1000) => {
		setAutoSaveEnabled(true);
	}, []);

	const disableAutoSave = useCallback(() => {
		setAutoSaveEnabled(false);
		if (autoSaveTimeout) {
			clearTimeout(autoSaveTimeout);
			setAutoSaveTimeout(null);
		}
	}, [autoSaveTimeout]);

	// Cleanup timeout on unmount
	useEffect(() => {
		return () => {
			if (autoSaveTimeout) {
				clearTimeout(autoSaveTimeout);
			}
		};
	}, [autoSaveTimeout]);

	return {
		data,
		isValid,
		isDirty,
		errors,
		field,
		submit,
		reset,
		setData,
		loading,
		error,
		validate,
		validateField,
		enableAutoSave,
		disableAutoSave,
		id,
	};
}

// ============================================================================
// UTILITY HOOKS
// ============================================================================

export function useUserExists(id: string): boolean {
	const user = useAtomValue(userByIdAtom(id));
	return !!user;
}
