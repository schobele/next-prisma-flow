// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-02T18:57:26.035Z

import { atom } from 'jotai';
import { atomWithImmer } from 'jotai-immer';
import type { User } from './types';
import * as UserActions from './actions';

// Base atom to store all users by ID for efficient updates
export const baseUsersAtom = atomWithImmer<Record<string, User>>({});

// Derived atom for the list of users
export const userListAtom = atom((get) => {
  const usersMap = get(baseUsersAtom);
  return Object.values(usersMap);
});

// Loading state atoms
export const usersLoadingAtom = atom<boolean>(false);
export const userCreatingAtom = atom<boolean>(false);
export const userUpdatingAtom = atom<Record<string, boolean>>({});
export const userDeletingAtom = atom<Record<string, boolean>>({});

// Error state atoms
export const usersErrorAtom = atom<string | null>(null);

// Refresh action atom - when written to, fetches fresh data
export const refreshUsersAtom = atom(
  null,
  async (_get, set) => {
    set(usersLoadingAtom, true);
    set(usersErrorAtom, null);
    
    try {
      const users = await UserActions.getAllUsers();
      const usersMap = Object.fromEntries(
        users.map(user => [user.id, user])
      );
      set(baseUsersAtom, usersMap);
    } catch (error) {
      set(usersErrorAtom, error instanceof Error ? error.message : 'Failed to fetch users');
    } finally {
      set(usersLoadingAtom, false);
    }
  }
);

// Individual user atom by ID
export const userByIdAtom = (id: string) => atom((get) => {
  const usersMap = get(baseUsersAtom);
  return usersMap[id] || null;
});

// Optimistic create atom
export const optimisticCreateUserAtom = atom(
  null,
  async (get, set, userData: Parameters<typeof UserActions.createUser>[0]) => {
    const tempId = `temp-${Date.now()}-${Math.random()}`;
    
    // Create optimistic model with defaults for required fields
    const scalarFields = Object.fromEntries(
      Object.entries(userData).filter(([key, value]) => 
        typeof value !== 'object' || value instanceof Date || value === null
      )
    );
    
    const optimisticUser = { 
      ...scalarFields,
      id: tempId,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as any; // Will be replaced with server response
    
    // Optimistic update
    set(baseUsersAtom, (draft) => {
      draft[tempId] = optimisticUser as User;
    });
    set(userCreatingAtom, true);
    set(usersErrorAtom, null);
    
    try {
      const createdUser = await UserActions.createUser(userData);
      
      // Replace optimistic entry with real data
      set(baseUsersAtom, (draft) => {
        delete draft[tempId];
        draft[createdUser.id] = createdUser;
      });
      
      return createdUser;
    } catch (error) {
      // Rollback optimistic update
      set(baseUsersAtom, (draft) => {
        delete draft[tempId];
      });
      set(usersErrorAtom, error instanceof Error ? error.message : 'Failed to create user');
      throw error;
    } finally {
      set(userCreatingAtom, false);
    }
  }
);

// Optimistic update atom
export const optimisticUpdateUserAtom = atom(
  null,
  async (get, set, { id, data }: { id: string; data: Parameters<typeof UserActions.updateUser>[1] }) => {
    const currentUser = get(baseUsersAtom)[id];
    if (!currentUser) {
      throw new Error('User not found');
    }
    
    // Set loading state
    set(userUpdatingAtom, (prev) => ({ ...prev, [id]: true }));
    set(usersErrorAtom, null);
    
    try {
      const updatedUser = await UserActions.updateUser(id, data);
      
      // Update with server response
      set(baseUsersAtom, (draft) => {
        draft[id] = updatedUser;
      });
      
      return updatedUser;
    } catch (error) {
      set(usersErrorAtom, error instanceof Error ? error.message : 'Failed to update user');
      throw error;
    } finally {
      set(userUpdatingAtom, (prev) => {
        const { [id]: _, ...rest } = prev;
        return rest;
      });
    }
  }
);

// Optimistic delete atom
export const optimisticDeleteUserAtom = atom(
  null,
  async (get, set, id: string) => {
    const userToDelete = get(baseUsersAtom)[id];
    if (!userToDelete) {
      throw new Error('User not found');
    }
    
    // Optimistic removal
    set(baseUsersAtom, (draft) => {
      delete draft[id];
    });
    set(userDeletingAtom, (prev) => ({ ...prev, [id]: true }));
    set(usersErrorAtom, null);
    
    try {
      await UserActions.deleteUser(id);
    } catch (error) {
      // Rollback: restore the deleted item
      set(baseUsersAtom, (draft) => {
        draft[id] = userToDelete;
      });
      set(usersErrorAtom, error instanceof Error ? error.message : 'Failed to delete user');
      throw error;
    } finally {
      set(userDeletingAtom, (prev) => {
        const { [id]: _, ...rest } = prev;
        return rest;
      });
    }
  }
);

// Utility atoms for computed state
export const userCountAtom = atom((get) => {
  const users = get(userListAtom);
  return users.length;
});

export const isUsersEmptyAtom = atom((get) => {
  const count = get(userCountAtom);
  return count === 0;
});
