// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-01T21:12:21.074Z

'use client';

import { useAtom, useAtomValue, useSetAtom } from 'jotai';
import { useCallback, useEffect, useRef } from 'react';
import {
  baseCategoriesAtom,
  categoryListAtom,
  categoriesLoadingAtom,
  categoryCreatingAtom,
  categoryUpdatingAtom,
  categoryDeletingAtom,
  categoriesErrorAtom,
  refreshCategoriesAtom,
  categoryByIdAtom,
  optimisticCreateCategoryAtom,
  optimisticUpdateCategoryAtom,
  optimisticDeleteCategoryAtom,
  categoryCountAtom,
  isCategoriesEmptyAtom,
} from './atoms';
import type { Category } from './types';
import * as CategoryActions from './actions';

export interface UseCategoriesResult {
  categories: Category[];
  loading: boolean;
  creating: boolean;
  error: string | null;
  count: number;
  isEmpty: boolean;
  refresh: () => void;
}

export function useCategories(autoFetch = true): UseCategoriesResult {
  const categories = useAtomValue(categoryListAtom);
  const loading = useAtomValue(categoriesLoadingAtom);
  const creating = useAtomValue(categoryCreatingAtom);
  const error = useAtomValue(categoriesErrorAtom);
  const count = useAtomValue(categoryCountAtom);
  const isEmpty = useAtomValue(isCategoriesEmptyAtom);
  const refresh = useSetAtom(refreshCategoriesAtom);
  
  // Track if we've already attempted to auto-fetch to prevent infinite loops
  const hasFetchedRef = useRef(false);

  // Auto-fetch on mount if enabled and no data exists (only once)
  useEffect(() => {
    if (autoFetch && isEmpty && !loading && !hasFetchedRef.current) {
      hasFetchedRef.current = true;
      refresh();
    }
  }, [autoFetch, isEmpty, loading, refresh]);

  return {
    categories,
    loading,
    creating,
    error,
    count,
    isEmpty,
    refresh: useCallback(() => refresh(), [refresh]),
  };
}

export interface UseCategoryResult {
  category: Category | null;
  loading: boolean;
  updating: boolean;
  deleting: boolean;
  error: string | null;
}

export function useCategory(id: string): UseCategoryResult {
  const category = useAtomValue(categoryByIdAtom(id));
  const loading = useAtomValue(categoriesLoadingAtom);
  const updatingStates = useAtomValue(categoryUpdatingAtom);
  const deletingStates = useAtomValue(categoryDeletingAtom);
  const error = useAtomValue(categoriesErrorAtom);

  return {
    category,
    loading,
    updating: updatingStates[id] || false,
    deleting: deletingStates[id] || false,
    error,
  };
}

export interface UseCreateCategoryResult {
  createCategory: (data: Parameters<typeof CategoryActions.createCategory>[0]) => Promise<Category>;
  creating: boolean;
  error: string | null;
}

export function useCreateCategory(): UseCreateCategoryResult {
  const creating = useAtomValue(categoryCreatingAtom);
  const error = useAtomValue(categoriesErrorAtom);
  const createCategory = useSetAtom(optimisticCreateCategoryAtom);

  return {
    createCategory: useCallback(
      async (data: Parameters<typeof CategoryActions.createCategory>[0]) => {
        return await createCategory(data);
      },
      [createCategory]
    ),
    creating,
    error,
  };
}

export interface UseUpdateCategoryResult {
  updateCategory: (id: string, data: Parameters<typeof CategoryActions.updateCategory>[1]) => Promise<Category>;
  updating: (id: string) => boolean;
  error: string | null;
}

export function useUpdateCategory(): UseUpdateCategoryResult {
  const updatingStates = useAtomValue(categoryUpdatingAtom);
  const error = useAtomValue(categoriesErrorAtom);
  const updateCategory = useSetAtom(optimisticUpdateCategoryAtom);

  return {
    updateCategory: useCallback(
      async (id: string, data: Parameters<typeof CategoryActions.updateCategory>[1]) => {
        return await updateCategory({ id, data });
      },
      [updateCategory]
    ),
    updating: useCallback((id: string) => updatingStates[id] || false, [updatingStates]),
    error,
  };
}

export interface UseDeleteCategoryResult {
  deleteCategory: (id: string) => Promise<void>;
  deleting: (id: string) => boolean;
  error: string | null;
}

export function useDeleteCategory(): UseDeleteCategoryResult {
  const deletingStates = useAtomValue(categoryDeletingAtom);
  const error = useAtomValue(categoriesErrorAtom);
  const deleteCategory = useSetAtom(optimisticDeleteCategoryAtom);

  return {
    deleteCategory: useCallback(
      async (id: string) => {
        await deleteCategory(id);
      },
      [deleteCategory]
    ),
    deleting: useCallback((id: string) => deletingStates[id] || false, [deletingStates]),
    error,
  };
}

// Combined mutation hook for convenience
export interface UseCategoryMutationsResult {
  createCategory: (data: Parameters<typeof CategoryActions.createCategory>[0]) => Promise<Category>;
  updateCategory: (id: string, data: Parameters<typeof CategoryActions.updateCategory>[1]) => Promise<Category>;
  deleteCategory: (id: string) => Promise<void>;
  creating: boolean;
  updating: (id: string) => boolean;
  deleting: (id: string) => boolean;
  error: string | null;
}

export function useCategoryMutations(): UseCategoryMutationsResult {
  const { createCategory, creating } = useCreateCategory();
  const { updateCategory, updating } = useUpdateCategory();
  const { deleteCategory, deleting } = useDeleteCategory();
  const error = useAtomValue(categoriesErrorAtom);

  return {
    createCategory,
    updateCategory,
    deleteCategory,
    creating,
    updating,
    deleting,
    error,
  };
}

// Batch operations hooks
export interface UseBatchCategoryOperationsResult {
  createManyCategories: (data: Parameters<typeof CategoryActions.createManyCategories>[0]) => Promise<{ count: number }>;
  deleteManyCategories: (ids: string[]) => Promise<{ count: number }>;
  processing: boolean;
  error: string | null;
}

export function useBatchCategoryOperations(): UseBatchCategoryOperationsResult {
  const [processing, setProcessing] = useAtom(categoriesLoadingAtom);
  const error = useAtomValue(categoriesErrorAtom);
  const refresh = useSetAtom(refreshCategoriesAtom);

  const createManyCategories = useCallback(
    async (data: Parameters<typeof CategoryActions.createManyCategories>[0]) => {
      setProcessing(true);
      try {
        const result = await CategoryActions.createManyCategories(data);
        refresh(); // Refresh the list after batch create
        return result;
      } finally {
        setProcessing(false);
      }
    },
    [setProcessing, refresh]
  );

  const deleteManyCategories = useCallback(
    async (ids: string[]) => {
      setProcessing(true);
      try {
        const result = await CategoryActions.deleteManyCategories(ids);
        refresh(); // Refresh the list after batch delete
        return result;
      } finally {
        setProcessing(false);
      }
    },
    [setProcessing, refresh]
  );

  return {
    createManyCategories,
    deleteManyCategories,
    processing,
    error,
  };
}

// Utility hook for category existence check
export function useCategoryExists(id: string): boolean {
  const category = useAtomValue(categoryByIdAtom(id));
  return !!category;
}
