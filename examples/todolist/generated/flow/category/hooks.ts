// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-07T12:32:18.077Z

'use client';

import { useAtom, useAtomValue, useSetAtom } from 'jotai';
import { useCallback, useEffect, useRef, useState, useMemo } from 'react';
import {
  baseCategoriesAtom,
  categoryListAtom,
  categoriesLoadingAtom,
  categoryCreatingAtom,
  categoryUpdatingAtom,
  categoryDeletingAtom,
  categoriesErrorAtom,
  refreshCategoriesAtom,
  categoryByIdAtom,
  optimisticCreateCategoryAtom,
  optimisticUpdateCategoryAtom,
  optimisticDeleteCategoryAtom,
  categoryCountAtom,
  isCategoriesEmptyAtom,
} from './atoms';
import type { 
  Category, 
  CategoryCreateInput, 
  CategoryUpdateInput,
  CategoryFormData,
  CategoryFieldConfig
} from './types';
import { CategoryCreateInputSchema, CategoryUpdateInputSchema } from './types';
import * as CategoryActions from './actions';

// ============================================================================
// ENHANCED UNIFIED HOOKS - Everything you need in one hook
// ============================================================================

export interface UseCategoriesResult {
  // Data
  data: Category[];
  loading: boolean;
  error: string | null;
  count: number;
  isEmpty: boolean;
  
  // CRUD operations
  createCategory: (data: CategoryCreateInput) => Promise<Category>;
  updateCategory: (id: string, data: CategoryUpdateInput) => Promise<Category>;
  deleteCategory: (id: string) => Promise<void>;
  
  // Batch operations
  createMany: (data: CategoryCreateInput[]) => Promise<{ count: number }>;
  deleteMany: (ids: string[]) => Promise<{ count: number }>;
  
  // State management
  refresh: () => void;
  
  // Loading states for individual operations
  isCreating: boolean;
  isUpdating: (id: string) => boolean;
  isDeleting: (id: string) => boolean;
  
  // Optimistic updates info
  optimisticUpdates: Record<string, boolean>;
}

export function useCategories(autoFetch = true): UseCategoriesResult {
  const data = useAtomValue(categoryListAtom);
  const loading = useAtomValue(categoriesLoadingAtom);
  const creating = useAtomValue(categoryCreatingAtom);
  const updatingStates = useAtomValue(categoryUpdatingAtom);
  const deletingStates = useAtomValue(categoryDeletingAtom);
  const error = useAtomValue(categoriesErrorAtom);
  const count = useAtomValue(categoryCountAtom);
  const isEmpty = useAtomValue(isCategoriesEmptyAtom);
  const refresh = useSetAtom(refreshCategoriesAtom);
  
  // Action atoms for optimistic updates
  const createCategory = useSetAtom(optimisticCreateCategoryAtom);
  const updateCategory = useSetAtom(optimisticUpdateCategoryAtom);
  const deleteCategory = useSetAtom(optimisticDeleteCategoryAtom);
  
  // Track if we've already attempted to auto-fetch to prevent infinite loops
  const hasFetchedRef = useRef(false);

  // Auto-fetch on mount if enabled and no data exists (only once)
  useEffect(() => {
    if (autoFetch && isEmpty && !loading && !hasFetchedRef.current) {
      hasFetchedRef.current = true;
      refresh();
    }
  }, [autoFetch, isEmpty, loading, refresh]);

  // Batch operations
  const createMany = useCallback(
    async (inputs: CategoryCreateInput[]) => {
      return await CategoryActions.createManyCategories(inputs);
    },
    []
  );

  const deleteMany = useCallback(
    async (ids: string[]) => {
      return await CategoryActions.deleteManyCategories(ids);
    },
    []
  );

  return {
    data,
    loading,
    error,
    count,
    isEmpty,
    createCategory: useCallback(
      async (data: CategoryCreateInput) => await createCategory(data),
      [createCategory]
    ),
    updateCategory: useCallback(
      async (id: string, data: CategoryUpdateInput) => 
        await updateCategory({ id, data }),
      [updateCategory]
    ),
    deleteCategory: useCallback(
      async (id: string) => await deleteCategory(id),
      [deleteCategory]
    ),
    createMany,
    deleteMany,
    refresh: useCallback(() => refresh(), [refresh]),
    isCreating: creating,
    isUpdating: useCallback((id: string) => updatingStates[id] || false, [updatingStates]),
    isDeleting: useCallback((id: string) => deletingStates[id] || false, [deletingStates]),
    optimisticUpdates: updatingStates,
  };
}

// ============================================================================
// ENHANCED INDIVIDUAL ITEM HOOK - Smart item management with form integration
// ============================================================================

export interface UseCategoryResult {
  // Data
  data: Category | null;
  loading: boolean;
  error: string | null;
  
  // Operations
  update: (data: CategoryUpdateInput) => Promise<Category>;
  delete: () => Promise<void>;
  
  // State
  isUpdating: boolean;
  isDeleting: boolean;
  isOptimistic: boolean;
  
  // Form integration
  form: UseUpdateCategoryFormResult;
}

export function useCategory(id: string): UseCategoryResult {
  const data = useAtomValue(categoryByIdAtom(id));
  const loading = useAtomValue(categoriesLoadingAtom);
  const updatingStates = useAtomValue(categoryUpdatingAtom);
  const deletingStates = useAtomValue(categoryDeletingAtom);
  const error = useAtomValue(categoriesErrorAtom);
  
  const updateCategory = useSetAtom(optimisticUpdateCategoryAtom);
  const deleteCategory = useSetAtom(optimisticDeleteCategoryAtom);
  
  // Filter data to only include update input fields (remove relations and computed fields)
  const filteredData = data ? Object.fromEntries(
    Object.entries(data).filter(([key]) => 
      // Exclude common relational and computed fields
      !['user', 'category', 'todos', 'posts', 'comments', 'profile'].includes(key)
    )
  ) : undefined;
  
  const form = useUpdateCategoryForm(id, filteredData);

  return {
    data,
    loading,
    error,
    update: useCallback(
      async (updateData: CategoryUpdateInput) => 
        await updateCategory({ id, data: updateData }),
      [updateCategory, id]
    ),
    delete: useCallback(
      async () => await deleteCategory(id),
      [deleteCategory, id]
    ),
    isUpdating: updatingStates[id] || false,
    isDeleting: deletingStates[id] || false,
    isOptimistic: !!(updatingStates[id] || deletingStates[id]),
    form,
  };
}


// ============================================================================
// SPECIALIZED FORM HOOKS - Dedicated hooks for create and update operations
// ============================================================================

export interface UseCreateCategoryFormResult {
  // Form state
  data: Partial<CategoryCreateInput>;
  isValid: boolean;
  isDirty: boolean;
  errors: Record<string, string>;
  
  // Field helpers with auto-validation
  field: (name: keyof CategoryCreateInput) => CategoryFieldConfig;
  
  // Form operations
  submit: () => Promise<Category | null>;
  reset: () => void;
  setData: (data: Partial<CategoryCreateInput>) => void;
  
  // Loading states
  loading: boolean;
  error: Error | null;
  
  // Validation
  validate: () => boolean;
  validateField: (field: keyof CategoryCreateInput) => boolean;
  
  // Auto-save capabilities
  enableAutoSave: (debounceMs?: number) => void;
  disableAutoSave: () => void;
}

export function useCreateCategoryForm(initialData?: Partial<CategoryCreateInput>): UseCreateCategoryFormResult {
  const [data, setFormData] = useState<Partial<CategoryCreateInput>>(initialData || {});
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [touched, setTouched] = useState<Record<string, boolean>>({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [autoSaveEnabled, setAutoSaveEnabled] = useState(false);
  const [autoSaveTimeout, setAutoSaveTimeout] = useState<NodeJS.Timeout | null>(null);
  
  const createCategory = useSetAtom(optimisticCreateCategoryAtom);
  
  // Check if form is dirty
  const isDirty = useMemo(() => {
    if (!initialData) return Object.keys(data).length > 0;
    return JSON.stringify(data) !== JSON.stringify(initialData);
  }, [data, initialData]);
  
  // Validate individual field
  const validateField = useCallback((fieldName: keyof CategoryCreateInput): boolean => {
    try {
      const value = data[fieldName];
      if (value !== undefined && value !== null && value !== '') {
        setErrors(prev => {
          const newErrors = { ...prev };
          delete newErrors[fieldName as string];
          return newErrors;
        });
        return true;
      }
      return true;
    } catch (err: any) {
      setErrors(prev => ({
        ...prev,
        [fieldName as string]: err.errors?.[0]?.message || 'Invalid value'
      }));
      return false;
    }
  }, [data]);
  
  // Validate entire form
  const validate = useCallback((): boolean => {
    try {
      CategoryCreateInputSchema.parse(data);
      setErrors({});
      return true;
    } catch (err: any) {
      const newErrors: Record<string, string> = {};
      err.errors?.forEach((error: any) => {
        if (error.path?.length > 0) {
          newErrors[error.path[0]] = error.message;
        }
      });
      setErrors(newErrors);
      return false;
    }
  }, [data]);
  
  // Check if form is valid
  const isValid = useMemo(() => {
    try {
      CategoryCreateInputSchema.parse(data);
      return true;
    } catch {
      return false;
    }
  }, [data]);
  
  // Memoized field helpers to prevent unnecessary re-renders
  const fieldConfigs = useMemo(() => {
    const configs: Record<string, CategoryFieldConfig> = {};
    return configs;
  }, []);

  // Field helper function with internal memoization
  const field = useCallback((name: keyof CategoryCreateInput): CategoryFieldConfig => {
    const cacheKey = `${name}-${data[name]}-${errors[name as string]}-${touched[name as string]}`;
    
    if (!fieldConfigs[cacheKey]) {
      fieldConfigs[cacheKey] = {
        name: name as string,
        value: data[name] ?? '',
        onChange: (value: any) => {
          setFormData(prev => ({ ...prev, [name]: value }));
          
          // Auto-save logic
          if (autoSaveEnabled && autoSaveTimeout) {
            clearTimeout(autoSaveTimeout);
          }
          if (autoSaveEnabled) {
            const timeout = setTimeout(() => {
              if (isValid) {
                submit();
              }
            }, 1000);
            setAutoSaveTimeout(timeout);
          }
        },
        onBlur: () => {
          setTouched(prev => ({ ...prev, [name]: true }));
          validateField(name);
        },
        error: touched[name as string] ? errors[name as string] : undefined,
        required: true, // TODO: Determine from schema
      };
    }
    
    return fieldConfigs[cacheKey];
  }, [data, errors, touched, validateField, autoSaveEnabled, autoSaveTimeout, isValid, fieldConfigs]);
  
  // Submit form
  const submit = useCallback(async (): Promise<Category | null> => {
    if (!validate()) {
      return null;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const result = await createCategory(data as CategoryCreateInput);
      
      // Reset form on successful create
      setFormData({});
      setTouched({});
      setErrors({});
      
      return result;
    } catch (err: any) {
      setError(err);
      return null;
    } finally {
      setLoading(false);
    }
  }, [data, validate, createCategory]);
  
  // Reset form
  const reset = useCallback(() => {
    setFormData(initialData || {});
    setErrors({});
    setTouched({});
    setError(null);
  }, [initialData]);
  
  // Set form data
  const setData = useCallback((newData: Partial<CategoryCreateInput>) => {
    setFormData(newData);
  }, []);
  
  // Auto-save functionality
  const enableAutoSave = useCallback((debounceMs = 1000) => {
    setAutoSaveEnabled(true);
  }, []);
  
  const disableAutoSave = useCallback(() => {
    setAutoSaveEnabled(false);
    if (autoSaveTimeout) {
      clearTimeout(autoSaveTimeout);
      setAutoSaveTimeout(null);
    }
  }, [autoSaveTimeout]);
  
  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (autoSaveTimeout) {
        clearTimeout(autoSaveTimeout);
      }
    };
  }, [autoSaveTimeout]);

  return {
    data,
    isValid,
    isDirty,
    errors,
    field,
    submit,
    reset,
    setData,
    loading,
    error,
    validate,
    validateField,
    enableAutoSave,
    disableAutoSave,
  };
}

export interface UseUpdateCategoryFormResult {
  // Form state
  data: Partial<CategoryUpdateInput>;
  isValid: boolean;
  isDirty: boolean;
  errors: Record<string, string>;
  
  // Field helpers with auto-validation
  field: (name: keyof CategoryUpdateInput) => CategoryFieldConfig;
  
  // Form operations
  submit: () => Promise<Category | null>;
  reset: () => void;
  setData: (data: Partial<CategoryUpdateInput>) => void;
  
  // Loading states
  loading: boolean;
  error: Error | null;
  
  // Validation
  validate: () => boolean;
  validateField: (field: keyof CategoryUpdateInput) => boolean;
  
  // Auto-save capabilities
  enableAutoSave: (debounceMs?: number) => void;
  disableAutoSave: () => void;
  
  // ID for update operations
  id: string;
}

export function useUpdateCategoryForm(id: string, initialData?: Partial<CategoryUpdateInput>): UseUpdateCategoryFormResult {
  const [data, setFormData] = useState<Partial<CategoryUpdateInput>>(initialData || {});
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [touched, setTouched] = useState<Record<string, boolean>>({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [autoSaveEnabled, setAutoSaveEnabled] = useState(false);
  const [autoSaveTimeout, setAutoSaveTimeout] = useState<NodeJS.Timeout | null>(null);
  
  const updateCategory = useSetAtom(optimisticUpdateCategoryAtom);
  
  // Check if form is dirty
  const isDirty = useMemo(() => {
    if (!initialData) return Object.keys(data).length > 0;
    return JSON.stringify(data) !== JSON.stringify(initialData);
  }, [data, initialData]);
  
  // Validate individual field
  const validateField = useCallback((fieldName: keyof CategoryUpdateInput): boolean => {
    try {
      const value = data[fieldName];
      if (value !== undefined && value !== null && value !== '') {
        setErrors(prev => {
          const newErrors = { ...prev };
          delete newErrors[fieldName as string];
          return newErrors;
        });
        return true;
      }
      return true;
    } catch (err: any) {
      setErrors(prev => ({
        ...prev,
        [fieldName as string]: err.errors?.[0]?.message || 'Invalid value'
      }));
      return false;
    }
  }, [data]);
  
  // Validate entire form
  const validate = useCallback((): boolean => {
    try {
      CategoryUpdateInputSchema.parse(data);
      setErrors({});
      return true;
    } catch (err: any) {
      const newErrors: Record<string, string> = {};
      err.errors?.forEach((error: any) => {
        if (error.path?.length > 0) {
          newErrors[error.path[0]] = error.message;
        }
      });
      setErrors(newErrors);
      return false;
    }
  }, [data]);
  
  // Check if form is valid
  const isValid = useMemo(() => {
    try {
      CategoryUpdateInputSchema.parse(data);
      return true;
    } catch {
      return false;
    }
  }, [data]);
  
  // Memoized field helpers to prevent unnecessary re-renders
  const updateFieldConfigs = useMemo(() => {
    const configs: Record<string, CategoryFieldConfig> = {};
    return configs;
  }, []);

  // Field helper function with internal memoization
  const field = useCallback((name: keyof CategoryUpdateInput): CategoryFieldConfig => {
    const cacheKey = `${name}-${data[name]}-${errors[name as string]}-${touched[name as string]}`;
    
    if (!updateFieldConfigs[cacheKey]) {
      updateFieldConfigs[cacheKey] = {
        name: name as string,
        value: data[name] ?? '',
        onChange: (value: any) => {
          setFormData(prev => ({ ...prev, [name]: value }));
          
          // Auto-save logic
          if (autoSaveEnabled && autoSaveTimeout) {
            clearTimeout(autoSaveTimeout);
          }
          if (autoSaveEnabled) {
            const timeout = setTimeout(() => {
              if (isValid) {
                submit();
              }
            }, 1000);
            setAutoSaveTimeout(timeout);
          }
        },
        onBlur: () => {
          setTouched(prev => ({ ...prev, [name]: true }));
          validateField(name);
        },
        error: touched[name as string] ? errors[name as string] : undefined,
        required: false, // Update fields are typically optional
      };
    }
    
    return updateFieldConfigs[cacheKey];
  }, [data, errors, touched, validateField, autoSaveEnabled, autoSaveTimeout, isValid, updateFieldConfigs]);
  
  // Submit form
  const submit = useCallback(async (): Promise<Category | null> => {
    if (!validate()) {
      return null;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const result = await updateCategory({ id, data: data as CategoryUpdateInput });
      return result;
    } catch (err: any) {
      setError(err);
      return null;
    } finally {
      setLoading(false);
    }
  }, [data, validate, updateCategory, id]);
  
  // Reset form
  const reset = useCallback(() => {
    setFormData(initialData || {});
    setErrors({});
    setTouched({});
    setError(null);
  }, [initialData]);
  
  // Set form data
  const setData = useCallback((newData: Partial<CategoryUpdateInput>) => {
    setFormData(newData);
  }, []);
  
  // Auto-save functionality
  const enableAutoSave = useCallback((debounceMs = 1000) => {
    setAutoSaveEnabled(true);
  }, []);
  
  const disableAutoSave = useCallback(() => {
    setAutoSaveEnabled(false);
    if (autoSaveTimeout) {
      clearTimeout(autoSaveTimeout);
      setAutoSaveTimeout(null);
    }
  }, [autoSaveTimeout]);
  
  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (autoSaveTimeout) {
        clearTimeout(autoSaveTimeout);
      }
    };
  }, [autoSaveTimeout]);

  return {
    data,
    isValid,
    isDirty,
    errors,
    field,
    submit,
    reset,
    setData,
    loading,
    error,
    validate,
    validateField,
    enableAutoSave,
    disableAutoSave,
    id,
  };
}

// ============================================================================
// UTILITY HOOKS
// ============================================================================

export function useCategoryExists(id: string): boolean {
  const category = useAtomValue(categoryByIdAtom(id));
  return !!category;
}

