// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-01T19:44:19.115Z

import { atom } from "jotai";
import { atomWithImmer } from "jotai-immer";
import type { Category } from "./types";
import * as CategoryActions from "./actions";

// Base atom to store all categories by ID for efficient updates
export const baseCategoriesAtom = atomWithImmer<Record<string, Category>>({});

// Derived atom for the list of categories
export const categoryListAtom = atom((get) => {
	const categoriesMap = get(baseCategoriesAtom);
	return Object.values(categoriesMap);
});

// Loading state atoms
export const categoriesLoadingAtom = atom<boolean>(false);
export const categoryCreatingAtom = atom<boolean>(false);
export const categoryUpdatingAtom = atom<Record<string, boolean>>({});
export const categoryDeletingAtom = atom<Record<string, boolean>>({});

// Error state atoms
export const categoriesErrorAtom = atom<string | null>(null);

// Refresh action atom - when written to, fetches fresh data
export const refreshCategoriesAtom = atom(null, async (_get, set) => {
	set(categoriesLoadingAtom, true);
	set(categoriesErrorAtom, null);

	try {
		const categories = await CategoryActions.getAllCategories();
		const categoriesMap = Object.fromEntries(categories.map((category) => [category.id, category]));
		set(baseCategoriesAtom, categoriesMap);
	} catch (error) {
		set(categoriesErrorAtom, error instanceof Error ? error.message : "Failed to fetch categories");
	} finally {
		set(categoriesLoadingAtom, false);
	}
});

// Individual category atom by ID
export const categoryByIdAtom = (id: string) =>
	atom((get) => {
		const categoriesMap = get(baseCategoriesAtom);
		return categoriesMap[id] || null;
	});

// Optimistic create atom
export const optimisticCreateCategoryAtom = atom(
	null,
	async (get, set, categoryData: Parameters<typeof CategoryActions.createCategory>[0]) => {
		const tempId = `temp-${Date.now()}-${Math.random()}`;
		const optimisticCategory = {
			...categoryData,
			id: tempId,
			createdAt: new Date(),
			updatedAt: new Date(),
		} as Category;

		// Optimistic update
		set(baseCategoriesAtom, (draft) => {
			draft[tempId] = optimisticCategory;
		});
		set(categoryCreatingAtom, true);
		set(categoriesErrorAtom, null);

		try {
			const createdCategory = await CategoryActions.createCategory(categoryData);

			// Replace optimistic entry with real data
			set(baseCategoriesAtom, (draft) => {
				delete draft[tempId];
				draft[createdCategory.id] = createdCategory;
			});

			return createdCategory;
		} catch (error) {
			// Rollback optimistic update
			set(baseCategoriesAtom, (draft) => {
				delete draft[tempId];
			});
			set(categoriesErrorAtom, error instanceof Error ? error.message : "Failed to create category");
			throw error;
		} finally {
			set(categoryCreatingAtom, false);
		}
	},
);

// Optimistic update atom
export const optimisticUpdateCategoryAtom = atom(
	null,
	async (get, set, { id, data }: { id: string; data: Parameters<typeof CategoryActions.updateCategory>[1] }) => {
		const currentCategory = get(baseCategoriesAtom)[id];
		if (!currentCategory) {
			throw new Error("Category not found");
		}

		// Store original for rollback
		const originalCategory = { ...currentCategory };

		// Optimistic update
		set(baseCategoriesAtom, (draft) => {
			draft[id] = { ...draft[id], ...data, updatedAt: new Date() };
		});
		set(categoryUpdatingAtom, (prev) => ({ ...prev, [id]: true }));
		set(categoriesErrorAtom, null);

		try {
			const updatedCategory = await CategoryActions.updateCategory(id, data);

			// Update with server response
			set(baseCategoriesAtom, (draft) => {
				draft[id] = updatedCategory;
			});

			return updatedCategory;
		} catch (error) {
			// Rollback to original state
			set(baseCategoriesAtom, (draft) => {
				draft[id] = originalCategory;
			});
			set(categoriesErrorAtom, error instanceof Error ? error.message : "Failed to update category");
			throw error;
		} finally {
			set(categoryUpdatingAtom, (prev) => {
				const { [id]: _, ...rest } = prev;
				return rest;
			});
		}
	},
);

// Optimistic delete atom
export const optimisticDeleteCategoryAtom = atom(null, async (get, set, id: string) => {
	const categoryToDelete = get(baseCategoriesAtom)[id];
	if (!categoryToDelete) {
		throw new Error("Category not found");
	}

	// Optimistic removal
	set(baseCategoriesAtom, (draft) => {
		delete draft[id];
	});
	set(categoryDeletingAtom, (prev) => ({ ...prev, [id]: true }));
	set(categoriesErrorAtom, null);

	try {
		await CategoryActions.deleteCategory(id);
	} catch (error) {
		// Rollback: restore the deleted item
		set(baseCategoriesAtom, (draft) => {
			draft[id] = categoryToDelete;
		});
		set(categoriesErrorAtom, error instanceof Error ? error.message : "Failed to delete category");
		throw error;
	} finally {
		set(categoryDeletingAtom, (prev) => {
			const { [id]: _, ...rest } = prev;
			return rest;
		});
	}
});

// Utility atoms for computed state
export const categoryCountAtom = atom((get) => {
	const categories = get(categoryListAtom);
	return categories.length;
});

export const isCategoriesEmptyAtom = atom((get) => {
	const count = get(categoryCountAtom);
	return count === 0;
});
