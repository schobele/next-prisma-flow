// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-05T08:52:12.054Z

'use client';

import { useMemo, useCallback } from 'react';
import { 
  useCreateCategoryForm, 
  useUpdateCategoryForm,
  type UseCreateCategoryFormResult,
  type UseUpdateCategoryFormResult,
} from './hooks';
import type { 
  Category,
  CategoryCreateInput,
  CategoryUpdateInput,
  CategoryFieldConfig
} from './types';

// ============================================================================
// SMART FORM HOOK - Handles create/update mode detection and field memoization
// ============================================================================

export interface UseCategorySmartFormOptions {
  mode?: 'create' | 'update';
  initialData?: any; // Flexible to accept various data shapes
  id?: string;
  autoDetectMode?: boolean; // Default true
}

export interface UseCategorySmartFormResult {
  // Mode detection
  isCreateMode: boolean;
  isUpdateMode: boolean;
  
  // Form state (unified interface)
  data: Partial<CategoryCreateInput | CategoryUpdateInput>;
  isValid: boolean;
  isDirty: boolean;
  errors: Record<string, string>;
  loading: boolean;
  error: Error | null;
  
  // Optimized field accessor (memoized internally)
  field: (name: keyof CategoryCreateInput) => CategoryFieldConfig;
  
  // Actions
  submit: () => Promise<Category | null>;
  reset: () => void;
  setData: (data: Partial<CategoryCreateInput | CategoryUpdateInput>) => void;
  
  // Auto-save
  enableAutoSave: (debounceMs?: number) => void;
  disableAutoSave: () => void;
  
  // Form-specific data (when in update mode)
  id?: string;
}

export function useCategorySmartForm({
  mode,
  initialData,
  id,
  autoDetectMode = true,
}: UseCategorySmartFormOptions = {}): UseCategorySmartFormResult {
  
  // Smart mode detection
  const detectedMode = useMemo(() => {
    if (mode) return mode;
    if (autoDetectMode && initialData && 'id' in initialData && initialData.id) {
      return 'update';
    }
    return 'create';
  }, [mode, initialData, autoDetectMode]);

  const isCreateMode = detectedMode === 'create';
  const isUpdateMode = detectedMode === 'update';

  // Filter initial data to remove read-only fields
  const filteredInitialData = useMemo(() => {
    if (!initialData) return undefined;
    
    // Remove read-only and relational fields
    const { 
      createdAt, 
      updatedAt, 
      user, 
      category, 
      todos, 
      posts, 
      comments, 
      profile,
      ...cleanData 
    } = initialData as any;
    
    return cleanData;
  }, [initialData]);

  // Get the ID for update operations
  const updateId = useMemo(() => {
    if (id) return id;
    if (initialData && 'id' in initialData) return initialData.id as string;
    return 'temp-id'; // Fallback for hooks
  }, [id, initialData]);

  // Always call both hooks (Rules of Hooks compliance)
  const createForm = useCreateCategoryForm(
    isCreateMode ? filteredInitialData : undefined
  );
  
  const updateForm = useUpdateCategoryForm(
    updateId,
    isUpdateMode ? filteredInitialData : undefined
  );

  // Select the active form
  const activeForm = isUpdateMode ? updateForm : createForm;

  // Optimized field accessor with internal memoization
  const field = useCallback((fieldName: keyof CategoryCreateInput): CategoryFieldConfig => {
    // The hooks already provide internal memoization
    return activeForm.field(fieldName);
  }, [activeForm]);

  // Unified submit that works for both create and update
  const submit = useCallback(async () => {
    return await activeForm.submit();
  }, [activeForm.submit]);

  // Unified reset
  const reset = useCallback(() => {
    activeForm.reset();
  }, [activeForm.reset]);

  // Unified setData with type safety
  const setData = useCallback((newData: Partial<CategoryCreateInput | CategoryUpdateInput>) => {
    activeForm.setData(newData as any);
  }, [activeForm.setData]);

  return {
    isCreateMode,
    isUpdateMode,
    data: activeForm.data,
    isValid: activeForm.isValid,
    isDirty: activeForm.isDirty,
    errors: activeForm.errors,
    loading: activeForm.loading,
    error: activeForm.error,
    field,
    submit,
    reset,
    setData,
    enableAutoSave: activeForm.enableAutoSave,
    disableAutoSave: activeForm.disableAutoSave,
    id: isUpdateMode ? updateId : undefined,
  };
}

// ============================================================================
// CONVENIENCE HOOKS FOR COMMON PATTERNS  
// ============================================================================

export function useCategoryCreateForm(initialData?: any) {
  return useCategorySmartForm({ 
    mode: 'create', 
    initialData, 
    autoDetectMode: false 
  });
}

export function useCategoryUpdateForm(id: string, initialData?: any) {
  return useCategorySmartForm({ 
    mode: 'update', 
    id, 
    initialData, 
    autoDetectMode: false 
  });
}
