// @generated by next-prisma-flow-state-engine
// file: types/transforms.ts

import type { Prisma } from "../../prisma";
import type { FlowPostCreate, FlowPostUpdate } from "./schemas";

export function transformPostCreate(
  input: FlowPostCreate,
): Prisma.PostCreateInput {
  const result: any = {};

  result.title = input.title;
  result.slug = input.slug;
  if ("excerpt" in input && input.excerpt !== undefined) {
    result.excerpt = input.excerpt;
  }
  result.content = input.content;
  if ("published" in input && input.published !== undefined) {
    result.published = input.published;
  }
  if ("publishedAt" in input && input.publishedAt !== undefined) {
    result.publishedAt = input.publishedAt;
  }
  if ("createdAt" in input && input.createdAt !== undefined) {
    result.createdAt = input.createdAt;
  }
  if (input.author !== undefined) {
    const authorData = input.author;
    if (authorData) {
      if ("connect" in authorData && authorData.connect) {
        result.author = { connect: authorData.connect };
      } else if ("create" in authorData && authorData.create) {
        result.author = { create: authorData.create as any };
      } else if (
        "connectOrCreate" in authorData &&
        authorData.connectOrCreate
      ) {
        result.author = {
          connectOrCreate: authorData.connectOrCreate as any,
        };
      }
    }
  }
  // Handle foreign key field when relation is not provided
  if (input.author === undefined && "authorId" in input && input.authorId) {
    result.author = { connect: { id: input.authorId } };
  }
  if (input.tags !== undefined) {
    const tagsData = input.tags;
    if (tagsData) {
      if ("connect" in tagsData && tagsData.connect) {
        result.tags = { connect: tagsData.connect };
      } else if ("create" in tagsData && tagsData.create) {
        result.tags = {
          create: tagsData.create as any,
        };
      } else if ("createMany" in tagsData && tagsData.createMany) {
      } else if ("connectOrCreate" in tagsData && tagsData.connectOrCreate) {
        result.tags = {
          connectOrCreate: tagsData.connectOrCreate as any,
        };
      }
    }
  }

  return result;
}

export function transformPostUpdate(
  input: FlowPostUpdate,
): Prisma.PostUpdateInput {
  const result: any = {};

  const titleValue = input.title;
  if (titleValue !== undefined && titleValue !== null) {
    result.title = titleValue;
  }
  const slugValue = input.slug;
  if (slugValue !== undefined && slugValue !== null) {
    result.slug = slugValue;
  }
  const excerptValue = input.excerpt;
  if (excerptValue !== undefined) {
    result.excerpt = excerptValue;
  }
  const contentValue = input.content;
  if (contentValue !== undefined && contentValue !== null) {
    result.content = contentValue;
  }
  const publishedValue = input.published;
  if (publishedValue !== undefined && publishedValue !== null) {
    result.published = publishedValue;
  }
  const publishedAtValue = input.publishedAt;
  if (publishedAtValue !== undefined) {
    result.publishedAt = publishedAtValue;
  }
  const createdAtValue = input.createdAt;
  if (createdAtValue !== undefined && createdAtValue !== null) {
    result.createdAt = createdAtValue;
  }
  if (input.author !== undefined) {
    const authorData = input.author;
    if (authorData) {
      result.author = authorData as any;
    }
  }
  if (input.tags !== undefined) {
    const tagsData = input.tags;
    if (tagsData) {
      result.tags = tagsData as any;
    }
  }

  return result;
}
