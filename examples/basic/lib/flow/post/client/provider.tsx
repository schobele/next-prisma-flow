// @generated by next-prisma-flow-state-engine
// file: client/provider.tsx

"use client";

import { type ReactNode, useEffect, useMemo, useCallback, useRef } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  FlowFormProvider,
  useFlowFormContext,
  type FlowFormFeatures,
  type FlowFormMode,
} from "../../core/form-provider";
import { PostCreateSchema, PostUpdateSchema } from "../types/schemas";
import type {
  FlowPost,
  FlowPostCreate,
  FlowPostUpdate,
} from "../types/schemas";
import { usePost, useCreatePost, useUpdatePost } from "./hooks";

/**
 * Props for the Post form component
 */
export interface FlowPostFormProps {
  children: ReactNode;

  /**
   * Form mode - determines behavior and data handling
   * - "create": New entity creation
   * - "update": Edit existing entity (requires id)
   * - "view": Read-only display
   */
  mode: FlowFormMode;

  /**
   * Entity ID for update mode
   */
  id?: string;

  /**
   * Default values for form fields
   */
  defaultValues?: Partial<FlowPostCreate | FlowPostUpdate>;

  /**
   * Callback when form is successfully submitted
   */
  onSuccess?: (data: FlowPost) => void | Promise<void>;

  /**
   * Callback when form submission fails
   */
  onError?: (error: Error) => void;

  /**
   * Form features configuration
   */
  features?: FlowFormFeatures;

  /**
   * Additional form element props
   */
  className?: string;
  style?: React.CSSProperties;
}

/**
 * Extract scalar fields from entity (removes relations)
 */
function extractScalarFields(data: any): any {
  if (!data) return {};
  const result: any = {};
  Object.keys(data).forEach((key) => {
    const value = data[key];
    if (value === null || value === undefined) {
      result[key] = value;
    } else if (typeof value !== "object" || value instanceof Date) {
      result[key] = value;
    } else if (!Array.isArray(value) && !value.id) {
      // Include simple objects without id (like JSON fields)
      result[key] = value;
    }
  });
  return result;
}

/**
 * Type-safe form component for Post
 *
 * @example
 * ```tsx
 * <FlowPostForm mode="create">
 *   <PostFormField
 *     name="title"
 *     render={({ field }) => (
 *       <FormItem>
 *         <FormLabel>Title</FormLabel>
 *         <FormControl>
 *           <Input {...field} />
 *         </FormControl>
 *         <FormMessage />
 *       </FormItem>
 *     )}
 *   />
 *   <Button type="submit">Submit</Button>
 * </FlowPostForm>
 * ```
 */
export function FlowPostForm({
  children,
  mode,
  id,
  defaultValues,
  onSuccess,
  onError,
  features,
  className,
  style,
}: FlowPostFormProps) {
  // Validate props
  if (mode === "update" && !id) {
    throw new Error(`FlowPostForm: id is required when mode is "update"`);
  }

  // Fetch existing data for update mode
  const { data: existingData, isLoading: isLoadingData } = usePost(id || "", {
    enabled: mode === "update" && !!id,
  });

  // Initialize form with proper schema based on mode
  const form = useForm<FlowPostCreate | FlowPostUpdate>({
    resolver: zodResolver(
      mode === "create" ? PostCreateSchema : PostUpdateSchema,
    ),
    defaultValues: defaultValues as any,
    mode: "onChange", // Enable real-time validation
  });

  // Track if we've loaded existing data
  const hasLoadedData = useRef(false);

  // Update form when existing data loads (for update mode)
  useEffect(() => {
    if (mode === "update" && existingData && !hasLoadedData.current) {
      const scalarData = extractScalarFields(existingData);
      form.reset(scalarData, {
        keepDefaultValues: false,
      });
      hasLoadedData.current = true;
    }
  }, [mode, existingData, form]);

  // Setup mutations
  const createMutation = useCreatePost({
    onSuccess: async (data) => {
      form.reset();
      hasLoadedData.current = false;
      await onSuccess?.(data);
    },
    onError,
  });

  const updateMutation = useUpdatePost(id!, {
    onSuccess: async (data) => {
      // Reset form with new data to clear dirty state
      const scalarData = extractScalarFields(data);
      form.reset(scalarData, {
        keepDefaultValues: false,
      });
      await onSuccess?.(data);
    },
    onError,
  });

  // Form submission handler
  const handleSubmit = useCallback(
    async (data: FlowPostCreate | FlowPostUpdate) => {
      try {
        if (mode === "create") {
          await createMutation.mutateAsync(data as FlowPostCreate);
        } else if (mode === "update") {
          await updateMutation.mutateAsync(data as FlowPostUpdate);
        }
      } catch (error) {
        // Error is already handled by mutation callbacks
        console.error("Form submission error:", error);
      }
    },
    [mode, createMutation, updateMutation],
  );

  // Autosave handler (for partial field updates)
  const handleAutosave = useCallback(
    async (data: Partial<FlowPostUpdate>) => {
      if (mode === "update" && id) {
        try {
          await updateMutation.mutateAsync(data as FlowPostUpdate);
        } catch (error) {
          console.error("Autosave error:", error);
          throw error;
        }
      }
    },
    [mode, id, updateMutation],
  );

  // Show loading state while fetching data in update mode
  if (mode === "update" && isLoadingData) {
    return (
      <div className={className} style={style}>
        <div className="flex items-center justify-center p-8">
          <span>Loading...</span>
        </div>
      </div>
    );
  }

  return (
    <form
      className={className}
      style={style}
      onSubmit={(e) => {
        e.preventDefault();
        e.stopPropagation();
      }}
    >
      <FlowFormProvider
        form={form as any}
        mode={mode}
        modelName="Post"
        features={features}
        onSubmit={handleSubmit}
        onSave={features?.autosave ? handleAutosave : undefined}
      >
        {children}
      </FlowFormProvider>
    </form>
  );
}

/**
 * Submit button that automatically shows loading state
 */
export function FlowPostFormSubmit({
  children = "Submit",
  className,
  ...props
}: React.ButtonHTMLAttributes<HTMLButtonElement>) {
  const { submit, isSubmitting } = useFlowFormContext();

  return (
    <button
      type="button"
      onClick={submit}
      disabled={isSubmitting}
      className={className}
      {...props}
    >
      {isSubmitting ? "Submitting..." : children}
    </button>
  );
}

/**
 * Reset button to clear form
 */
export function FlowPostFormReset({
  children = "Reset",
  className,
  ...props
}: React.ButtonHTMLAttributes<HTMLButtonElement>) {
  const { reset } = useFlowFormContext();

  return (
    <button type="button" onClick={reset} className={className} {...props}>
      {children}
    </button>
  );
}

/**
 * Form state indicator
 */
export function FlowPostFormState({ className }: { className?: string }) {
  const { hasUnsavedChanges, isSaving, autosave } = useFlowFormContext();

  if (!hasUnsavedChanges && !isSaving) {
    return null;
  }

  return (
    <div className={className}>
      {isSaving && <span>Saving...</span>}
      {!isSaving && hasUnsavedChanges && <span>Unsaved changes</span>}
      {autosave?.lastSaved && (
        <span>Last saved: {autosave.lastSaved.toLocaleTimeString()}</span>
      )}
    </div>
  );
}
