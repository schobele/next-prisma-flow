// @generated by next-prisma-flow-state-engine
// file: client/forms.ts

"use client";

import { useCallback, useEffect, useState, useRef } from "react";
import {
  useForm,
  type UseFormReturn,
  type UseFormProps,
} from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { CommentCreateSchema, CommentUpdateSchema } from "../types/schemas";
import type {
  FlowComment,
  FlowCommentCreate,
  FlowCommentUpdate,
} from "../types/schemas";
import { useComment, useCreateComment, useUpdateComment } from "./hooks";

export type CommentAutosaveConfig = {
  enabled: boolean;
  debounceMs?: number;
  fields?: string[];
  onFieldSave?: (field: string, value: any) => void;
  onFieldError?: (field: string, error: Error) => void;
};

export type CommentFormOptions = {
  id?: string;
  defaultValues?: Partial<FlowCommentCreate> | Partial<FlowCommentUpdate>;
  onSuccess?: (data: FlowComment) => void;
  onError?: (error: Error) => void;
  formOptions?: Omit<
    UseFormProps<FlowCommentCreate | FlowCommentUpdate>,
    "resolver" | "defaultValues"
  >;
  autosave?: CommentAutosaveConfig;
};

export function useCommentForm(options?: CommentFormOptions) {
  const { id, defaultValues, onSuccess, onError, formOptions, autosave } =
    options || {};

  // Smart mode detection
  const mode = id ? "update" : "create";

  // Autosave state
  const [fieldSaveStates, setFieldSaveStates] = useState<
    Record<string, "idle" | "saving" | "saved" | "error">
  >({});
  const debounceTimers = useRef<Record<string, NodeJS.Timeout>>({});

  // Fetch existing data if updating
  const { data: existingData } = useComment(id || "", {
    enabled: !!id,
  });

  // Choose appropriate schema
  const schema = mode === "create" ? CommentCreateSchema : CommentUpdateSchema;

  // Initialize form with proper defaults
  const form = useForm<FlowCommentCreate | FlowCommentUpdate>({
    ...formOptions,
    resolver: zodResolver(schema),
    defaultValues: {
      ...defaultValues,
      ...(existingData || {}),
    } as FlowCommentCreate | FlowCommentUpdate,
  });

  // Update form when existing data loads, preserving user changes
  useEffect(() => {
    if (existingData && mode === "update") {
      // Extract only scalar fields for update forms
      const updateData: any = {};

      // Copy scalar fields only, skip relations (arrays and objects)
      Object.keys(existingData).forEach((key) => {
        const value = (existingData as any)[key];
        // Include scalar values and nulls, skip arrays and objects (relations)
        if (
          value === null ||
          (typeof value !== "object" && !Array.isArray(value))
        ) {
          updateData[key] = value;
        }
      });

      console.log(
        "[CommentForm] Resetting form with scalar data only:",
        updateData,
      );
      form.reset(updateData as FlowCommentUpdate, {
        keepDirtyValues: true, // Preserve user-modified fields
        keepErrors: true, // Keep validation errors for dirty fields
      });
    }
  }, [existingData, mode, form]);

  // Get appropriate mutation
  const createMutation = useCreateComment({
    onSuccess: (data) => {
      form.reset();
      onSuccess?.(data);
    },
    onError,
  });

  // Only create update mutation if we have a valid ID
  const updateMutation = useUpdateComment(id || "dummy-id-never-used", {
    onSuccess: (data) => {
      onSuccess?.(data);
    },
    onError,
    enabled: !!id, // Only enable if we have a real ID
  });

  const mutation = mode === "update" ? updateMutation : createMutation;

  // Autosave handler for individual fields
  const handleAutosave = useCallback(
    (fieldName: string, value: any) => {
      if (!autosave?.enabled || mode !== "update" || !id) return;

      // Check if this field should be autosaved
      if (autosave.fields && !autosave.fields.includes(fieldName)) return;

      // Clear existing timer for this field
      if (debounceTimers.current[fieldName]) {
        clearTimeout(debounceTimers.current[fieldName]);
      }

      // Set field state to saving after debounce
      setFieldSaveStates((prev) => ({ ...prev, [fieldName]: "idle" }));

      // Create new debounced save
      debounceTimers.current[fieldName] = setTimeout(async () => {
        // Validate the specific field
        const isValid = await form.trigger(fieldName as any);
        if (!isValid) {
          setFieldSaveStates((prev) => ({ ...prev, [fieldName]: "error" }));
          return;
        }

        setFieldSaveStates((prev) => ({ ...prev, [fieldName]: "saving" }));

        try {
          // Create partial update with just this field
          const partialUpdate = { [fieldName]: value } as FlowCommentUpdate;
          await updateMutation.mutateAsync(partialUpdate);

          setFieldSaveStates((prev) => ({ ...prev, [fieldName]: "saved" }));
          autosave.onFieldSave?.(fieldName, value);

          // Reset to idle after 2 seconds
          setTimeout(() => {
            setFieldSaveStates((prev) => ({ ...prev, [fieldName]: "idle" }));
          }, 2000);
        } catch (error) {
          setFieldSaveStates((prev) => ({ ...prev, [fieldName]: "error" }));
          autosave.onFieldError?.(fieldName, error as Error);
        }
      }, autosave.debounceMs || 1000);
    },
    [autosave, mode, form, updateMutation, id],
  );

  // Watch for field changes if autosave is enabled
  useEffect(() => {
    if (!autosave?.enabled || mode !== "update" || !id) return;

    const subscription = form.watch((value, { name }) => {
      if (name) {
        handleAutosave(name, value[name]);
      }
    });

    return () => subscription.unsubscribe();
  }, [form, autosave, mode, handleAutosave]);

  // Submit handler
  const submit = useCallback(
    (data: FlowCommentCreate | FlowCommentUpdate) => {
      console.log("[CommentForm] Submitting " + mode + " form:", data);
      if (mode === "update") {
        return updateMutation.mutate(data as FlowCommentUpdate);
      } else {
        return createMutation.mutate(data as FlowCommentCreate);
      }
    },
    [createMutation, updateMutation, mode],
  );

  // Validation error handler
  const onInvalid = useCallback((errors: any) => {
    console.error("[CommentForm] Validation failed:", errors);
  }, []);

  return {
    form,
    submit: form.handleSubmit(submit, onInvalid),
    isSubmitting: mutation.isPending,
    error: mutation.error,
    isSuccess: mutation.isSuccess,
    mode,
    reset: () => form.reset(),
    // Autosave specific
    fieldSaveStates,
    isAutosaving: Object.values(fieldSaveStates).some(
      (state) => state === "saving",
    ),
    autosaveEnabled: autosave?.enabled || false,
  };
}

export function useCommentQuickForm(id?: string) {
  return useCommentForm({ id });
}

export type CommentFormProps = {
  form: UseFormReturn<FlowCommentCreate | FlowCommentUpdate>;
  onSubmit: () => void;
  isSubmitting: boolean;
  error?: Error | null;
};
