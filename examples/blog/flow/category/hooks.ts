// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-06-09T17:45:48.134Z

import { useAtomValue, useSetAtom } from "jotai";
import { entityAtomFamily, errorAtom } from "./atoms";
import {
	countAtom,
	countByFieldAtomFamily,
	entityBusyFamily,
	entityLoadableFamily,
	hasAnyAtom,
	listByFieldAtomFamily,
	listLoadable,
	loadingAtom,
	pagedAtom,
	searchAtom,
	selectedAtom,
	selectedIdAtom,
} from "./derived";

import { makeRelationHelpers } from "../shared/hooks/relation-helper";
import { makeUseFormHook } from "../shared/hooks/use-form-factory";
import { createAtom, deleteAtom, loadEntityAtom, loadsListAtom, updateAtom, upsertAtom } from "./fx";
import { schemas } from "./schemas";
import type { CreateInput, ModelType, Relationships, UpdateInput } from "./types";

/**
 * Hook for managing the complete categories collection with comprehensive state management.
 *
 * Provides access to the full categories list along with loading states, error handling,
 * and all necessary CRUD operations. This hook manages the global state for categories
 * and automatically handles loading indicators and error states.
 */
export function useCategories() {
	const loadable = useAtomValue(listLoadable);
	const busy = useAtomValue(loadingAtom);
	const count = useAtomValue(countAtom);
	const hasAny = useAtomValue(hasAnyAtom);
	const lastError = useAtomValue(errorAtom);

	const createCategory = useSetAtom(createAtom);
	const updateCategory = useSetAtom(updateAtom);
	const deleteCategory = useSetAtom(deleteAtom);
	const upsertCategory = useSetAtom(upsertAtom);
	const fetchAll = useSetAtom(loadsListAtom);
	const fetchById = useSetAtom(loadEntityAtom);

	return {
		/* data */
		data: loadable.state === "hasData" ? loadable.data : [],
		count,
		hasAny,

		/* meta */
		loading: busy || loadable.state === "loading",
		error: loadable.state === "hasError" ? loadable.error : lastError,

		/* actions */
		createCategory,
		updateCategory,
		deleteCategory,
		upsertCategory,
		fetchAll,
		fetchById,
	};
}

/**
 * Hook for managing a specific category by ID with optimistic updates and error handling.
 *
 * Provides granular control over individual categories, including fetching, updating, and deleting.
 * The hook automatically manages loading states and errors specific to this category instance.
 */
export function useCategory(id: string) {
	const entity = useAtomValue(entityAtomFamily(id));
	const loadable = useAtomValue(entityLoadableFamily(id));
	const isBusy = useAtomValue(entityBusyFamily(id));
	const lastError = useAtomValue(errorAtom);

	const updateCategory = useSetAtom(updateAtom);
	const deleteCategory = useSetAtom(deleteAtom);
	const upsertCategory = useSetAtom(upsertAtom);
	const fetchById = useSetAtom(loadEntityAtom);

	const update = (data: UpdateInput) => updateCategory({ id, data });
	const remove = () => deleteCategory(id);
	const upsert = (payload: { create: CreateInput; update: UpdateInput }) => upsertCategory({ id }, payload);

	const relations = makeRelationHelpers<Relationships>(id, updateCategory);

	return {
		/* data */
		data: entity || null,
		loading: isBusy || loadable.state === "loading",
		error: loadable.state === "hasError" ? loadable.error : lastError,

		/* entity actions */
		updateCategory: update,
		deleteCategory: remove,
		upsertCategory: upsert,
		fetchById: () => fetchById({ id }),

		/* relation helpers */
		relations,
	};
}

export const useCategoryForm = makeUseFormHook<ModelType, CreateInput, UpdateInput>({
	create: schemas.create,
	update: schemas.update,
});
