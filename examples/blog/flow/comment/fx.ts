// This file is auto-generated by Next Prisma Flow Generator.
// Do not edit this file manually as it will be overwritten.
// Generated at: 2025-08-01T17:20:41.602Z

import { atom } from "jotai";
import { unwrap } from "../shared/actions/unwrap";
import * as actions from "./actions";
import { entitiesAtom, errorAtom, pendingPatchesAtom } from "./atoms";
import type { CreateInput, ModelType, Options, UpdateInput, WhereInput, WhereUniqueInput } from "./types";

/* ---------- create ---------- */
export const createAtom = atom(null, async (_get, set, data: CreateInput) => {
	const tempId = crypto.randomUUID();
	set(entitiesAtom, (m) => ({ ...m, [tempId]: { ...data, id: tempId } as unknown as ModelType }));
	set(pendingPatchesAtom, (p) => ({ ...p, [tempId]: { type: "create" } }));

	try {
		const created = unwrap(await actions.create(data));
		set(entitiesAtom, (m) => {
			const { [tempId]: _, ...rest } = m;
			return { ...rest, [created.id]: created };
		});
	} catch (err: any) {
		set(errorAtom, err);
		// rollback
		set(entitiesAtom, (m) => {
			const { [tempId]: _, ...rest } = m;
			return rest;
		});
	} finally {
		set(pendingPatchesAtom, (p) => {
			const { [tempId]: _, ...rest } = p;
			return rest;
		});
	}
});

/* ---------- update ---------- */
export const updateAtom = atom(null, async (get, set, { id, data }: { id: string; data: UpdateInput }) => {
	set(pendingPatchesAtom, (p) => ({ ...p, [id]: { type: "update" } }));
	const prev = get(entitiesAtom)[id] ?? ({} as ModelType);
	set(entitiesAtom, (m) => ({ ...m, [id]: { ...prev, ...data } as unknown as ModelType }));

	try {
		const updated = unwrap(await actions.update({ id }, data));
		set(entitiesAtom, (m) => ({ ...m, [id]: updated }));
	} catch (err: any) {
		set(errorAtom, err);
		// rollback
		if (prev) {
			set(entitiesAtom, (m) => ({ ...m, [id]: prev }));
		}
	} finally {
		set(pendingPatchesAtom, (p) => {
			const { [id]: _, ...rest } = p;
			return rest;
		});
	}
});

/* ---------- upsert ---------- */
export const upsertAtom = atom(
	null,
	async (get, set, selector: WhereUniqueInput, payload: { create: CreateInput; update: UpdateInput }) => {
		const tempId = selector.id ?? crypto.randomUUID();
		let committedId = tempId;
		const prev = get(entitiesAtom)[tempId] ?? ({} as ModelType);

		/* optimistic */
		set(pendingPatchesAtom, (p) => ({ ...p, [tempId]: { type: "upsert" } }));
		set(entitiesAtom, (m) => ({ ...m, [tempId]: { ...prev, ...payload.update } as unknown as ModelType }));

		try {
			const updated = unwrap(await actions.upsert(selector, payload.create, payload.update));
			committedId = updated.id;

			set(entitiesAtom, (m) =>
				committedId === tempId
					? { ...m, [tempId]: updated }
					: { ...Object.fromEntries(Object.entries(m).filter(([k]) => k !== tempId)), [committedId]: updated },
			);
		} catch (err: any) {
			set(errorAtom, err);
			set(entitiesAtom, (m) => ({ ...m, [committedId]: prev }));
		} finally {
			set(pendingPatchesAtom, (p) => {
				const { [tempId]: _, [committedId]: __, ...rest } = p;
				return rest;
			});
		}
	},
);

/* ---------- delete ---------- */
export const deleteAtom = atom(null, async (get, set, id: string) => {
	set(pendingPatchesAtom, (p) => ({ ...p, [id]: { type: "delete" } }));
	const prev = get(entitiesAtom)[id];
	set(entitiesAtom, (m) => {
		const { [id]: _, ...rest } = m;
		return rest;
	});

	try {
		unwrap(await actions.remove({ id }));
	} catch (err: any) {
		set(errorAtom, err);
		// rollback
		if (prev) {
			set(entitiesAtom, (m) => ({ ...m, [id]: prev }));
		}
	} finally {
		set(pendingPatchesAtom, (p) => {
			const { [id]: _, ...rest } = p;
			return rest;
		});
	}
});

/* ---------- load helpers ---------- */
export const loadsListAtom = atom(null, async (_get, set, filter: WhereInput = {}, options: Options = {}) => {
	try {
		const list = unwrap(await actions.findMany(filter, options));
		const map = list.reduce<Record<string, ModelType>>((acc, p) => {
			acc[p.id] = p;
			return acc;
		}, {});
		set(entitiesAtom, map);
	} catch (err: any) {
		set(errorAtom, err);
	}
});

export const loadEntityAtom = atom(null, async (_get, set, selector: WhereUniqueInput) => {
	try {
		const single = unwrap(await actions.findUnique(selector));
		if (single) set(entitiesAtom, (m) => ({ ...m, [single.id]: single }));
	} catch (err: any) {
		set(errorAtom, err);
	}
});
