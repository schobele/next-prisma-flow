import { join } from "node:path";
import type { DMMF } from "@prisma/generator-helper";
import type { FlowConfig } from "../../../config";
import { write } from "../../fs";
import { header, imp, impType } from "../../strings";

export async function emitClientComposables({
  modelDir,
  model,
  cfg,
}: {
  modelDir: string;
  model: DMMF.Model;
  cfg: FlowConfig;
}) {
  const idField = model.fields.find((f) => f.isId);
  const idType = idField?.type === "String" ? "string" : "number";

  const content = [];
  content.push(header("client/composables.ts"));
  content.push(`"use client";`);
  content.push(``);
  content.push(imp("react", ["useState", "useCallback", "useRef", "useEffect"]));
  content.push(`import { type UseFormReturn, type Path, type PathValue, useWatch } from "react-hook-form";`);
  content.push(`import { type UseMutationResult } from "@tanstack/react-query";`);
  content.push(impType(`../types/schemas`, [`Flow${model.name}`, `Flow${model.name}Create`, `Flow${model.name}Update`]));
  content.push(``);

  // Autosave composable
  content.push(`// Autosave functionality for forms`);
  content.push(`export function use${model.name}FormAutosave<T extends Flow${model.name}Create | Flow${model.name}Update>(`);
  content.push(`  form: UseFormReturn<T>,`);
  content.push(`  mutation: UseMutationResult<Flow${model.name}, Error, any>,`);
  content.push(`  options?: {`);
  content.push(`    enabled?: boolean;`);
  content.push(`    debounceMs?: number;`);
  content.push(`    fields?: string[];`);
  content.push(`    onFieldSave?: (field: string, value: any) => void;`);
  content.push(`    onFieldError?: (field: string, error: Error) => void;`);
  content.push(`  }`);
  content.push(`) {`);
  content.push(`  const { enabled = true, debounceMs = 1000, fields, onFieldSave, onFieldError } = options || {};`);
  content.push(`  const [fieldSaveStates, setFieldSaveStates] = useState<Record<string, 'idle' | 'saving' | 'saved' | 'error'>>({});`);
  content.push(`  const debounceTimers = useRef<Record<string, NodeJS.Timeout>>({});`);
  content.push(`  const lastSavedValues = useRef<Record<string, any>>({});`);
  content.push(`  const isSystemUpdate = useRef(false);`);
  content.push(`  const isSaving = useRef<Set<string>>(new Set());`);
  content.push(`  const saveFieldRef = useRef<(fieldName: string, value: any) => void>();`);
  content.push(`  `);
  content.push(`  const saveField = useCallback(async (fieldName: string, value: any) => {`);
  content.push(`    console.log('[${model.name} Autosave] saveField called:', { fieldName, value, enabled, isSystemUpdate: isSystemUpdate.current });`);
  content.push(`    if (!enabled) return;`);
  content.push(`    if (fields && !fields.includes(fieldName)) return;`);
  content.push(`    if (isSystemUpdate.current) return;`);
  content.push(`    if (isSaving.current.has(fieldName)) return;`);
  content.push(`    `);
  content.push(`    // Check if value actually changed from last saved`);
  content.push(`    if (lastSavedValues.current[fieldName] === value) {`);
  content.push(`      console.log('[${model.name} Autosave] Value unchanged, skipping save');`);
  content.push(`      return;`);
  content.push(`    }`);
  content.push(`    `);
  content.push(`    // Clear existing timer`);
  content.push(`    if (debounceTimers.current[fieldName]) {`);
  content.push(`      clearTimeout(debounceTimers.current[fieldName]);`);
  content.push(`    }`);
  content.push(`    `);
  content.push(`    console.log('[${model.name} Autosave] Setting debounce timer for', fieldName, 'with delay', debounceMs);`);
  content.push(`    debounceTimers.current[fieldName] = setTimeout(async () => {`);
  content.push(`      console.log('[${model.name} Autosave] Debounce timer fired for', fieldName);`);
  content.push(`      // Double-check value hasn't changed while debouncing`);
  content.push(`      const currentValue = form.getValues(fieldName as Path<T>);`);
  content.push(`      if (lastSavedValues.current[fieldName] === currentValue) {`);
  content.push(`        console.log('[${model.name} Autosave] Value unchanged after debounce, skipping');`);
  content.push(`        return;`);
  content.push(`      }`);
  content.push(`      `);
  content.push(`      const isValid = await form.trigger(fieldName as Path<T>);`);
  content.push(`      if (!isValid) {`);
  content.push(`        console.log('[${model.name} Autosave] Field validation failed');`);
  content.push(`        setFieldSaveStates(prev => ({ ...prev, [fieldName]: 'error' }));`);
  content.push(`        return;`);
  content.push(`      }`);
  content.push(`      `);
  content.push(`      isSaving.current.add(fieldName);`);
  content.push(`      setFieldSaveStates(prev => ({ ...prev, [fieldName]: 'saving' }));`);
  content.push(`      `);
  content.push(`      try {`);
  content.push(`        console.log('[${model.name} Autosave] Calling mutation with:', { [fieldName]: currentValue });`);
  content.push(`        // Temporarily disable autosave during mutation`);
  content.push(`        isSystemUpdate.current = true;`);
  content.push(`        await mutation.mutateAsync({ [fieldName]: currentValue } as any);`);
  content.push(`        console.log('[${model.name} Autosave] Mutation successful');`);
  content.push(`        lastSavedValues.current[fieldName] = currentValue;`);
  content.push(`        setFieldSaveStates(prev => ({ ...prev, [fieldName]: 'saved' }));`);
  content.push(`        onFieldSave?.(fieldName, currentValue);`);
  content.push(`        `);
  content.push(`        setTimeout(() => {`);
  content.push(`          setFieldSaveStates(prev => ({ ...prev, [fieldName]: 'idle' }));`);
  content.push(`        }, 2000);`);
  content.push(`      } catch (error) {`);
  content.push(`        console.error('[${model.name} Autosave] Mutation failed:', error);`);
  content.push(`        setFieldSaveStates(prev => ({ ...prev, [fieldName]: 'error' }));`);
  content.push(`        onFieldError?.(fieldName, error as Error);`);
  content.push(`      } finally {`);
  content.push(`        isSaving.current.delete(fieldName);`);
  content.push(`        // Re-enable autosave after a small delay to prevent immediate retrigger`);
  content.push(`        setTimeout(() => {`);
  content.push(`          isSystemUpdate.current = false;`);
  content.push(`        }, 100);`);
  content.push(`      }`);
  content.push(`    }, debounceMs);`);
  content.push(`  }, [enabled, fields, form, mutation, debounceMs, onFieldSave, onFieldError]);`);
  content.push(`  `);
  content.push(`  // Store saveField in ref to prevent effect re-runs`);
  content.push(`  useEffect(() => {`);
  content.push(`    saveFieldRef.current = saveField;`);
  content.push(`  }, [saveField]);`);
  content.push(`  `);
  content.push(`  // Initialize last saved values`);
  content.push(`  useEffect(() => {`);
  content.push(`    if (enabled) {`);
  content.push(`      const formValues = form.getValues();`);
  content.push(`      Object.keys(formValues).forEach(key => {`);
  content.push(`        lastSavedValues.current[key] = (formValues as any)[key];`);
  content.push(`      });`);
  content.push(`    }`);
  content.push(`  }, [enabled, form]);`);
  content.push(`  `);
  content.push(`  // Watch for changes`);
  content.push(`  useEffect(() => {`);
  content.push(`    console.log('[${model.name} Autosave] Setting up watch subscription, enabled:', enabled);`);
  content.push(`    if (!enabled) return;`);
  content.push(`    `);
  content.push(`    const subscription = form.watch((value, { name, type }) => {`);
  content.push(`      console.log('[${model.name} Autosave] Form change detected:', { name, type, isSystemUpdate: isSystemUpdate.current });`);
  content.push(`      // Only trigger on actual field changes, not on form reset`);
  content.push(`      if (name && type === 'change' && !isSystemUpdate.current) {`);
  content.push(`        const fieldValue = (value as any)[name];`);
  content.push(`        console.log('[${model.name} Autosave] Triggering saveField for:', name, 'with value:', fieldValue);`);
  content.push(`        // Use ref to avoid stale closure`);
  content.push(`        saveFieldRef.current?.(name, fieldValue);`);
  content.push(`      }`);
  content.push(`    });`);
  content.push(`    `);
  content.push(`    return () => {`);
  content.push(`      console.log('[${model.name} Autosave] Cleaning up watch subscription');`);
  content.push(`      subscription.unsubscribe();`);
  content.push(`      // Clear all timers on unmount`);
  content.push(`      Object.values(debounceTimers.current).forEach(timer => clearTimeout(timer));`);
  content.push(`    };`);
  content.push(`  }, [enabled, form]); // Keep form as dep but not saveField`);
  content.push(`  `);
  content.push(`  // Pause autosave during bulk updates`);
  content.push(`  const pauseAutosave = useCallback((callback: () => void) => {`);
  content.push(`    isSystemUpdate.current = true;`);
  content.push(`    callback();`);
  content.push(`    setTimeout(() => {`);
  content.push(`      isSystemUpdate.current = false;`);
  content.push(`      // Update last saved values after bulk update`);
  content.push(`      const formValues = form.getValues();`);
  content.push(`      Object.keys(formValues).forEach(key => {`);
  content.push(`        lastSavedValues.current[key] = (formValues as any)[key];`);
  content.push(`      });`);
  content.push(`    }, 100);`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  return {`);
  content.push(`    fieldSaveStates,`);
  content.push(`    isAutosaving: Object.values(fieldSaveStates).some(state => state === 'saving'),`);
  content.push(`    clearSaveStates: () => setFieldSaveStates({}),`);
  content.push(`    pauseAutosave`);
  content.push(`  };`);
  content.push(`}`);
  content.push(``);

  // Field tracking composable
  content.push(`// Field tracking and state management`);
  content.push(`export function use${model.name}FormFieldTracking<T extends Flow${model.name}Create | Flow${model.name}Update>(`);
  content.push(`  form: UseFormReturn<T>,`);
  content.push(`  original?: Flow${model.name}`);
  content.push(`) {`);
  content.push(`  const getFieldState = useCallback((name: Path<T>) => {`);
  content.push(`    const fieldState = form.getFieldState(name);`);
  content.push(`    const currentValue = form.getValues(name);`);
  content.push(`    const originalValue = original?.[name as keyof Flow${model.name}];`);
  content.push(`    `);
  content.push(`    return {`);
  content.push(`      isDirty: fieldState.isDirty,`);
  content.push(`      isTouched: fieldState.isTouched,`);
  content.push(`      error: fieldState.error,`);
  content.push(`      current: currentValue,`);
  content.push(`      original: originalValue,`);
  content.push(`      hasChanged: original ? currentValue !== originalValue : fieldState.isDirty`);
  content.push(`    };`);
  content.push(`  }, [form, original]);`);
  content.push(`  `);
  content.push(`  const getDirtyFields = useCallback(() => {`);
  content.push(`    const dirtyFields: Array<{ field: string; original?: any; current: any }> = [];`);
  content.push(`    `);
  content.push(`    Object.keys(form.formState.dirtyFields).forEach(key => {`);
  content.push(`      if ((form.formState.dirtyFields as any)[key]) {`);
  content.push(`        dirtyFields.push({`);
  content.push(`          field: key,`);
  content.push(`          original: original?.[key as keyof Flow${model.name}],`);
  content.push(`          current: form.getValues(key as Path<T>)`);
  content.push(`        });`);
  content.push(`      }`);
  content.push(`    });`);
  content.push(`    `);
  content.push(`    return dirtyFields;`);
  content.push(`  }, [form, original]);`);
  content.push(`  `);
  content.push(`  const resetField = useCallback((name: Path<T>) => {`);
  content.push(`    if (original) {`);
  content.push(`      form.setValue(name, (original as any)[name]);`);
  content.push(`    } else {`);
  content.push(`      form.resetField(name);`);
  content.push(`    }`);
  content.push(`    form.clearErrors(name);`);
  content.push(`  }, [form, original]);`);
  content.push(`  `);
  content.push(`  return {`);
  content.push(`    getFieldState,`);
  content.push(`    getDirtyFields,`);
  content.push(`    resetField,`);
  content.push(`    hasChanges: form.formState.isDirty`);
  content.push(`  };`);
  content.push(`}`);
  content.push(``);

  // History tracking composable
  content.push(`// Form history for undo/redo`);
  content.push(`export function use${model.name}FormHistory<T extends Flow${model.name}Create | Flow${model.name}Update>(`);
  content.push(`  form: UseFormReturn<T>,`);
  content.push(`  options?: {`);
  content.push(`    maxHistorySize?: number;`);
  content.push(`  }`);
  content.push(`) {`);
  content.push(`  const { maxHistorySize = 50 } = options || {};`);
  content.push(`  const [history, setHistory] = useState<Array<{ field: string; oldValue: any; newValue: any; timestamp: number }>>([]);`);
  content.push(`  const [historyIndex, setHistoryIndex] = useState(-1);`);
  content.push(`  const previousValues = useRef<Record<string, any>>({});`);
  content.push(`  `);
  content.push(`  // Track changes`);
  content.push(`  useEffect(() => {`);
  content.push(`    const subscription = form.watch((value, { name, type }) => {`);
  content.push(`      if (name && type === 'change') {`);
  content.push(`        const oldValue = previousValues.current[name];`);
  content.push(`        const newValue = (value as any)[name];`);
  content.push(`        `);
  content.push(`        if (oldValue !== newValue) {`);
  content.push(`          const change = { field: name, oldValue, newValue, timestamp: Date.now() };`);
  content.push(`          `);
  content.push(`          setHistory(prev => {`);
  content.push(`            const newHistory = [...prev.slice(0, historyIndex + 1), change];`);
  content.push(`            return newHistory.slice(-maxHistorySize);`);
  content.push(`          });`);
  content.push(`          `);
  content.push(`          setHistoryIndex(prev => Math.min(prev + 1, maxHistorySize - 1));`);
  content.push(`          previousValues.current[name] = newValue;`);
  content.push(`        }`);
  content.push(`      }`);
  content.push(`    });`);
  content.push(`    `);
  content.push(`    return () => subscription.unsubscribe();`);
  content.push(`  }, [form, historyIndex, maxHistorySize]);`);
  content.push(`  `);
  content.push(`  const undo = useCallback(() => {`);
  content.push(`    if (historyIndex >= 0 && history[historyIndex]) {`);
  content.push(`      const change = history[historyIndex];`);
  content.push(`      form.setValue(change.field as Path<T>, change.oldValue);`);
  content.push(`      previousValues.current[change.field] = change.oldValue;`);
  content.push(`      setHistoryIndex(prev => prev - 1);`);
  content.push(`    }`);
  content.push(`  }, [history, historyIndex, form]);`);
  content.push(`  `);
  content.push(`  const redo = useCallback(() => {`);
  content.push(`    if (historyIndex < history.length - 1) {`);
  content.push(`      const change = history[historyIndex + 1];`);
  content.push(`      form.setValue(change.field as Path<T>, change.newValue);`);
  content.push(`      previousValues.current[change.field] = change.newValue;`);
  content.push(`      setHistoryIndex(prev => prev + 1);`);
  content.push(`    }`);
  content.push(`  }, [history, historyIndex, form]);`);
  content.push(`  `);
  content.push(`  const clearHistory = useCallback(() => {`);
  content.push(`    setHistory([]);`);
  content.push(`    setHistoryIndex(-1);`);
  content.push(`    previousValues.current = {};`);
  content.push(`  }, []);`);
  content.push(`  `);
  content.push(`  return {`);
  content.push(`    history,`);
  content.push(`    canUndo: historyIndex >= 0,`);
  content.push(`    canRedo: historyIndex < history.length - 1,`);
  content.push(`    undo,`);
  content.push(`    redo,`);
  content.push(`    clearHistory`);
  content.push(`  };`);
  content.push(`}`);
  content.push(``);

  // Field-level hook
  content.push(`// Individual field hook for granular control`);
  content.push(`export function use${model.name}FieldDirect<T extends Flow${model.name}Create | Flow${model.name}Update>(`);
  content.push(`  name: Path<T>,`);
  content.push(`  form: UseFormReturn<T>`);
  content.push(`) {`);
  content.push(`  const value = useWatch({ control: form.control, name });`);
  content.push(`  const fieldState = form.getFieldState(name);`);
  content.push(`  `);
  content.push(`  const setValue = useCallback(`);
  content.push(`    (value: PathValue<T, typeof name>) => {`);
  content.push(`      form.setValue(name, value);`);
  content.push(`    },`);
  content.push(`    [form, name]`);
  content.push(`  );`);
  content.push(`  `);
  content.push(`  const reset = useCallback(() => {`);
  content.push(`    form.resetField(name);`);
  content.push(`  }, [form, name]);`);
  content.push(`  `);
  content.push(`  const validate = useCallback(() => {`);
  content.push(`    return form.trigger(name);`);
  content.push(`  }, [form, name]);`);
  content.push(`  `);
  content.push(`  return {`);
  content.push(`    value,`);
  content.push(`    error: fieldState.error,`);
  content.push(`    isDirty: fieldState.isDirty,`);
  content.push(`    isTouched: fieldState.isTouched,`);
  content.push(`    isInvalid: !!fieldState.error,`);
  content.push(`    setValue,`);
  content.push(`    reset,`);
  content.push(`    validate`);
  content.push(`  };`);
  content.push(`}`);

  const clientDir = join(modelDir, "client");
  await write(join(clientDir, "composables.ts"), content.join("\n"));
}