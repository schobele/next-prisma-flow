import { join } from "node:path";
import type { DMMF } from "@prisma/generator-helper";
import type { FlowConfig } from "../../../config";
import { write } from "../../fs";
import { header, imp, impType } from "../../strings";

export async function emitClientForms({
  modelDir,
  model,
  cfg,
}: {
  modelDir: string;
  model: DMMF.Model;
  cfg: FlowConfig;
}) {
  const idField = model.fields.find((f) => f.isId);
  const idType = idField?.type === "String" ? "string" : "number";

  const content = [];
  content.push(header("client/forms.ts"));
  content.push(`"use client";`);
  content.push(``);
  content.push(imp("react", ["useCallback", "useEffect", "useState", "useRef"]));
  content.push(`import { useForm, type UseFormReturn, type UseFormProps } from "react-hook-form";`);
  content.push(imp("@hookform/resolvers/zod", ["zodResolver"]));
  content.push(imp(`../types/schemas`, [`${model.name}CreateSchema`, `${model.name}UpdateSchema`]));
  content.push(impType(`../types/schemas`, [`Flow${model.name}`, `Flow${model.name}Create`, `Flow${model.name}Update`]));
  content.push(imp(`./hooks`, [`use${model.name}`, `useCreate${model.name}`, `useUpdate${model.name}`]));
  content.push(``);

  // Autosave configuration type
  content.push(`export type ${model.name}AutosaveConfig = {`);
  content.push(`  enabled: boolean;`);
  content.push(`  debounceMs?: number;`);
  content.push(`  fields?: string[];`);
  content.push(`  onFieldSave?: (field: string, value: any) => void;`);
  content.push(`  onFieldError?: (field: string, error: Error) => void;`);
  content.push(`};`);
  content.push(``);

  // Form options type
  content.push(`export type ${model.name}FormOptions = {`);
  content.push(`  id?: ${idType};`);
  content.push(`  defaultValues?: Partial<Flow${model.name}Create> | Partial<Flow${model.name}Update>;`);
  content.push(`  onSuccess?: (data: Flow${model.name}) => void;`);
  content.push(`  onError?: (error: Error) => void;`);
  content.push(`  formOptions?: Omit<UseFormProps<Flow${model.name}Create | Flow${model.name}Update>, 'resolver' | 'defaultValues'>;`);
  content.push(`  autosave?: ${model.name}AutosaveConfig;`);
  content.push(`};`);
  content.push(``);

  // Main form hook
  content.push(`export function use${model.name}Form(options?: ${model.name}FormOptions) {`);
  content.push(`  const { id, defaultValues, onSuccess, onError, formOptions, autosave } = options || {};`);
  content.push(`  `);
  content.push(`  // Smart mode detection`);
  content.push(`  const mode = id ? 'update' : 'create';`);
  content.push(`  `);
  content.push(`  // Autosave state`);
  content.push(`  const [fieldSaveStates, setFieldSaveStates] = useState<Record<string, 'idle' | 'saving' | 'saved' | 'error'>>({});`);
  content.push(`  const debounceTimers = useRef<Record<string, NodeJS.Timeout>>({});`);
  content.push(`  `);
  content.push(`  // Fetch existing data if updating`);
  content.push(`  const { data: existingData } = use${model.name}(id || '', {`);
  content.push(`    enabled: !!id`);
  content.push(`  });`);
  content.push(`  `);
  content.push(`  // Choose appropriate schema`);
  content.push(`  const schema = mode === 'create' ? ${model.name}CreateSchema : ${model.name}UpdateSchema;`);
  content.push(`  `);
  content.push(`  // Initialize form with proper defaults`);
  content.push(`  const form = useForm<Flow${model.name}Create | Flow${model.name}Update>({`);
  content.push(`    ...formOptions,`);
  content.push(`    resolver: zodResolver(schema),`);
  content.push(`    defaultValues: {`);
  content.push(`      ...defaultValues,`);
  content.push(`      ...(existingData || {})`);
  content.push(`    } as Flow${model.name}Create | Flow${model.name}Update`);
  content.push(`  });`);
  content.push(`  `);
  content.push(`  // Update form when existing data loads, preserving user changes`);
  content.push(`  useEffect(() => {`);
  content.push(`    if (existingData && mode === 'update') {`);
  content.push(`      // Extract only scalar fields for update forms`);
  content.push(`      const updateData: any = {};`);
  content.push(`      `);
  content.push(`      // Copy scalar fields only, skip relations (arrays and objects)`);
  content.push(`      Object.keys(existingData).forEach(key => {`);
  content.push(`        const value = (existingData as any)[key];`);
  content.push(`        // Include scalar values and nulls, skip arrays and objects (relations)`);
  content.push(`        if (value === null || (typeof value !== 'object' && !Array.isArray(value))) {`);
  content.push(`          updateData[key] = value;`);
  content.push(`        }`);
  content.push(`      });`);
  content.push(`      `);
  content.push(`      console.log('[${model.name}Form] Resetting form with scalar data only:', updateData);`);
  content.push(`      form.reset(updateData as Flow${model.name}Update, {`);
  content.push(`        keepDirtyValues: true,  // Preserve user-modified fields`);
  content.push(`        keepErrors: true         // Keep validation errors for dirty fields`);
  content.push(`      });`);
  content.push(`    }`);
  content.push(`  }, [existingData, mode, form]);`);
  content.push(`  `);
  content.push(`  // Get appropriate mutation`);
  content.push(`  const createMutation = useCreate${model.name}({`);
  content.push(`    onSuccess: (data) => {`);
  content.push(`      form.reset();`);
  content.push(`      onSuccess?.(data);`);
  content.push(`    },`);
  content.push(`    onError`);
  content.push(`  });`);
  content.push(`  `);
  content.push(`  // Only create update mutation if we have a valid ID`);
  content.push(`  const updateMutation = useUpdate${model.name}(id || 'dummy-id-never-used', {`);
  content.push(`    onSuccess: (data) => {`);
  content.push(`      onSuccess?.(data);`);
  content.push(`    },`);
  content.push(`    onError,`);
  content.push(`    enabled: !!id  // Only enable if we have a real ID`);
  content.push(`  });`);
  content.push(`  `);
  content.push(`  const mutation = mode === 'update' ? updateMutation : createMutation;`);
  content.push(`  `);
  content.push(`  // Autosave handler for individual fields`);
  content.push(`  const handleAutosave = useCallback((fieldName: string, value: any) => {`);
  content.push(`    if (!autosave?.enabled || mode !== 'update' || !id) return;`);
  content.push(`    `);
  content.push(`    // Check if this field should be autosaved`);
  content.push(`    if (autosave.fields && !autosave.fields.includes(fieldName)) return;`);
  content.push(`    `);
  content.push(`    // Clear existing timer for this field`);
  content.push(`    if (debounceTimers.current[fieldName]) {`);
  content.push(`      clearTimeout(debounceTimers.current[fieldName]);`);
  content.push(`    }`);
  content.push(`    `);
  content.push(`    // Set field state to saving after debounce`);
  content.push(`    setFieldSaveStates(prev => ({ ...prev, [fieldName]: 'idle' }));`);
  content.push(`    `);
  content.push(`    // Create new debounced save`);
  content.push(`    debounceTimers.current[fieldName] = setTimeout(async () => {`);
  content.push(`      // Validate the specific field`);
  content.push(`      const isValid = await form.trigger(fieldName as any);`);
  content.push(`      if (!isValid) {`);
  content.push(`        setFieldSaveStates(prev => ({ ...prev, [fieldName]: 'error' }));`);
  content.push(`        return;`);
  content.push(`      }`);
  content.push(`      `);
  content.push(`      setFieldSaveStates(prev => ({ ...prev, [fieldName]: 'saving' }));`);
  content.push(`      `);
  content.push(`      try {`);
  content.push(`        // Create partial update with just this field`);
  content.push(`        const partialUpdate = { [fieldName]: value } as Flow${model.name}Update;`);
  content.push(`        await updateMutation.mutateAsync(partialUpdate);`);
  content.push(`        `);
  content.push(`        setFieldSaveStates(prev => ({ ...prev, [fieldName]: 'saved' }));`);
  content.push(`        autosave.onFieldSave?.(fieldName, value);`);
  content.push(`        `);
  content.push(`        // Reset to idle after 2 seconds`);
  content.push(`        setTimeout(() => {`);
  content.push(`          setFieldSaveStates(prev => ({ ...prev, [fieldName]: 'idle' }));`);
  content.push(`        }, 2000);`);
  content.push(`      } catch (error) {`);
  content.push(`        setFieldSaveStates(prev => ({ ...prev, [fieldName]: 'error' }));`);
  content.push(`        autosave.onFieldError?.(fieldName, error as Error);`);
  content.push(`      }`);
  content.push(`    }, autosave.debounceMs || 1000);`);
  content.push(`  }, [autosave, mode, form, updateMutation, id]);`);
  content.push(`  `);
  content.push(`  // Watch for field changes if autosave is enabled`);
  content.push(`  useEffect(() => {`);
  content.push(`    if (!autosave?.enabled || mode !== 'update' || !id) return;`);
  content.push(`    `);
  content.push(`    const subscription = form.watch((value, { name }) => {`);
  content.push(`      if (name) {`);
  content.push(`        handleAutosave(name, value[name]);`);
  content.push(`      }`);
  content.push(`    });`);
  content.push(`    `);
  content.push(`    return () => subscription.unsubscribe();`);
  content.push(`  }, [form, autosave, mode, handleAutosave]);`);
  content.push(`  `);
  content.push(`  // Submit handler`);
  content.push(`  const submit = useCallback(`);
  content.push(`    (data: Flow${model.name}Create | Flow${model.name}Update) => {`);
  content.push(`      console.log('[${model.name}Form] Submitting ' + mode + ' form:', data);`);
  content.push(`      if (mode === 'update') {`);
  content.push(`        return updateMutation.mutate(data as Flow${model.name}Update);`);
  content.push(`      } else {`);
  content.push(`        return createMutation.mutate(data as Flow${model.name}Create);`);
  content.push(`      }`);
  content.push(`    },`);
  content.push(`    [createMutation, updateMutation, mode]`);
  content.push(`  );`);
  content.push(`  `);
  content.push(`  // Validation error handler`);
  content.push(`  const onInvalid = useCallback((errors: any) => {`);
  content.push(`    console.error('[${model.name}Form] Validation failed:', errors);`);
  content.push(`  }, []);`);
  content.push(`  `);
  content.push(`  return {`);
  content.push(`    form,`);
  content.push(`    submit: form.handleSubmit(submit, onInvalid),`);
  content.push(`    isSubmitting: mutation.isPending,`);
  content.push(`    error: mutation.error,`);
  content.push(`    isSuccess: mutation.isSuccess,`);
  content.push(`    mode,`);
  content.push(`    reset: () => form.reset(),`);
  content.push(`    // Autosave specific`);
  content.push(`    fieldSaveStates,`);
  content.push(`    isAutosaving: Object.values(fieldSaveStates).some(state => state === 'saving'),`);
  content.push(`    autosaveEnabled: autosave?.enabled || false`);
  content.push(`  };`);
  content.push(`}`);
  content.push(``);

  // Quick form hook for simple use cases
  content.push(`export function use${model.name}QuickForm(id?: ${idType}) {`);
  content.push(`  return use${model.name}Form({ id });`);
  content.push(`}`);
  content.push(``);

  // Form component type helper
  content.push(`export type ${model.name}FormProps = {`);
  content.push(`  form: UseFormReturn<Flow${model.name}Create | Flow${model.name}Update>;`);
  content.push(`  onSubmit: () => void;`);
  content.push(`  isSubmitting: boolean;`);
  content.push(`  error?: Error | null;`);
  content.push(`};`);

  const clientDir = join(modelDir, "client");
  await write(join(clientDir, "forms.ts"), content.join("\n"));
}