import { join } from "node:path";
import type { DMMF } from "@prisma/generator-helper";
import type { FlowConfig } from "../../../config";
import { write } from "../../fs";
import { header, imp, impType } from "../../strings";

export async function emitClientForms({
  modelDir,
  model,
  cfg,
}: {
  modelDir: string;
  model: DMMF.Model;
  cfg: FlowConfig;
}) {
  const idField = model.fields.find((f) => f.isId);
  const idType = idField?.type === "String" ? "string" : "number";

  const content = [];
  content.push(header("client/forms.ts"));
  content.push(`"use client";`);
  content.push(``);
  content.push(imp("react", ["useCallback", "useEffect", "useState", "useRef"]));
  content.push(`import { useForm, type UseFormReturn, type UseFormProps, type Path, type PathValue, type FieldErrors } from "react-hook-form";`);
  content.push(imp("@hookform/resolvers/zod", ["zodResolver"]));
  content.push(imp(`../types/schemas`, [`${model.name}CreateSchema`, `${model.name}UpdateSchema`]));
  content.push(impType(`../types/schemas`, [`Flow${model.name}`, `Flow${model.name}Create`, `Flow${model.name}Update`]));
  content.push(imp(`./hooks`, [`use${model.name}`, `useCreate${model.name}`, `useUpdate${model.name}`]));
  content.push(imp(`./composables`, [`use${model.name}FormAutosave`, `use${model.name}FormFieldTracking`, `use${model.name}FormHistory`]));
  content.push(``);

  // Field state type
  content.push(`export type ${model.name}FieldState = {`);
  content.push(`  isDirty: boolean;`);
  content.push(`  isTouched: boolean;`);
  content.push(`  error?: any;`);
  content.push(`  current: any;`);
  content.push(`  original?: any;`);
  content.push(`  hasChanged?: boolean;`);
  content.push(`};`);
  content.push(``);

  // Dirty field type
  content.push(`export type ${model.name}DirtyField = {`);
  content.push(`  field: string;`);
  content.push(`  original?: any;`);
  content.push(`  current: any;`);
  content.push(`};`);
  content.push(``);


  // Feature configuration types
  content.push(`export type ${model.name}AutosaveConfig = {`);
  content.push(`  enabled: boolean;`);
  content.push(`  debounceMs?: number;`);
  content.push(`  fields?: string[];`);
  content.push(`  onFieldSave?: (field: string, value: any) => void;`);
  content.push(`  onFieldError?: (field: string, error: Error) => void;`);
  content.push(`};`);
  content.push(``);
  content.push(`export type ${model.name}FormFeatures = {`);
  content.push(`  autosave?: ${model.name}AutosaveConfig | boolean;`);
  content.push(`  tracking?: boolean;`);
  content.push(`  history?: {`);
  content.push(`    enabled: boolean;`);
  content.push(`    maxHistorySize?: number;`);
  content.push(`  } | boolean;`);
  content.push(`};`);
  content.push(``);
  content.push(`// Create form options`);
  content.push(`export type ${model.name}CreateFormOptions = {`);
  content.push(`  defaultValues?: Partial<Flow${model.name}Create>;`);
  content.push(`  onSuccess?: (data: Flow${model.name}) => void;`);
  content.push(`  onError?: (error: Error) => void;`);
  content.push(`  formOptions?: Omit<UseFormProps<Flow${model.name}Create>, 'resolver' | 'defaultValues'>;`);
  content.push(`  features?: ${model.name}FormFeatures;`);
  content.push(`};`);
  content.push(``);

  // Update form options
  content.push(`export type ${model.name}UpdateFormOptions = {`);
  content.push(`  defaultValues?: Partial<Flow${model.name}Update>;`);
  content.push(`  onSuccess?: (data: Flow${model.name}) => void;`);
  content.push(`  onError?: (error: Error) => void;`);
  content.push(`  formOptions?: Omit<UseFormProps<Flow${model.name}Update>, 'resolver' | 'defaultValues'>;`);
  content.push(`  features?: ${model.name}FormFeatures;`);
  content.push(`};`);
  content.push(``);

  // Helper function to extract scalar fields
  content.push(`function extractScalarFields(data: any): any {`);
  content.push(`  const result: any = {};`);
  content.push(`  Object.keys(data).forEach(key => {`);
  content.push(`    const value = data[key];`);
  content.push(`    if (value === null || (typeof value !== 'object' && !Array.isArray(value))) {`);
  content.push(`      result[key] = value;`);
  content.push(`    }`);
  content.push(`  });`);
  content.push(`  return result;`);
  content.push(`}`);
  content.push(``);

  // CREATE form hook
  content.push(`export function useCreate${model.name}Form(options?: ${model.name}CreateFormOptions) {`);
  content.push(`  const { defaultValues, onSuccess, onError, formOptions, features } = options || {};`);
  content.push(`  `);
  content.push(`  const form = useForm<Flow${model.name}Create>({`);
  content.push(`    ...formOptions,`);
  content.push(`    resolver: zodResolver(${model.name}CreateSchema),`);
  content.push(`    defaultValues: defaultValues as Flow${model.name}Create`);
  content.push(`  });`);
  content.push(`  `);
  content.push(`  const mutation = useCreate${model.name}({`);
  content.push(`    onSuccess: (data) => {`);
  content.push(`      form.reset();`);
  content.push(`      onSuccess?.(data);`);
  content.push(`    },`);
  content.push(`    onError`);
  content.push(`  });`);
  content.push(`  `);
  content.push(`  // Field operations`);
  content.push(`  const getFieldState = useCallback((name: Path<Flow${model.name}Create>): ${model.name}FieldState => {`);
  content.push(`    const fieldState = form.getFieldState(name);`);
  content.push(`    return {`);
  content.push(`      isDirty: fieldState.isDirty,`);
  content.push(`      isTouched: fieldState.isTouched,`);
  content.push(`      error: fieldState.error,`);
  content.push(`      current: form.getValues(name),`);
  content.push(`      original: (form.formState.defaultValues as any)?.[name]`);
  content.push(`    };`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  const resetField = useCallback((name: Path<Flow${model.name}Create>) => {`);
  content.push(`    form.resetField(name);`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  const setFieldValue = useCallback(<T extends Path<Flow${model.name}Create>>(`);
  content.push(`    name: T,`);
  content.push(`    value: PathValue<Flow${model.name}Create, T>,`);
  content.push(`    options?: { shouldValidate?: boolean; shouldDirty?: boolean; shouldTouch?: boolean }`);
  content.push(`  ) => {`);
  content.push(`    form.setValue(name, value, options);`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  const validateField = useCallback((name: Path<Flow${model.name}Create>) => {`);
  content.push(`    return form.trigger(name);`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  const clearFieldError = useCallback((name: Path<Flow${model.name}Create>) => {`);
  content.push(`    form.clearErrors(name);`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  const batchUpdate = useCallback((updates: Partial<Flow${model.name}Create>) => {`);
  content.push(`    Object.entries(updates).forEach(([key, value]) => {`);
  content.push(`      form.setValue(key as Path<Flow${model.name}Create>, value as any);`);
  content.push(`    });`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  const getDirtyFields = useCallback((): ${model.name}DirtyField[] => {`);
  content.push(`    const dirtyFields: ${model.name}DirtyField[] = [];`);
  content.push(`    Object.keys(form.formState.dirtyFields).forEach(key => {`);
  content.push(`      if ((form.formState.dirtyFields as any)[key]) {`);
  content.push(`        dirtyFields.push({`);
  content.push(`          field: key,`);
  content.push(`          original: (form.formState.defaultValues as any)?.[key],`);
  content.push(`          current: form.getValues(key as Path<Flow${model.name}Create>)`);
  content.push(`        });`);
  content.push(`      }`);
  content.push(`    });`);
  content.push(`    return dirtyFields;`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  // Submit handler`);
  content.push(`  const submit = useCallback((data: Flow${model.name}Create) => {`);
  content.push(`    console.log('[${model.name}CreateForm] Submitting:', data);`);
  content.push(`    return mutation.mutate(data);`);
  content.push(`  }, [mutation]);`);
  content.push(`  `);
  content.push(`  const onInvalid = useCallback((errors: any) => {`);
  content.push(`    console.error('[${model.name}CreateForm] Validation failed:', errors);`);
  content.push(`  }, []);`);
  content.push(`  `);
  content.push(`  // Always call composables (no conditional hooks)`);
  content.push(`  const autosaveConfig = typeof features?.autosave === 'object' ? features.autosave : { enabled: !!features?.autosave };`);
  content.push(`  const autosave = use${model.name}FormAutosave(form, mutation, autosaveConfig);`);
  content.push(`  `);
  content.push(`  const tracking = use${model.name}FormFieldTracking(form);`);
  content.push(`  `);
  content.push(`  const historyConfig = typeof features?.history === 'object' ? features.history : { enabled: !!features?.history };`);
  content.push(`  const history = use${model.name}FormHistory(form, historyConfig);`);
  content.push(`  `);
  content.push(`  return {`);
  content.push(`    form,`);
  content.push(`    mutation,`);
  content.push(`    submit: form.handleSubmit(submit, onInvalid),`);
  content.push(`    isSubmitting: mutation.isPending,`);
  content.push(`    error: mutation.error,`);
  content.push(`    isSuccess: mutation.isSuccess,`);
  content.push(`    reset: () => form.reset(),`);
  content.push(`    // Field operations`);
  content.push(`    getFieldState,`);
  content.push(`    resetField,`);
  content.push(`    setFieldValue,`);
  content.push(`    validateField,`);
  content.push(`    clearFieldError,`);
  content.push(`    batchUpdate,`);
  content.push(`    getDirtyFields,`);
  content.push(`    // Include features if enabled`);
  content.push(`    ...(autosaveConfig.enabled ? { autosave } : {}),`);
  content.push(`    ...(features?.tracking ? { tracking } : {}),`);
  content.push(`    ...(historyConfig.enabled ? { history } : {})`);
  content.push(`  };`);
  content.push(`}`);
  content.push(``);

  // UPDATE form hook
  content.push(`export function useUpdate${model.name}Form(id: ${idType}, options?: ${model.name}UpdateFormOptions) {`);
  content.push(`  const { defaultValues, onSuccess, onError, formOptions, features } = options || {};`);
  content.push(`  `);
  content.push(`  const originalRef = useRef<Flow${model.name}>();`);
  content.push(`  `);
  content.push(`  // Fetch existing data`);
  content.push(`  const { data: existingData } = use${model.name}(id);`);
  content.push(`  `);
  content.push(`  // Initialize form`);
  content.push(`  const form = useForm<Flow${model.name}Update>({`);
  content.push(`    ...formOptions,`);
  content.push(`    resolver: zodResolver(${model.name}UpdateSchema),`);
  content.push(`    defaultValues: defaultValues as Flow${model.name}Update`);
  content.push(`  });`);
  content.push(`  `);
  content.push(`  // Track autosave ref to use in useEffect`);
  content.push(`  const autosaveRef = useRef<ReturnType<typeof use${model.name}FormAutosave>>();`);
  content.push(`  `);
  content.push(`  // Update form when existing data loads`);
  content.push(`  useEffect(() => {`);
  content.push(`    if (existingData) {`);
  content.push(`      originalRef.current = existingData;`);
  content.push(`      const scalarData = extractScalarFields(existingData);`);
  content.push(`      console.log('[${model.name}UpdateForm] Loading data:', scalarData);`);
  content.push(`      `);
  content.push(`      // Pause autosave during form reset to prevent loops`);
  content.push(`      if (autosaveRef.current?.pauseAutosave) {`);
  content.push(`        autosaveRef.current.pauseAutosave(() => {`);
  content.push(`          form.reset(scalarData as Flow${model.name}Update, {`);
  content.push(`            keepDirtyValues: true,`);
  content.push(`            keepErrors: true`);
  content.push(`          });`);
  content.push(`        });`);
  content.push(`      } else {`);
  content.push(`        form.reset(scalarData as Flow${model.name}Update, {`);
  content.push(`          keepDirtyValues: true,`);
  content.push(`          keepErrors: true`);
  content.push(`        });`);
  content.push(`      }`);
  content.push(`    }`);
  content.push(`  }, [existingData, form]);`);
  content.push(`  `);
  content.push(`  // Update mutation`);
  content.push(`  const mutation = useUpdate${model.name}(id, {`);
  content.push(`    onSuccess,`);
  content.push(`    onError`);
  content.push(`  });`);
  content.push(`  `);
  content.push(`  // Field operations with original comparison`);
  content.push(`  const getFieldState = useCallback((name: Path<Flow${model.name}Update>): ${model.name}FieldState => {`);
  content.push(`    const fieldState = form.getFieldState(name);`);
  content.push(`    const currentValue = form.getValues(name);`);
  content.push(`    const originalValue = originalRef.current?.[name as keyof Flow${model.name}];`);
  content.push(`    return {`);
  content.push(`      isDirty: fieldState.isDirty,`);
  content.push(`      isTouched: fieldState.isTouched,`);
  content.push(`      error: fieldState.error,`);
  content.push(`      current: currentValue,`);
  content.push(`      original: originalValue,`);
  content.push(`      hasChanged: currentValue !== originalValue`);
  content.push(`    };`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  const resetField = useCallback((name: Path<Flow${model.name}Update>) => {`);
  content.push(`    const originalValue = originalRef.current?.[name as keyof Flow${model.name}];`);
  content.push(`    form.setValue(name, originalValue as any);`);
  content.push(`    form.clearErrors(name);`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  const setFieldValue = useCallback(<T extends Path<Flow${model.name}Update>>(`);
  content.push(`    name: T,`);
  content.push(`    value: PathValue<Flow${model.name}Update, T>,`);
  content.push(`    options?: { shouldValidate?: boolean; shouldDirty?: boolean; shouldTouch?: boolean }`);
  content.push(`  ) => {`);
  content.push(`    form.setValue(name, value, options);`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  const validateField = useCallback((name: Path<Flow${model.name}Update>) => {`);
  content.push(`    return form.trigger(name);`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  const clearFieldError = useCallback((name: Path<Flow${model.name}Update>) => {`);
  content.push(`    form.clearErrors(name);`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  const batchUpdate = useCallback((updates: Partial<Flow${model.name}Update>) => {`);
  content.push(`    Object.entries(updates).forEach(([key, value]) => {`);
  content.push(`      form.setValue(key as Path<Flow${model.name}Update>, value as any);`);
  content.push(`    });`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  const getDirtyFields = useCallback((): ${model.name}DirtyField[] => {`);
  content.push(`    const dirtyFields: ${model.name}DirtyField[] = [];`);
  content.push(`    Object.keys(form.formState.dirtyFields).forEach(key => {`);
  content.push(`      if ((form.formState.dirtyFields as any)[key]) {`);
  content.push(`        dirtyFields.push({`);
  content.push(`          field: key,`);
  content.push(`          original: originalRef.current?.[key as keyof Flow${model.name}],`);
  content.push(`          current: form.getValues(key as Path<Flow${model.name}Update>)`);
  content.push(`        });`);
  content.push(`      }`);
  content.push(`    });`);
  content.push(`    return dirtyFields;`);
  content.push(`  }, [form]);`);
  content.push(`  `);
  content.push(`  // Submit handler`);
  content.push(`  const submit = useCallback((data: Flow${model.name}Update) => {`);
  content.push(`    console.log('[${model.name}UpdateForm] Submitting:', data);`);
  content.push(`    return mutation.mutate(data);`);
  content.push(`  }, [mutation]);`);
  content.push(`  `);
  content.push(`  const onInvalid = useCallback((errors: any) => {`);
  content.push(`    console.error('[${model.name}UpdateForm] Validation failed:', errors);`);
  content.push(`  }, []);`);
  content.push(`  `);
  content.push(`  // Always call composables (no conditional hooks)`);
  content.push(`  const autosaveConfig = typeof features?.autosave === 'object' ? features.autosave : { enabled: !!features?.autosave };`);
  content.push(`  const autosave = use${model.name}FormAutosave(form, mutation, autosaveConfig);`);
  content.push(`  `);
  content.push(`  // Store autosave ref for use in useEffect`);
  content.push(`  useEffect(() => {`);
  content.push(`    autosaveRef.current = autosave;`);
  content.push(`  }, [autosave]);`);
  content.push(`  `);
  content.push(`  const tracking = use${model.name}FormFieldTracking(form, originalRef.current);`);
  content.push(`  `);
  content.push(`  const historyConfig = typeof features?.history === 'object' ? features.history : { enabled: !!features?.history };`);
  content.push(`  const history = use${model.name}FormHistory(form, historyConfig);`);
  content.push(`  `);
  content.push(`  return {`);
  content.push(`    form,`);
  content.push(`    mutation,`);
  content.push(`    original: originalRef.current,`);
  content.push(`    submit: form.handleSubmit(submit, onInvalid),`);
  content.push(`    isSubmitting: mutation.isPending,`);
  content.push(`    error: mutation.error,`);
  content.push(`    isSuccess: mutation.isSuccess,`);
  content.push(`    reset: () => form.reset(extractScalarFields(originalRef.current || {})),`);
  content.push(`    // Field operations`);
  content.push(`    getFieldState,`);
  content.push(`    resetField,`);
  content.push(`    setFieldValue,`);
  content.push(`    validateField,`);
  content.push(`    clearFieldError,`);
  content.push(`    batchUpdate,`);
  content.push(`    getDirtyFields,`);
  content.push(`    // Include features if enabled`);
  content.push(`    ...(autosaveConfig.enabled ? { autosave } : {}),`);
  content.push(`    ...(features?.tracking ? { tracking } : {}),`);
  content.push(`    ...(historyConfig.enabled ? { history } : {})`);
  content.push(`  };`);
  content.push(`}`);
  content.push(``);

  // Form component type helpers
  content.push(`export type ${model.name}CreateFormProps = {`);
  content.push(`  form: UseFormReturn<Flow${model.name}Create>;`);
  content.push(`  onSubmit: () => void;`);
  content.push(`  isSubmitting: boolean;`);
  content.push(`  error?: Error | null;`);
  content.push(`};`);
  content.push(``);
  content.push(`export type ${model.name}UpdateFormProps = {`);
  content.push(`  form: UseFormReturn<Flow${model.name}Update>;`);
  content.push(`  onSubmit: () => void;`);
  content.push(`  isSubmitting: boolean;`);
  content.push(`  error?: Error | null;`);
  content.push(`  original?: Flow${model.name};`);
  content.push(`};`);

  const clientDir = join(modelDir, "client");
  await write(join(clientDir, "forms.ts"), content.join("\n"));
}