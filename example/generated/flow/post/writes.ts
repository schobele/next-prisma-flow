// @generated by next-prisma-flow-state-engine
// file: writes.ts

import type { Prisma } from "@prisma/client";
import type { FlowPostWrite } from "./zod";
import { transformAuthorCreate, transformAuthorUpdate } from "../author/writes";
import {
  transformCommentCreate,
  transformCommentUpdate,
} from "../comment/writes";
import { transformTagCreate, transformTagUpdate } from "../tag/writes";
import {
  transformOrganizationCreate,
  transformOrganizationUpdate,
} from "../organization/writes";

export function transformPostCreate(
  input: FlowPostWrite,
): Prisma.PostCreateInput {
  const result: any = {};

  result.title = input.title as any;
  if ("content" in input) {
    result.content = input.content as any;
  }
  if ("published" in input) {
    result.published = input.published as any;
  }
  if ("views" in input) {
    result.views = input.views as any;
  }
  if ("createdAt" in input) {
    result.createdAt = input.createdAt as any;
  }
  if (input.authorId !== undefined && input.author === undefined) {
    // Direct foreign key provided - use connect
    result.author = { connect: { id: input.authorId } };
  } else if (input.author !== undefined) {
    const rel = input.author;
    const strategy = rel.flowRelationStrategy;
    const data = { ...rel };
    delete data.flowRelationStrategy;

    switch (strategy) {
      case "connect": {
        const where: any = {};
        if (data.id) where.id = data.id;
        if (data.email) where.email = data.email;
        result.author = { connect: where };
        break;
      }

      case "create": {
        result.author = { create: transformAuthorCreate(data) };
        break;
      }

      case "connectOrCreate": {
        const where: any = {};
        if (data.id) where.id = data.id;
        if (data.email) where.email = data.email;
        const createData = { ...data };
        delete createData.id;
        if (where.email) delete createData.email;
        result.author = {
          connectOrCreate: {
            where,
            create: transformAuthorCreate(createData),
          },
        };
        break;
      }

      default: {
        // Smart default based on available fields
        const where: any = {};
        if (data.id) where.id = data.id;
        if (data.email) where.email = data.email;

        // Check if we have all required fields for create
        const hasAllRequiredFields = data.email != null;
        if (Object.keys(where).length === 0) {
          // No ID/unique fields - must create
          result.author = { create: transformAuthorCreate(data) };
        } else if (!hasAllRequiredFields) {
          // Has ID/unique but missing required fields - use connect
          result.author = { connect: where };
        } else {
          // Has ID/unique AND all required fields - use connectOrCreate
          const createData = { ...data };
          delete createData.id;
          if (where.email) delete createData.email;
          result.author = {
            connectOrCreate: {
              where,
              create: transformAuthorCreate(createData),
            },
          };
        }
      }
    }
  }
  if (input.comments !== undefined) {
    if (Array.isArray(input.comments)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];

      for (const item of input.comments) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformCommentCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
          }
        }
      }

      result.comments = {};
      if (connects.length) result.comments.connect = connects;
      if (creates.length) result.comments.create = creates;
      if (connectOrCreates.length)
        result.comments.connectOrCreate = connectOrCreates;
    }
  }
  if (input.tags !== undefined) {
    if (Array.isArray(input.tags)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];

      for (const item of input.tags) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.name) where.name = data.name;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformTagCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.name) where.name = data.name;
            const createData = { ...data };
            delete createData.id;
            if (where.name) delete createData.name;
            connectOrCreates.push({
              where,
              create: transformTagCreate(createData),
            });
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.name) where.name = data.name;
            const createData = { ...data };
            delete createData.id;
            if (where.name) delete createData.name;
            connectOrCreates.push({
              where,
              create: transformTagCreate(createData),
            });
          }
        }
      }

      result.tags = {};
      if (connects.length) result.tags.connect = connects;
      if (creates.length) result.tags.create = creates;
      if (connectOrCreates.length)
        result.tags.connectOrCreate = connectOrCreates;
    }
  }
  if (input.organizationId !== undefined && input.organization === undefined) {
    // Direct foreign key provided - use connect
    result.organization = { connect: { id: input.organizationId } };
  } else if (input.organization !== undefined) {
    const rel = input.organization;
    const strategy = rel.flowRelationStrategy;
    const data = { ...rel };
    delete data.flowRelationStrategy;

    switch (strategy) {
      case "connect": {
        const where: any = {};
        if (data.id) where.id = data.id;
        result.organization = { connect: where };
        break;
      }

      case "create": {
        result.organization = { create: transformOrganizationCreate(data) };
        break;
      }

      case "connectOrCreate": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const createData = { ...data };
        delete createData.id;
        result.organization = {
          connectOrCreate: {
            where,
            create: transformOrganizationCreate(createData),
          },
        };
        break;
      }

      default: {
        // Smart default based on available fields
        const where: any = {};
        if (data.id) where.id = data.id;

        const hasAllRequiredFields = true; // No required fields

        if (Object.keys(where).length === 0) {
          // No ID/unique fields - must create
          result.organization = { create: transformOrganizationCreate(data) };
        } else if (!hasAllRequiredFields) {
          // Has ID/unique but missing required fields - use connect
          result.organization = { connect: where };
        } else {
          // Has ID/unique AND all required fields - use connectOrCreate
          const createData = { ...data };
          delete createData.id;
          result.organization = {
            connectOrCreate: {
              where,
              create: transformOrganizationCreate(createData),
            },
          };
        }
      }
    }
  }

  return result as Prisma.PostCreateInput;
}

export function transformPostUpdate(
  input: Partial<FlowPostWrite>,
): Prisma.PostUpdateInput {
  const result: any = {};

  if ("title" in input) {
    result.title = input.title as any;
  }
  if ("content" in input) {
    result.content = input.content as any;
  }
  if ("published" in input) {
    result.published = input.published as any;
  }
  if ("views" in input) {
    result.views = input.views as any;
  }
  if ("createdAt" in input) {
    result.createdAt = input.createdAt as any;
  }
  if (input.authorId !== undefined && input.author === undefined) {
    // Direct foreign key provided - use connect
    result.author = { connect: { id: input.authorId } };
  } else if (input.author !== undefined) {
    const rel = input.author;
    const strategy = rel.flowRelationStrategy;
    const data = { ...rel };
    delete data.flowRelationStrategy;

    switch (strategy) {
      case "connect": {
        const where: any = {};
        if (data.id) where.id = data.id;
        if (data.email) where.email = data.email;
        result.author = { connect: where };
        break;
      }

      case "create": {
        result.author = { create: transformAuthorCreate(data) };
        break;
      }

      case "connectOrCreate": {
        const where: any = {};
        if (data.id) where.id = data.id;
        if (data.email) where.email = data.email;
        const createData = { ...data };
        delete createData.id;
        if (where.email) delete createData.email;
        result.author = {
          connectOrCreate: {
            where,
            create: transformAuthorCreate(createData),
          },
        };
        break;
      }

      case "update": {
        result.author = { update: transformAuthorUpdate(data) };
        break;
      }

      case "upsert": {
        const where: any = {};
        if (data.id) where.id = data.id;
        if (data.email) where.email = data.email;
        const upsertData = { ...data };
        delete upsertData.id;
        result.author = {
          upsert: {
            where,
            create: transformAuthorCreate(upsertData),
            update: transformAuthorUpdate(upsertData),
          },
        };
        break;
      }

      case "disconnect": {
        result.author = { disconnect: true };
        break;
      }

      case "delete": {
        result.author = { delete: true };
        break;
      }

      default: {
        // Smart default based on available fields
        const where: any = {};
        if (data.id) where.id = data.id;
        if (data.email) where.email = data.email;

        // Check if we have all required fields for create
        const hasAllRequiredFields = data.email != null;
        if (Object.keys(where).length === 0) {
          // No ID/unique fields - must create
          result.author = { create: transformAuthorCreate(data) };
        } else if (!hasAllRequiredFields) {
          // Has ID/unique but missing required fields - use connect
          result.author = { connect: where };
        } else {
          // Has ID/unique AND all required fields - use connectOrCreate
          const createData = { ...data };
          delete createData.id;
          if (where.email) delete createData.email;
          result.author = {
            connectOrCreate: {
              where,
              create: transformAuthorCreate(createData),
            },
          };
        }
      }
    }
  }
  if (input.comments !== undefined) {
    if (Array.isArray(input.comments)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];
      const updates: any[] = [];
      const upserts: any[] = [];
      const deletes: any[] = [];
      let hasSet = false;

      for (const item of input.comments) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformCommentCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
            break;
          }

          case "update": {
            const where: any = {};
            if (data.id) where.id = data.id;
            updates.push({
              where,
              data: transformCommentUpdate(data),
            });
            break;
          }

          case "set": {
            hasSet = true;
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "delete": {
            const where: any = {};
            if (data.id) where.id = data.id;
            deletes.push(where);
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
          }
        }
      }

      result.comments = {};
      if (hasSet) result.comments.set = connects;
      else {
        if (connects.length) result.comments.connect = connects;
        if (creates.length) result.comments.create = creates;
        if (connectOrCreates.length)
          result.comments.connectOrCreate = connectOrCreates;
        if (updates.length) result.comments.updateMany = updates;
        if (deletes.length) result.comments.deleteMany = deletes;
      }
    }
  }
  if (input.tags !== undefined) {
    if (Array.isArray(input.tags)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];
      const updates: any[] = [];
      const upserts: any[] = [];
      const deletes: any[] = [];
      let hasSet = false;

      for (const item of input.tags) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.name) where.name = data.name;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformTagCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.name) where.name = data.name;
            const createData = { ...data };
            delete createData.id;
            if (where.name) delete createData.name;
            connectOrCreates.push({
              where,
              create: transformTagCreate(createData),
            });
            break;
          }

          case "update": {
            const where: any = {};
            if (data.id) where.id = data.id;
            updates.push({
              where,
              data: transformTagUpdate(data),
            });
            break;
          }

          case "set": {
            hasSet = true;
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.name) where.name = data.name;
            connects.push(where);
            break;
          }

          case "delete": {
            const where: any = {};
            if (data.id) where.id = data.id;
            deletes.push(where);
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.name) where.name = data.name;
            const createData = { ...data };
            delete createData.id;
            if (where.name) delete createData.name;
            connectOrCreates.push({
              where,
              create: transformTagCreate(createData),
            });
          }
        }
      }

      result.tags = {};
      if (hasSet) result.tags.set = connects;
      else {
        if (connects.length) result.tags.connect = connects;
        if (creates.length) result.tags.create = creates;
        if (connectOrCreates.length)
          result.tags.connectOrCreate = connectOrCreates;
        if (updates.length) result.tags.updateMany = updates;
        if (deletes.length) result.tags.deleteMany = deletes;
      }
    }
  }
  if (input.organizationId !== undefined && input.organization === undefined) {
    // Direct foreign key provided - use connect
    result.organization = { connect: { id: input.organizationId } };
  } else if (input.organization !== undefined) {
    const rel = input.organization;
    const strategy = rel.flowRelationStrategy;
    const data = { ...rel };
    delete data.flowRelationStrategy;

    switch (strategy) {
      case "connect": {
        const where: any = {};
        if (data.id) where.id = data.id;
        result.organization = { connect: where };
        break;
      }

      case "create": {
        result.organization = { create: transformOrganizationCreate(data) };
        break;
      }

      case "connectOrCreate": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const createData = { ...data };
        delete createData.id;
        result.organization = {
          connectOrCreate: {
            where,
            create: transformOrganizationCreate(createData),
          },
        };
        break;
      }

      case "update": {
        result.organization = { update: transformOrganizationUpdate(data) };
        break;
      }

      case "upsert": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const upsertData = { ...data };
        delete upsertData.id;
        result.organization = {
          upsert: {
            where,
            create: transformOrganizationCreate(upsertData),
            update: transformOrganizationUpdate(upsertData),
          },
        };
        break;
      }

      case "disconnect": {
        result.organization = { disconnect: true };
        break;
      }

      case "delete": {
        result.organization = { delete: true };
        break;
      }

      default: {
        // Smart default based on available fields
        const where: any = {};
        if (data.id) where.id = data.id;

        const hasAllRequiredFields = true; // No required fields

        if (Object.keys(where).length === 0) {
          // No ID/unique fields - must create
          result.organization = { create: transformOrganizationCreate(data) };
        } else if (!hasAllRequiredFields) {
          // Has ID/unique but missing required fields - use connect
          result.organization = { connect: where };
        } else {
          // Has ID/unique AND all required fields - use connectOrCreate
          const createData = { ...data };
          delete createData.id;
          result.organization = {
            connectOrCreate: {
              where,
              create: transformOrganizationCreate(createData),
            },
          };
        }
      }
    }
  }

  return result as Prisma.PostUpdateInput;
}
