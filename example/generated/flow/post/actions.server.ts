// @generated by next-prisma-flow-state-engine
// file: actions.server.ts

"use server";

import { prisma } from "../../../lib/prisma";
import { z } from "zod";
import { invalidateTags, keys, FlowCtx } from "../core";
import { canPost } from "../policies";
import { PostDeepSelect } from "./selects";
import { PostCreateSchema, PostUpdateSchema } from "./zod";
import type { FlowPostCreate, FlowPostUpdate } from "./zod";
import { transformPostCreate, transformPostUpdate } from "./writes";

export async function createPost(data: FlowPostCreate, ctx: FlowCtx) {
  const policy = await canPost("create", ctx);
  if (!policy.ok) return { ok: false, error: policy.message };

  const parsed = PostCreateSchema.safeParse(data);
  if (!parsed.success) {
    return { ok: false, error: "Invalid data", issues: parsed.error.issues };
  }

  try {
    const createData = transformPostCreate(parsed.data as any);
    const item = await prisma.post.create({
      data: { ...createData, ...policy.data },
      select: PostDeepSelect,
    });

    await invalidateTags([keys.m("Post").tag()]);
    return { ok: true, data: item };
  } catch (error) {
    console.error("Error creating Post:", error);
    return { ok: false, error: "Failed to create" };
  }
}

export async function updatePost(
  id: string,
  data: FlowPostUpdate,
  ctx: FlowCtx,
) {
  const policy = await canPost("update", ctx, id);
  if (!policy.ok) return { ok: false, error: policy.message };

  // Validate update payload against UpdateSchema (all fields optional)
  const parsedUpdate = PostUpdateSchema.safeParse(data);
  if (!parsedUpdate.success) {
    return {
      ok: false,
      error: "Invalid data",
      issues: parsedUpdate.error.issues,
    };
  }
  try {
    const updateData = transformPostUpdate(parsedUpdate.data as any);
    const item = await prisma.post.update({
      where: { id: id, ...policy.where },
      data: { ...updateData, ...policy.data },
      select: PostDeepSelect,
    });

    await invalidateTags([
      keys.m("Post").tag(),
      keys.m("Post").tag(String(id)),
    ]);
    return { ok: true, data: item };
  } catch (error) {
    console.error("Error updating Post:", error);
    return { ok: false, error: "Failed to update" };
  }
}

export async function deletePost(id: string, ctx: FlowCtx) {
  const policy = await canPost("delete", ctx, id);
  if (!policy.ok) return { ok: false, error: policy.message };

  try {
    await prisma.post.delete({
      where: { id: id, ...policy.where },
    });

    await invalidateTags([
      keys.m("Post").tag(),
      keys.m("Post").tag(String(id)),
    ]);
    return { ok: true };
  } catch (error) {
    console.error("Error deleting Post:", error);
    return { ok: false, error: "Failed to delete" };
  }
}
