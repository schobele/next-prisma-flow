// @generated by next-prisma-flow-state-engine
// file: forms.ts

"use client";

import { zodResolver } from "@hookform/resolvers/zod";
import { useCallback, useState } from "react";
import { type UseFormProps, UseFormReturn, useForm } from "react-hook-form";
import { z } from "zod";
import { useCreatePost, usePost, useUpdatePost } from "./hooks";
import type { FlowPostCreate, FlowPostUpdate, FlowPostWrite } from "./zod";
import { PostCreateSchema, PostUpdateSchema } from "./zod";

export function usePostForm(params?: {
	id?: string;
	mode?: "create" | "update";
	defaultValues?: Partial<FlowPostCreate> | Partial<FlowPostUpdate>;
	form?: Omit<UseFormProps<FlowPostWrite>, "resolver" | "defaultValues">;
}) {
	const mode = params?.mode || "create";
	const id = params?.id as string | undefined;

	const post = id ? usePost(id) : null;
	// Use mode-specific schemas for better client-side validation

	const schema =
		mode === "create"
			? z.object({
					flowWriteMode: z.literal("create"),
					...PostCreateSchema.shape,
				})
			: z.object({
					flowWriteMode: z.literal("update"),
					...PostUpdateSchema.shape,
				});
	const refinedSchema = schema.superRefine((val, ctx) => {
		if (val.author == null && (val as any).authorId == null) {
			ctx.addIssue({
				code: "custom",
				path: ["author"],
				message: "author is required",
			});
		}
	});
	const userFormOpts = params?.form || {};
	const mergedDefaults: any = {
		...(userFormOpts as any).defaultValues,
		...(params?.defaultValues || {}),
		...(post?.data || {}),
	};
	mergedDefaults.flowWriteMode = mode;
	const form = useForm<FlowPostWrite>({
		...(userFormOpts as any),
		resolver: zodResolver(refinedSchema),
		defaultValues: mergedDefaults,
	});
	const [serverError, setServerError] = useState<string | null>(null);

	const createMutation = useCreatePost();
	const updateMutation = id ? useUpdatePost(id) : null;

	const onSubmit = useCallback(
		async (data: FlowPostWrite) => {
			try {
				setServerError(null);
				if (mode === "update" && updateMutation) {
					await updateMutation.mutateAsync(data);
				} else {
					await createMutation.mutateAsync(data);
				}
				form.reset();
			} catch (error: any) {
				console.error("Form submission error:", error);
				const msg =
					typeof error?.error === "string"
						? error.error
						: error?.message || "Request failed";
				setServerError(msg);
			}
		},
		[mode, createMutation, updateMutation, form],
	);

	return {
		form,
		onSubmit,
		isSubmitting:
			createMutation.isPending || (updateMutation?.isPending ?? false),
		mode,
		serverError,
	};
}

export type PostFormReturn = ReturnType<typeof usePostForm>;
