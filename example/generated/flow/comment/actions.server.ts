// @generated by next-prisma-flow-state-engine
// file: actions.server.ts

"use server";

import { prisma } from "../../../lib/prisma";
import { z } from "zod";
import { invalidateTags, keys, FlowCtx } from "../core";
import { canComment } from "../policies";
import { CommentDeepSelect } from "./selects";
import { CommentCreateSchema, CommentUpdateSchema } from "./zod";
import type { FlowCommentCreate, FlowCommentUpdate } from "./zod";
import { transformCommentCreate, transformCommentUpdate } from "./writes";

export async function createComment(data: FlowCommentCreate, ctx: FlowCtx) {
  const policy = await canComment("create", ctx);
  if (!policy.ok) return { ok: false, error: policy.message };

  const parsed = CommentCreateSchema.safeParse(data);
  if (!parsed.success) {
    return { ok: false, error: "Invalid data", issues: parsed.error.issues };
  }

  try {
    const createData = transformCommentCreate(parsed.data as any);
    const item = await prisma.comment.create({
      data: { ...createData, ...policy.data },
      select: CommentDeepSelect,
    });

    await invalidateTags([keys.m("Comment").tag()]);
    return { ok: true, data: item };
  } catch (error) {
    console.error("Error creating Comment:", error);
    return { ok: false, error: "Failed to create" };
  }
}

export async function updateComment(
  id: string,
  data: FlowCommentUpdate,
  ctx: FlowCtx,
) {
  const policy = await canComment("update", ctx, id);
  if (!policy.ok) return { ok: false, error: policy.message };

  // Validate update payload against UpdateSchema (all fields optional)
  const parsedUpdate = CommentUpdateSchema.safeParse(data);
  if (!parsedUpdate.success) {
    return {
      ok: false,
      error: "Invalid data",
      issues: parsedUpdate.error.issues,
    };
  }
  try {
    const updateData = transformCommentUpdate(parsedUpdate.data as any);
    const item = await prisma.comment.update({
      where: { id: id, ...policy.where },
      data: { ...updateData, ...policy.data },
      select: CommentDeepSelect,
    });

    await invalidateTags([
      keys.m("Comment").tag(),
      keys.m("Comment").tag(String(id)),
    ]);
    return { ok: true, data: item };
  } catch (error) {
    console.error("Error updating Comment:", error);
    return { ok: false, error: "Failed to update" };
  }
}

export async function deleteComment(id: string, ctx: FlowCtx) {
  const policy = await canComment("delete", ctx, id);
  if (!policy.ok) return { ok: false, error: policy.message };

  try {
    await prisma.comment.delete({
      where: { id: id, ...policy.where },
    });

    await invalidateTags([
      keys.m("Comment").tag(),
      keys.m("Comment").tag(String(id)),
    ]);
    return { ok: true };
  } catch (error) {
    console.error("Error deleting Comment:", error);
    return { ok: false, error: "Failed to delete" };
  }
}
