// @generated by next-prisma-flow-state-engine
// file: types/transforms.ts

import type { Prisma } from "../../prisma";
import type { FlowCommentCreate, FlowCommentUpdate } from "./schemas";
import { transformAuthorCreate } from "../../author/types/transforms";

export function transformCommentCreate(
  input: FlowCommentCreate,
): Prisma.CommentCreateInput {
  const result: Prisma.CommentCreateInput = {} as Prisma.CommentCreateInput;

  result.content = input.content;
  if ("createdAt" in input && input.createdAt !== undefined) {
    result.createdAt = input.createdAt;
  }
  if (input.author !== undefined) {
    const authorData = input.author;
    if (authorData) {
      if ("connect" in authorData && authorData.connect) {
        result.author = { connect: authorData.connect };
      } else if ("create" in authorData && authorData.create) {
        result.author = { create: transformAuthorCreate(authorData.create) };
      } else if (
        "connectOrCreate" in authorData &&
        authorData.connectOrCreate
      ) {
        result.author = {
          connectOrCreate: {
            where: authorData.connectOrCreate.where,
            create: transformAuthorCreate(authorData.connectOrCreate.create),
          },
        };
      }
    }
  }
  // Handle foreign key field when relation is not provided
  if (input.author === undefined && "authorId" in input && input.authorId) {
    result.author = { connect: { id: input.authorId } };
  }
  if (input.replies !== undefined) {
    const repliesData = input.replies;
    if (repliesData) {
      if ("connect" in repliesData && repliesData.connect) {
        result.replies = { connect: repliesData.connect };
      } else if ("create" in repliesData && repliesData.create) {
        const cleanedData = Array.isArray(repliesData.create)
          ? repliesData.create.map((item: any) => {
              // Extract only scalar fields and foreign keys that exist in input
              const cleaned: any = {};
              if ("id" in item && item.id !== undefined) cleaned.id = item.id;
              if ("content" in item && item.content !== undefined)
                cleaned.content = item.content;
              if ("createdAt" in item && item.createdAt !== undefined)
                cleaned.createdAt = item.createdAt;
              if ("updatedAt" in item && item.updatedAt !== undefined)
                cleaned.updatedAt = item.updatedAt;
              if ("postId" in item && item.postId !== undefined)
                cleaned.postId = item.postId;
              if ("authorId" in item && item.authorId !== undefined)
                cleaned.authorId = item.authorId;
              if ("parentId" in item && item.parentId !== undefined)
                cleaned.parentId = item.parentId;
              if ("organizationId" in item && item.organizationId !== undefined)
                cleaned.organizationId = item.organizationId;
              return cleaned;
            })
          : (() => {
              const item = repliesData.create;
              const cleaned: any = {};
              if ("id" in item && item.id !== undefined) cleaned.id = item.id;
              if ("content" in item && item.content !== undefined)
                cleaned.content = item.content;
              if ("createdAt" in item && item.createdAt !== undefined)
                cleaned.createdAt = item.createdAt;
              if ("updatedAt" in item && item.updatedAt !== undefined)
                cleaned.updatedAt = item.updatedAt;
              if ("postId" in item && item.postId !== undefined)
                cleaned.postId = item.postId;
              if ("authorId" in item && item.authorId !== undefined)
                cleaned.authorId = item.authorId;
              if ("parentId" in item && item.parentId !== undefined)
                cleaned.parentId = item.parentId;
              if ("organizationId" in item && item.organizationId !== undefined)
                cleaned.organizationId = item.organizationId;
              return cleaned;
            })();
        result.replies = { create: cleanedData };
      }
    }
  }
  // Handle post foreign key when relation is not configured
  if ("postId" in input && input.postId) {
    result.post = { connect: { id: input.postId } };
  }
  // Handle parent foreign key when relation is not configured
  if ("parentId" in input && input.parentId) {
    result.parent = { connect: { id: input.parentId } };
  }
  // Handle organization foreign key when relation is not configured
  if ("organizationId" in input && input.organizationId) {
    result.organization = { connect: { id: input.organizationId } };
  }

  return result;
}

export function transformCommentUpdate(
  input: FlowCommentUpdate,
): Prisma.CommentUpdateInput {
  const result: Prisma.CommentUpdateInput = {} as Prisma.CommentUpdateInput;

  const contentValue = input.content;
  if (contentValue !== undefined && contentValue !== null) {
    result.content = contentValue;
  }
  const createdAtValue = input.createdAt;
  if (createdAtValue !== undefined && createdAtValue !== null) {
    result.createdAt = createdAtValue;
  }
  if (input.author !== undefined) {
    const authorData = input.author;
    if (authorData) {
      result.author = {};
      if ("create" in authorData && authorData.create) {
        result.author.create = transformAuthorCreate(authorData.create);
      }
      if ("connect" in authorData && authorData.connect) {
        result.author.connect = authorData.connect;
      }
      if ("connectOrCreate" in authorData && authorData.connectOrCreate) {
        result.author.connectOrCreate = authorData.connectOrCreate;
      }
      if ("update" in authorData && authorData.update) {
        result.author.update = authorData.update;
      }
      if ("upsert" in authorData && authorData.upsert) {
        result.author.upsert = authorData.upsert;
      }
    }
  }
  if (input.replies !== undefined) {
    const repliesData = input.replies;
    if (repliesData) {
      result.replies = {};
      if ("create" in repliesData && repliesData.create) {
        result.replies.create = repliesData.create;
      }
      if ("createMany" in repliesData && repliesData.createMany) {
        result.replies.createMany = repliesData.createMany;
      }
      if ("connect" in repliesData && repliesData.connect) {
        result.replies.connect = repliesData.connect;
      }
      if ("connectOrCreate" in repliesData && repliesData.connectOrCreate) {
        result.replies.connectOrCreate = repliesData.connectOrCreate;
      }
      if ("update" in repliesData && repliesData.update) {
        result.replies.update = repliesData.update;
      }
      if ("updateMany" in repliesData && repliesData.updateMany) {
        result.replies.updateMany = repliesData.updateMany;
      }
      if ("upsert" in repliesData && repliesData.upsert) {
        result.replies.upsert = repliesData.upsert;
      }
      if ("delete" in repliesData && repliesData.delete) {
        result.replies.delete = repliesData.delete;
      }
      if ("deleteMany" in repliesData && repliesData.deleteMany) {
        result.replies.deleteMany = repliesData.deleteMany;
      }
      if ("disconnect" in repliesData && repliesData.disconnect) {
        result.replies.disconnect = repliesData.disconnect;
      }
      if ("set" in repliesData && repliesData.set) {
        result.replies.set = repliesData.set;
      }
    }
  }

  return result;
}
