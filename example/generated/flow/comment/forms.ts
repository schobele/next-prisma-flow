// @generated by next-prisma-flow-state-engine
// file: forms.ts

"use client";

import { useCallback, useEffect, useRef, useState } from "react";
import { z } from "zod";
import { useForm, UseFormReturn, UseFormProps } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { CommentCreateSchema, CommentUpdateSchema } from "./zod";
import type {
  FlowCommentWrite,
  FlowCommentCreate,
  FlowCommentUpdate,
} from "./zod";
import { useCreateComment, useUpdateComment } from "./hooks";

export function useCommentForm(params?: {
  id?: string;
  mode?: "create" | "update";
  defaultValues?: Partial<FlowCommentCreate> | Partial<FlowCommentUpdate>;
  form?: Omit<UseFormProps<FlowCommentWrite>, "resolver" | "defaultValues">;
  autosave?: boolean | { debounceMs?: number };
}) {
  const mode = params?.mode || "create";
  const id = params?.id as string | undefined;
  // Use mode-specific schemas for better client-side validation

  const schema =
    mode === "create"
      ? z.object({
          flowWriteMode: z.literal("create"),
          ...CommentCreateSchema.shape,
        })
      : z.object({
          flowWriteMode: z.literal("update"),
          ...CommentUpdateSchema.shape,
        });
  const refinedSchema =
    mode === "create"
      ? schema.superRefine((val, ctx) => {
          if (val.post == null && (val as any).postId == null) {
            ctx.addIssue({
              code: "custom",
              path: ["post"],
              message: "post is required",
            });
          }
          if (val.author == null && (val as any).authorId == null) {
            ctx.addIssue({
              code: "custom",
              path: ["author"],
              message: "author is required",
            });
          }
        })
      : schema;
  const userFormOpts = params?.form || {};
  const normalizedFormOpts = {
    mode: (userFormOpts as any).mode ?? "all",
    ...userFormOpts,
  } as any;
  const mergedDefaults: any = {
    ...(normalizedFormOpts as any).defaultValues,
    ...(params?.defaultValues || {}),
  };
  mergedDefaults.flowWriteMode = mode;
  const form = useForm<FlowCommentWrite>({
    ...normalizedFormOpts,
    resolver: zodResolver(refinedSchema),
    defaultValues: mergedDefaults,
  });
  const [serverError, setServerError] = useState<string | null>(null);
  const autosaveTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const createMutation = useCreateComment();
  const updateMutation = id ? useUpdateComment(id) : null;

  const onSubmit = useCallback(
    async (data: FlowCommentWrite) => {
      try {
        setServerError(null);
        if (mode === "update" && updateMutation) {
          await updateMutation.mutateAsync(data);
        } else {
          await createMutation.mutateAsync(data);
        }
        form.reset();
      } catch (error: any) {
        console.error("Form submission error:", error);
        const msg =
          typeof error?.error === "string"
            ? error.error
            : error?.message || "Request failed";
        setServerError(msg);
      }
    },
    [mode, createMutation, updateMutation, form],
  );

  // Autosave support
  useEffect(() => {
    const enabled = !!params?.autosave;
    if (!enabled) return;
    const debounceMs =
      typeof params?.autosave === "object"
        ? (params!.autosave!.debounceMs ?? 600)
        : 600;
    const subscription = form.watch(() => {
      const hasTouched =
        Object.keys(form.formState.touchedFields || {}).length > 0;
      if (!hasTouched || !form.formState.isValid) return;
      if (autosaveTimerRef.current) clearTimeout(autosaveTimerRef.current);
      autosaveTimerRef.current = setTimeout(() => {
        form.handleSubmit(onSubmit as any)();
      }, debounceMs);
    });
    return () => {
      (subscription as any)?.unsubscribe?.();
      if (autosaveTimerRef.current) clearTimeout(autosaveTimerRef.current);
    };
  }, [form, onSubmit, params?.autosave]);

  return {
    form,
    onSubmit,
    isSubmitting:
      createMutation.isPending || (updateMutation?.isPending ?? false),
    mode,
    serverError,
  };
}

export type CommentFormReturn = ReturnType<typeof useCommentForm>;
