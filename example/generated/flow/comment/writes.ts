// @generated by next-prisma-flow-state-engine
// file: writes.ts

import type { Prisma } from "@prisma/client";
import type { FlowCommentWrite } from "./zod";
import { transformPostCreate, transformPostUpdate } from "../post/writes";
import { transformAuthorCreate, transformAuthorUpdate } from "../author/writes";
import {
  transformOrganizationCreate,
  transformOrganizationUpdate,
} from "../organization/writes";

export function transformCommentCreate(
  input: FlowCommentWrite,
): Prisma.CommentCreateInput {
  const result: any = {};

  result.content = input.content as any;
  if ("createdAt" in input) {
    result.createdAt = input.createdAt as any;
  }
  if (input.postId !== undefined && input.post === undefined) {
    // Direct foreign key provided - use connect
    result.post = { connect: { id: input.postId } };
  } else if (input.post !== undefined) {
    const rel = input.post;
    const strategy = rel.flowRelationStrategy;
    const data = { ...rel };
    delete data.flowRelationStrategy;

    switch (strategy) {
      case "connect": {
        const where: any = {};
        if (data.id) where.id = data.id;
        result.post = { connect: where };
        break;
      }

      case "create": {
        result.post = { create: transformPostCreate(data) };
        break;
      }

      case "connectOrCreate": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const createData = { ...data };
        delete createData.id;
        result.post = {
          connectOrCreate: {
            where,
            create: transformPostCreate(createData),
          },
        };
        break;
      }

      default: {
        // Smart default based on available fields
        const where: any = {};
        if (data.id) where.id = data.id;

        // Check if we have all required fields for create
        const hasAllRequiredFields = data.title != null;
        if (Object.keys(where).length === 0) {
          // No ID/unique fields - must create
          result.post = { create: transformPostCreate(data) };
        } else if (!hasAllRequiredFields) {
          // Has ID/unique but missing required fields - use connect
          result.post = { connect: where };
        } else {
          // Has ID/unique AND all required fields - use connectOrCreate
          const createData = { ...data };
          delete createData.id;
          result.post = {
            connectOrCreate: {
              where,
              create: transformPostCreate(createData),
            },
          };
        }
      }
    }
  }
  if (input.authorId !== undefined && input.author === undefined) {
    // Direct foreign key provided - use connect
    result.author = { connect: { id: input.authorId } };
  } else if (input.author !== undefined) {
    const rel = input.author;
    const strategy = rel.flowRelationStrategy;
    const data = { ...rel };
    delete data.flowRelationStrategy;

    switch (strategy) {
      case "connect": {
        const where: any = {};
        if (data.id) where.id = data.id;
        if (data.email) where.email = data.email;
        result.author = { connect: where };
        break;
      }

      case "create": {
        result.author = { create: transformAuthorCreate(data) };
        break;
      }

      case "connectOrCreate": {
        const where: any = {};
        if (data.id) where.id = data.id;
        if (data.email) where.email = data.email;
        const createData = { ...data };
        delete createData.id;
        if (where.email) delete createData.email;
        result.author = {
          connectOrCreate: {
            where,
            create: transformAuthorCreate(createData),
          },
        };
        break;
      }

      default: {
        // Smart default based on available fields
        const where: any = {};
        if (data.id) where.id = data.id;
        if (data.email) where.email = data.email;

        // Check if we have all required fields for create
        const hasAllRequiredFields = data.email != null;
        if (Object.keys(where).length === 0) {
          // No ID/unique fields - must create
          result.author = { create: transformAuthorCreate(data) };
        } else if (!hasAllRequiredFields) {
          // Has ID/unique but missing required fields - use connect
          result.author = { connect: where };
        } else {
          // Has ID/unique AND all required fields - use connectOrCreate
          const createData = { ...data };
          delete createData.id;
          if (where.email) delete createData.email;
          result.author = {
            connectOrCreate: {
              where,
              create: transformAuthorCreate(createData),
            },
          };
        }
      }
    }
  }
  if (input.parentId !== undefined && input.parent === undefined) {
    // Direct foreign key provided - use connect
    result.parent = { connect: { id: input.parentId } };
  } else if (input.parent !== undefined) {
    const rel = input.parent;
    const strategy = rel.flowRelationStrategy;
    const data = { ...rel };
    delete data.flowRelationStrategy;

    switch (strategy) {
      case "connect": {
        const where: any = {};
        if (data.id) where.id = data.id;
        result.parent = { connect: where };
        break;
      }

      case "create": {
        result.parent = { create: transformCommentCreate(data) };
        break;
      }

      case "connectOrCreate": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const createData = { ...data };
        delete createData.id;
        result.parent = {
          connectOrCreate: {
            where,
            create: transformCommentCreate(createData),
          },
        };
        break;
      }

      default: {
        // Smart default based on available fields
        const where: any = {};
        if (data.id) where.id = data.id;

        // Check if we have all required fields for create
        const hasAllRequiredFields = data.content != null;
        if (Object.keys(where).length === 0) {
          // No ID/unique fields - must create
          result.parent = { create: transformCommentCreate(data) };
        } else if (!hasAllRequiredFields) {
          // Has ID/unique but missing required fields - use connect
          result.parent = { connect: where };
        } else {
          // Has ID/unique AND all required fields - use connectOrCreate
          const createData = { ...data };
          delete createData.id;
          result.parent = {
            connectOrCreate: {
              where,
              create: transformCommentCreate(createData),
            },
          };
        }
      }
    }
  }
  if (input.replies !== undefined) {
    if (Array.isArray(input.replies)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];

      for (const item of input.replies) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformCommentCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
          }
        }
      }

      result.replies = {};
      if (connects.length) result.replies.connect = connects;
      if (creates.length) result.replies.create = creates;
      if (connectOrCreates.length)
        result.replies.connectOrCreate = connectOrCreates;
    }
  }
  if (input.organizationId !== undefined && input.organization === undefined) {
    // Direct foreign key provided - use connect
    result.organization = { connect: { id: input.organizationId } };
  } else if (input.organization !== undefined) {
    const rel = input.organization;
    const strategy = rel.flowRelationStrategy;
    const data = { ...rel };
    delete data.flowRelationStrategy;

    switch (strategy) {
      case "connect": {
        const where: any = {};
        if (data.id) where.id = data.id;
        result.organization = { connect: where };
        break;
      }

      case "create": {
        result.organization = { create: transformOrganizationCreate(data) };
        break;
      }

      case "connectOrCreate": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const createData = { ...data };
        delete createData.id;
        result.organization = {
          connectOrCreate: {
            where,
            create: transformOrganizationCreate(createData),
          },
        };
        break;
      }

      default: {
        // Smart default based on available fields
        const where: any = {};
        if (data.id) where.id = data.id;

        const hasAllRequiredFields = true; // No required fields

        if (Object.keys(where).length === 0) {
          // No ID/unique fields - must create
          result.organization = { create: transformOrganizationCreate(data) };
        } else if (!hasAllRequiredFields) {
          // Has ID/unique but missing required fields - use connect
          result.organization = { connect: where };
        } else {
          // Has ID/unique AND all required fields - use connectOrCreate
          const createData = { ...data };
          delete createData.id;
          result.organization = {
            connectOrCreate: {
              where,
              create: transformOrganizationCreate(createData),
            },
          };
        }
      }
    }
  }

  return result as Prisma.CommentCreateInput;
}

export function transformCommentUpdate(
  input: Partial<FlowCommentWrite>,
): Prisma.CommentUpdateInput {
  const result: any = {};

  if ("content" in input) {
    result.content = input.content as any;
  }
  if ("createdAt" in input) {
    result.createdAt = input.createdAt as any;
  }
  if (input.postId !== undefined && input.post === undefined) {
    // Direct foreign key provided - use connect
    result.post = { connect: { id: input.postId } };
  } else if (input.post !== undefined) {
    const rel = input.post;
    const strategy = rel.flowRelationStrategy;
    const data = { ...rel };
    delete data.flowRelationStrategy;

    switch (strategy) {
      case "connect": {
        const where: any = {};
        if (data.id) where.id = data.id;
        result.post = { connect: where };
        break;
      }

      case "create": {
        result.post = { create: transformPostCreate(data) };
        break;
      }

      case "connectOrCreate": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const createData = { ...data };
        delete createData.id;
        result.post = {
          connectOrCreate: {
            where,
            create: transformPostCreate(createData),
          },
        };
        break;
      }

      case "update": {
        result.post = { update: transformPostUpdate(data) };
        break;
      }

      case "upsert": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const upsertData = { ...data };
        delete upsertData.id;
        result.post = {
          upsert: {
            where,
            create: transformPostCreate(upsertData),
            update: transformPostUpdate(upsertData),
          },
        };
        break;
      }

      case "disconnect": {
        result.post = { disconnect: true };
        break;
      }

      case "delete": {
        result.post = { delete: true };
        break;
      }

      default: {
        // Smart default based on available fields
        const where: any = {};
        if (data.id) where.id = data.id;

        // Check if we have all required fields for create
        const hasAllRequiredFields = data.title != null;
        if (Object.keys(where).length === 0) {
          // No ID/unique fields - must create
          result.post = { create: transformPostCreate(data) };
        } else if (!hasAllRequiredFields) {
          // Has ID/unique but missing required fields - use connect
          result.post = { connect: where };
        } else {
          // Has ID/unique AND all required fields - use connectOrCreate
          const createData = { ...data };
          delete createData.id;
          result.post = {
            connectOrCreate: {
              where,
              create: transformPostCreate(createData),
            },
          };
        }
      }
    }
  }
  if (input.authorId !== undefined && input.author === undefined) {
    // Direct foreign key provided - use connect
    result.author = { connect: { id: input.authorId } };
  } else if (input.author !== undefined) {
    const rel = input.author;
    const strategy = rel.flowRelationStrategy;
    const data = { ...rel };
    delete data.flowRelationStrategy;

    switch (strategy) {
      case "connect": {
        const where: any = {};
        if (data.id) where.id = data.id;
        if (data.email) where.email = data.email;
        result.author = { connect: where };
        break;
      }

      case "create": {
        result.author = { create: transformAuthorCreate(data) };
        break;
      }

      case "connectOrCreate": {
        const where: any = {};
        if (data.id) where.id = data.id;
        if (data.email) where.email = data.email;
        const createData = { ...data };
        delete createData.id;
        if (where.email) delete createData.email;
        result.author = {
          connectOrCreate: {
            where,
            create: transformAuthorCreate(createData),
          },
        };
        break;
      }

      case "update": {
        result.author = { update: transformAuthorUpdate(data) };
        break;
      }

      case "upsert": {
        const where: any = {};
        if (data.id) where.id = data.id;
        if (data.email) where.email = data.email;
        const upsertData = { ...data };
        delete upsertData.id;
        result.author = {
          upsert: {
            where,
            create: transformAuthorCreate(upsertData),
            update: transformAuthorUpdate(upsertData),
          },
        };
        break;
      }

      case "disconnect": {
        result.author = { disconnect: true };
        break;
      }

      case "delete": {
        result.author = { delete: true };
        break;
      }

      default: {
        // Smart default based on available fields
        const where: any = {};
        if (data.id) where.id = data.id;
        if (data.email) where.email = data.email;

        // Check if we have all required fields for create
        const hasAllRequiredFields = data.email != null;
        if (Object.keys(where).length === 0) {
          // No ID/unique fields - must create
          result.author = { create: transformAuthorCreate(data) };
        } else if (!hasAllRequiredFields) {
          // Has ID/unique but missing required fields - use connect
          result.author = { connect: where };
        } else {
          // Has ID/unique AND all required fields - use connectOrCreate
          const createData = { ...data };
          delete createData.id;
          if (where.email) delete createData.email;
          result.author = {
            connectOrCreate: {
              where,
              create: transformAuthorCreate(createData),
            },
          };
        }
      }
    }
  }
  if (input.parentId !== undefined && input.parent === undefined) {
    // Direct foreign key provided - use connect
    result.parent = { connect: { id: input.parentId } };
  } else if (input.parent !== undefined) {
    const rel = input.parent;
    const strategy = rel.flowRelationStrategy;
    const data = { ...rel };
    delete data.flowRelationStrategy;

    switch (strategy) {
      case "connect": {
        const where: any = {};
        if (data.id) where.id = data.id;
        result.parent = { connect: where };
        break;
      }

      case "create": {
        result.parent = { create: transformCommentCreate(data) };
        break;
      }

      case "connectOrCreate": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const createData = { ...data };
        delete createData.id;
        result.parent = {
          connectOrCreate: {
            where,
            create: transformCommentCreate(createData),
          },
        };
        break;
      }

      case "update": {
        result.parent = { update: transformCommentUpdate(data) };
        break;
      }

      case "upsert": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const upsertData = { ...data };
        delete upsertData.id;
        result.parent = {
          upsert: {
            where,
            create: transformCommentCreate(upsertData),
            update: transformCommentUpdate(upsertData),
          },
        };
        break;
      }

      case "disconnect": {
        result.parent = { disconnect: true };
        break;
      }

      case "delete": {
        result.parent = { delete: true };
        break;
      }

      default: {
        // Smart default based on available fields
        const where: any = {};
        if (data.id) where.id = data.id;

        // Check if we have all required fields for create
        const hasAllRequiredFields = data.content != null;
        if (Object.keys(where).length === 0) {
          // No ID/unique fields - must create
          result.parent = { create: transformCommentCreate(data) };
        } else if (!hasAllRequiredFields) {
          // Has ID/unique but missing required fields - use connect
          result.parent = { connect: where };
        } else {
          // Has ID/unique AND all required fields - use connectOrCreate
          const createData = { ...data };
          delete createData.id;
          result.parent = {
            connectOrCreate: {
              where,
              create: transformCommentCreate(createData),
            },
          };
        }
      }
    }
  }
  if (input.replies !== undefined) {
    if (Array.isArray(input.replies)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];
      const updates: any[] = [];
      const upserts: any[] = [];
      const deletes: any[] = [];
      let hasSet = false;

      for (const item of input.replies) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformCommentCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
            break;
          }

          case "update": {
            const where: any = {};
            if (data.id) where.id = data.id;
            updates.push({
              where,
              data: transformCommentUpdate(data),
            });
            break;
          }

          case "set": {
            hasSet = true;
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "delete": {
            const where: any = {};
            if (data.id) where.id = data.id;
            deletes.push(where);
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
          }
        }
      }

      result.replies = {};
      if (hasSet) result.replies.set = connects;
      else {
        if (connects.length) result.replies.connect = connects;
        if (creates.length) result.replies.create = creates;
        if (connectOrCreates.length)
          result.replies.connectOrCreate = connectOrCreates;
        if (updates.length) result.replies.updateMany = updates;
        if (deletes.length) result.replies.deleteMany = deletes;
      }
    }
  }
  if (input.organizationId !== undefined && input.organization === undefined) {
    // Direct foreign key provided - use connect
    result.organization = { connect: { id: input.organizationId } };
  } else if (input.organization !== undefined) {
    const rel = input.organization;
    const strategy = rel.flowRelationStrategy;
    const data = { ...rel };
    delete data.flowRelationStrategy;

    switch (strategy) {
      case "connect": {
        const where: any = {};
        if (data.id) where.id = data.id;
        result.organization = { connect: where };
        break;
      }

      case "create": {
        result.organization = { create: transformOrganizationCreate(data) };
        break;
      }

      case "connectOrCreate": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const createData = { ...data };
        delete createData.id;
        result.organization = {
          connectOrCreate: {
            where,
            create: transformOrganizationCreate(createData),
          },
        };
        break;
      }

      case "update": {
        result.organization = { update: transformOrganizationUpdate(data) };
        break;
      }

      case "upsert": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const upsertData = { ...data };
        delete upsertData.id;
        result.organization = {
          upsert: {
            where,
            create: transformOrganizationCreate(upsertData),
            update: transformOrganizationUpdate(upsertData),
          },
        };
        break;
      }

      case "disconnect": {
        result.organization = { disconnect: true };
        break;
      }

      case "delete": {
        result.organization = { delete: true };
        break;
      }

      default: {
        // Smart default based on available fields
        const where: any = {};
        if (data.id) where.id = data.id;

        const hasAllRequiredFields = true; // No required fields

        if (Object.keys(where).length === 0) {
          // No ID/unique fields - must create
          result.organization = { create: transformOrganizationCreate(data) };
        } else if (!hasAllRequiredFields) {
          // Has ID/unique but missing required fields - use connect
          result.organization = { connect: where };
        } else {
          // Has ID/unique AND all required fields - use connectOrCreate
          const createData = { ...data };
          delete createData.id;
          result.organization = {
            connectOrCreate: {
              where,
              create: transformOrganizationCreate(createData),
            },
          };
        }
      }
    }
  }

  return result as Prisma.CommentUpdateInput;
}
