// @generated by next-prisma-flow-state-engine
// file: actions.server.ts

"use server";

import { prisma } from "../../../lib/prisma";
import { z } from "zod";
import { invalidateTags, keys, FlowCtx } from "../core";
import { canOrganization } from "../policies";
import { OrganizationDeepSelect } from "./selects";
import { OrganizationCreateSchema, OrganizationUpdateSchema } from "./zod";
import type { FlowOrganizationCreate, FlowOrganizationUpdate } from "./zod";
import {
  transformOrganizationCreate,
  transformOrganizationUpdate,
} from "./writes";

export async function createOrganization(
  data: FlowOrganizationCreate,
  ctx: FlowCtx,
) {
  const policy = await canOrganization("create", ctx);
  if (!policy.ok) return { ok: false, error: policy.message };

  const parsed = OrganizationCreateSchema.safeParse(data);
  if (!parsed.success) {
    return { ok: false, error: "Invalid data", issues: parsed.error.issues };
  }

  try {
    const createData = transformOrganizationCreate(parsed.data as any);
    const item = await prisma.organization.create({
      data: { ...createData, ...policy.data },
      select: OrganizationDeepSelect,
    });

    await invalidateTags([keys.m("Organization").tag()]);
    return { ok: true, data: item };
  } catch (error) {
    console.error("Error creating Organization:", error);
    return { ok: false, error: "Failed to create" };
  }
}

export async function updateOrganization(
  id: string,
  data: FlowOrganizationUpdate,
  ctx: FlowCtx,
) {
  const policy = await canOrganization("update", ctx, id);
  if (!policy.ok) return { ok: false, error: policy.message };

  // Validate update payload against UpdateSchema (all fields optional)
  const parsedUpdate = OrganizationUpdateSchema.safeParse(data);
  if (!parsedUpdate.success) {
    return {
      ok: false,
      error: "Invalid data",
      issues: parsedUpdate.error.issues,
    };
  }
  try {
    const updateData = transformOrganizationUpdate(parsedUpdate.data as any);
    const item = await prisma.organization.update({
      where: { id: id, ...policy.where },
      data: { ...updateData, ...policy.data },
      select: OrganizationDeepSelect,
    });

    await invalidateTags([
      keys.m("Organization").tag(),
      keys.m("Organization").tag(String(id)),
    ]);
    return { ok: true, data: item };
  } catch (error) {
    console.error("Error updating Organization:", error);
    return { ok: false, error: "Failed to update" };
  }
}

export async function deleteOrganization(id: string, ctx: FlowCtx) {
  const policy = await canOrganization("delete", ctx, id);
  if (!policy.ok) return { ok: false, error: policy.message };

  try {
    await prisma.organization.delete({
      where: { id: id, ...policy.where },
    });

    await invalidateTags([
      keys.m("Organization").tag(),
      keys.m("Organization").tag(String(id)),
    ]);
    return { ok: true };
  } catch (error) {
    console.error("Error deleting Organization:", error);
    return { ok: false, error: "Failed to delete" };
  }
}
