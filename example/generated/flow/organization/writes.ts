// @generated by next-prisma-flow-state-engine
// file: writes.ts

import type { Prisma } from "@prisma/client";
import type { FlowOrganizationWrite } from "./zod";
import { transformAuthorCreate, transformAuthorUpdate } from "../author/writes";
import { transformPostCreate, transformPostUpdate } from "../post/writes";
import {
  transformCommentCreate,
  transformCommentUpdate,
} from "../comment/writes";
import { transformTagCreate, transformTagUpdate } from "../tag/writes";

export function transformOrganizationCreate(
  input: FlowOrganizationWrite,
): Prisma.OrganizationCreateInput {
  const result: any = {};

  if ("name" in input) {
    result.name = input.name as any;
  }
  if ("createdAt" in input) {
    result.createdAt = input.createdAt as any;
  }
  if (input.authors !== undefined) {
    if (Array.isArray(input.authors)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];

      for (const item of input.authors) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.email) where.email = data.email;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformAuthorCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.email) where.email = data.email;
            const createData = { ...data };
            delete createData.id;
            if (where.email) delete createData.email;
            connectOrCreates.push({
              where,
              create: transformAuthorCreate(createData),
            });
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.email) where.email = data.email;
            const createData = { ...data };
            delete createData.id;
            if (where.email) delete createData.email;
            connectOrCreates.push({
              where,
              create: transformAuthorCreate(createData),
            });
          }
        }
      }

      result.authors = {};
      if (connects.length) result.authors.connect = connects;
      if (creates.length) result.authors.create = creates;
      if (connectOrCreates.length)
        result.authors.connectOrCreate = connectOrCreates;
    }
  }
  if (input.posts !== undefined) {
    if (Array.isArray(input.posts)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];

      for (const item of input.posts) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformPostCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformPostCreate(createData),
            });
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformPostCreate(createData),
            });
          }
        }
      }

      result.posts = {};
      if (connects.length) result.posts.connect = connects;
      if (creates.length) result.posts.create = creates;
      if (connectOrCreates.length)
        result.posts.connectOrCreate = connectOrCreates;
    }
  }
  if (input.comments !== undefined) {
    if (Array.isArray(input.comments)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];

      for (const item of input.comments) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformCommentCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
          }
        }
      }

      result.comments = {};
      if (connects.length) result.comments.connect = connects;
      if (creates.length) result.comments.create = creates;
      if (connectOrCreates.length)
        result.comments.connectOrCreate = connectOrCreates;
    }
  }
  if (input.tags !== undefined) {
    if (Array.isArray(input.tags)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];

      for (const item of input.tags) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.name) where.name = data.name;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformTagCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.name) where.name = data.name;
            const createData = { ...data };
            delete createData.id;
            if (where.name) delete createData.name;
            connectOrCreates.push({
              where,
              create: transformTagCreate(createData),
            });
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.name) where.name = data.name;
            const createData = { ...data };
            delete createData.id;
            if (where.name) delete createData.name;
            connectOrCreates.push({
              where,
              create: transformTagCreate(createData),
            });
          }
        }
      }

      result.tags = {};
      if (connects.length) result.tags.connect = connects;
      if (creates.length) result.tags.create = creates;
      if (connectOrCreates.length)
        result.tags.connectOrCreate = connectOrCreates;
    }
  }

  return result as Prisma.OrganizationCreateInput;
}

export function transformOrganizationUpdate(
  input: Partial<FlowOrganizationWrite>,
): Prisma.OrganizationUpdateInput {
  const result: any = {};

  if ("name" in input) {
    result.name = input.name as any;
  }
  if ("createdAt" in input) {
    result.createdAt = input.createdAt as any;
  }
  if (input.authors !== undefined) {
    if (Array.isArray(input.authors)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];
      const updates: any[] = [];
      const upserts: any[] = [];
      const deletes: any[] = [];
      let hasSet = false;

      for (const item of input.authors) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.email) where.email = data.email;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformAuthorCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.email) where.email = data.email;
            const createData = { ...data };
            delete createData.id;
            if (where.email) delete createData.email;
            connectOrCreates.push({
              where,
              create: transformAuthorCreate(createData),
            });
            break;
          }

          case "update": {
            const where: any = {};
            if (data.id) where.id = data.id;
            updates.push({
              where,
              data: transformAuthorUpdate(data),
            });
            break;
          }

          case "set": {
            hasSet = true;
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.email) where.email = data.email;
            connects.push(where);
            break;
          }

          case "delete": {
            const where: any = {};
            if (data.id) where.id = data.id;
            deletes.push(where);
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.email) where.email = data.email;
            const createData = { ...data };
            delete createData.id;
            if (where.email) delete createData.email;
            connectOrCreates.push({
              where,
              create: transformAuthorCreate(createData),
            });
          }
        }
      }

      result.authors = {};
      if (hasSet) result.authors.set = connects;
      else {
        if (connects.length) result.authors.connect = connects;
        if (creates.length) result.authors.create = creates;
        if (connectOrCreates.length)
          result.authors.connectOrCreate = connectOrCreates;
        if (updates.length) result.authors.updateMany = updates;
        if (deletes.length) result.authors.deleteMany = deletes;
      }
    }
  }
  if (input.posts !== undefined) {
    if (Array.isArray(input.posts)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];
      const updates: any[] = [];
      const upserts: any[] = [];
      const deletes: any[] = [];
      let hasSet = false;

      for (const item of input.posts) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformPostCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformPostCreate(createData),
            });
            break;
          }

          case "update": {
            const where: any = {};
            if (data.id) where.id = data.id;
            updates.push({
              where,
              data: transformPostUpdate(data),
            });
            break;
          }

          case "set": {
            hasSet = true;
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "delete": {
            const where: any = {};
            if (data.id) where.id = data.id;
            deletes.push(where);
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformPostCreate(createData),
            });
          }
        }
      }

      result.posts = {};
      if (hasSet) result.posts.set = connects;
      else {
        if (connects.length) result.posts.connect = connects;
        if (creates.length) result.posts.create = creates;
        if (connectOrCreates.length)
          result.posts.connectOrCreate = connectOrCreates;
        if (updates.length) result.posts.updateMany = updates;
        if (deletes.length) result.posts.deleteMany = deletes;
      }
    }
  }
  if (input.comments !== undefined) {
    if (Array.isArray(input.comments)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];
      const updates: any[] = [];
      const upserts: any[] = [];
      const deletes: any[] = [];
      let hasSet = false;

      for (const item of input.comments) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformCommentCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
            break;
          }

          case "update": {
            const where: any = {};
            if (data.id) where.id = data.id;
            updates.push({
              where,
              data: transformCommentUpdate(data),
            });
            break;
          }

          case "set": {
            hasSet = true;
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "delete": {
            const where: any = {};
            if (data.id) where.id = data.id;
            deletes.push(where);
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
          }
        }
      }

      result.comments = {};
      if (hasSet) result.comments.set = connects;
      else {
        if (connects.length) result.comments.connect = connects;
        if (creates.length) result.comments.create = creates;
        if (connectOrCreates.length)
          result.comments.connectOrCreate = connectOrCreates;
        if (updates.length) result.comments.updateMany = updates;
        if (deletes.length) result.comments.deleteMany = deletes;
      }
    }
  }
  if (input.tags !== undefined) {
    if (Array.isArray(input.tags)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];
      const updates: any[] = [];
      const upserts: any[] = [];
      const deletes: any[] = [];
      let hasSet = false;

      for (const item of input.tags) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.name) where.name = data.name;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformTagCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.name) where.name = data.name;
            const createData = { ...data };
            delete createData.id;
            if (where.name) delete createData.name;
            connectOrCreates.push({
              where,
              create: transformTagCreate(createData),
            });
            break;
          }

          case "update": {
            const where: any = {};
            if (data.id) where.id = data.id;
            updates.push({
              where,
              data: transformTagUpdate(data),
            });
            break;
          }

          case "set": {
            hasSet = true;
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.name) where.name = data.name;
            connects.push(where);
            break;
          }

          case "delete": {
            const where: any = {};
            if (data.id) where.id = data.id;
            deletes.push(where);
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            if (data.name) where.name = data.name;
            const createData = { ...data };
            delete createData.id;
            if (where.name) delete createData.name;
            connectOrCreates.push({
              where,
              create: transformTagCreate(createData),
            });
          }
        }
      }

      result.tags = {};
      if (hasSet) result.tags.set = connects;
      else {
        if (connects.length) result.tags.connect = connects;
        if (creates.length) result.tags.create = creates;
        if (connectOrCreates.length)
          result.tags.connectOrCreate = connectOrCreates;
        if (updates.length) result.tags.updateMany = updates;
        if (deletes.length) result.tags.deleteMany = deletes;
      }
    }
  }

  return result as Prisma.OrganizationUpdateInput;
}
