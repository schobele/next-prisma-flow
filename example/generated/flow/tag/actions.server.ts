// @generated by next-prisma-flow-state-engine
// file: actions.server.ts

"use server";

import { prisma } from "../../../lib/prisma";
import { z } from "zod";
import { invalidateTags, keys, FlowCtx } from "../core";
import { canTag } from "../policies";
import { TagDeepSelect } from "./selects";
import { TagCreateSchema, TagUpdateSchema } from "./zod";
import type { FlowTagCreate, FlowTagUpdate } from "./zod";
import { transformTagCreate, transformTagUpdate } from "./writes";

export async function createTag(data: FlowTagCreate, ctx: FlowCtx) {
  const policy = await canTag("create", ctx);
  if (!policy.ok) return { ok: false, error: policy.message };

  const parsed = TagCreateSchema.safeParse(data);
  if (!parsed.success) {
    return { ok: false, error: "Invalid data", issues: parsed.error.issues };
  }

  try {
    const createData = transformTagCreate(parsed.data as any);
    const item = await prisma.tag.create({
      data: { ...createData, ...policy.data },
      select: TagDeepSelect,
    });

    await invalidateTags([keys.m("Tag").tag()]);
    return { ok: true, data: item };
  } catch (error) {
    console.error("Error creating Tag:", error);
    return { ok: false, error: "Failed to create" };
  }
}

export async function updateTag(id: string, data: FlowTagUpdate, ctx: FlowCtx) {
  const policy = await canTag("update", ctx, id);
  if (!policy.ok) return { ok: false, error: policy.message };

  // Validate update payload against UpdateSchema (all fields optional)
  const parsedUpdate = TagUpdateSchema.safeParse(data);
  if (!parsedUpdate.success) {
    return {
      ok: false,
      error: "Invalid data",
      issues: parsedUpdate.error.issues,
    };
  }
  try {
    const updateData = transformTagUpdate(parsedUpdate.data as any);
    const item = await prisma.tag.update({
      where: { id: id, ...policy.where },
      data: { ...updateData, ...policy.data },
      select: TagDeepSelect,
    });

    await invalidateTags([keys.m("Tag").tag(), keys.m("Tag").tag(String(id))]);
    return { ok: true, data: item };
  } catch (error) {
    console.error("Error updating Tag:", error);
    return { ok: false, error: "Failed to update" };
  }
}

export async function deleteTag(id: string, ctx: FlowCtx) {
  const policy = await canTag("delete", ctx, id);
  if (!policy.ok) return { ok: false, error: policy.message };

  try {
    await prisma.tag.delete({
      where: { id: id, ...policy.where },
    });

    await invalidateTags([keys.m("Tag").tag(), keys.m("Tag").tag(String(id))]);
    return { ok: true };
  } catch (error) {
    console.error("Error deleting Tag:", error);
    return { ok: false, error: "Failed to delete" };
  }
}
