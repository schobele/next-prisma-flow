// @generated by next-prisma-flow-state-engine
// file: forms.ts

"use client";

import { useCallback, useEffect, useRef, useState } from "react";
import { z } from "zod";
import { useForm, UseFormReturn, UseFormProps } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { TagCreateSchema, TagUpdateSchema } from "./zod";
import type { FlowTagWrite, FlowTagCreate, FlowTagUpdate } from "./zod";
import { useCreateTag, useUpdateTag } from "./hooks";

export function useTagForm(params?: {
  id?: string;
  mode?: "create" | "update";
  defaultValues?: Partial<FlowTagCreate> | Partial<FlowTagUpdate>;
  form?: Omit<UseFormProps<FlowTagWrite>, "resolver" | "defaultValues">;
  autosave?: boolean | { debounceMs?: number };
}) {
  const mode = params?.mode || "create";
  const id = params?.id as string | undefined;
  // Use mode-specific schemas for better client-side validation

  const schema =
    mode === "create"
      ? z.object({
          flowWriteMode: z.literal("create"),
          ...TagCreateSchema.shape,
        })
      : z.object({
          flowWriteMode: z.literal("update"),
          ...TagUpdateSchema.shape,
        });
  const refinedSchema = schema;
  const userFormOpts = params?.form || {};
  const normalizedFormOpts = {
    mode: (userFormOpts as any).mode ?? "all",
    ...userFormOpts,
  } as any;
  const mergedDefaults: any = {
    ...(normalizedFormOpts as any).defaultValues,
    ...(params?.defaultValues || {}),
  };
  mergedDefaults.flowWriteMode = mode;
  const form = useForm<FlowTagWrite>({
    ...normalizedFormOpts,
    resolver: zodResolver(refinedSchema),
    defaultValues: mergedDefaults,
  });
  const [serverError, setServerError] = useState<string | null>(null);
  const autosaveTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const createMutation = useCreateTag();
  const updateMutation = id ? useUpdateTag(id) : null;

  const onSubmit = useCallback(
    async (data: FlowTagWrite) => {
      try {
        setServerError(null);
        if (mode === "update" && updateMutation) {
          await updateMutation.mutateAsync(data);
        } else {
          await createMutation.mutateAsync(data);
        }
        form.reset();
      } catch (error: any) {
        console.error("Form submission error:", error);
        const msg =
          typeof error?.error === "string"
            ? error.error
            : error?.message || "Request failed";
        setServerError(msg);
      }
    },
    [mode, createMutation, updateMutation, form],
  );

  // Autosave support
  useEffect(() => {
    const enabled = !!params?.autosave;
    if (!enabled) return;
    const debounceMs =
      typeof params?.autosave === "object"
        ? (params!.autosave!.debounceMs ?? 600)
        : 600;
    const subscription = form.watch(() => {
      const hasTouched =
        Object.keys(form.formState.touchedFields || {}).length > 0;
      if (!hasTouched || !form.formState.isValid) return;
      if (autosaveTimerRef.current) clearTimeout(autosaveTimerRef.current);
      autosaveTimerRef.current = setTimeout(() => {
        form.handleSubmit(onSubmit as any)();
      }, debounceMs);
    });
    return () => {
      (subscription as any)?.unsubscribe?.();
      if (autosaveTimerRef.current) clearTimeout(autosaveTimerRef.current);
    };
  }, [form, onSubmit, params?.autosave]);

  return {
    form,
    onSubmit,
    isSubmitting:
      createMutation.isPending || (updateMutation?.isPending ?? false),
    mode,
    serverError,
  };
}

export type TagFormReturn = ReturnType<typeof useTagForm>;
