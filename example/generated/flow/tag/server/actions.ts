// @generated by next-prisma-flow-state-engine
// file: server/actions.ts

"use server";

import { prisma } from "../../prisma";
import {
  invalidateTags,
  keys,
  FlowCtx,
  FlowPolicyError,
  FlowValidationError,
} from "../../core";
import { canTag } from "../../policies";
import { TagDeepSelect } from "./selects";
import { TagCreateSchema, TagUpdateSchema } from "../types/schemas";
import type { FlowTagCreate, FlowTagUpdate } from "../types/schemas";
import { transformTagCreate, transformTagUpdate } from "../types/transforms";

// Transform Prisma response to match FlowPost schema (null -> undefined for relations)
function transformResponse(item: any): any {
  if (!item) return item;
  const result = { ...item };
  if (result.organization === null) result.organization = undefined;
  return result;
}

export async function createTag(data: FlowTagCreate, ctx: FlowCtx = {}) {
  const policy = await canTag("create", ctx || {});
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  const parsed = TagCreateSchema.safeParse(data);
  if (!parsed.success) {
    throw new FlowValidationError(parsed.error.issues);
  }

  const createData = transformTagCreate(parsed.data as any);
  const item = await prisma.tag.create({
    data: { ...createData, ...policy.data },
    select: TagDeepSelect,
  });

  await invalidateTags([keys.m("Tag").tag()]);
  return transformResponse(item);
}

export async function updateTag(
  id: string,
  data: FlowTagUpdate,
  ctx: FlowCtx = {},
) {
  const policy = await canTag("update", ctx || {}, id);
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  const parsed = TagUpdateSchema.safeParse(data);
  if (!parsed.success) {
    throw new FlowValidationError(parsed.error.issues);
  }

  const updateData = transformTagUpdate(parsed.data as any);
  const item = await prisma.tag.update({
    where: { id: id, ...policy.where },
    data: { ...updateData, ...policy.data },
    select: TagDeepSelect,
  });

  await invalidateTags([keys.m("Tag").tag(), keys.m("Tag").tag(String(id))]);
  return transformResponse(item);
}

export async function deleteTag(id: string, ctx?: FlowCtx) {
  const policy = await canTag("delete", ctx || {}, id);
  if (!policy.ok) throw new FlowPolicyError(policy.message);

  await prisma.tag.delete({
    where: { id: id, ...policy.where },
  });

  await invalidateTags([keys.m("Tag").tag(), keys.m("Tag").tag(String(id))]);
}
