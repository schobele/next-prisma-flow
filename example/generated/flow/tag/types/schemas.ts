// @generated by next-prisma-flow-state-engine
// file: types/schemas.ts

import { z } from "zod";

// Scalar fields only
export const TagScalarSchema = z.object({
  id: z.string(),
  name: z.string(),
  createdAt: z.date(),
  organizationId: z.string().optional().nullable(),
});

// Relation schemas
// Main schema with relations
export const TagSchema = TagScalarSchema;

// Input schemas for create operations
export const TagCreateSchema = z.object({
  id: z.string().optional(),
  name: z.string(),
  createdAt: z.date().optional(),
});

export const TagCreateManyInputSchema = z.object({
  id: z.string().optional(),
  name: z.string(),
  createdAt: z.date().optional(),
});

// Input schemas for update operations
export const TagUpdateSchema = z.object({
  name: z.string().optional(),
  createdAt: z.date().optional().nullable(),
});

export const TagUpdateManyInputSchema = z.object({
  name: z.string().optional().nullable(),
  createdAt: z.date().optional().nullable(),
});

export const TagUpsertInputSchema = z.object({
  create: TagCreateSchema,
  update: TagUpdateSchema,
});

// Filter and where schemas
// Base filter schema
export const TagFilterBaseSchema = z.object({
  id: z
    .union([
      z.string(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  name: z
    .union([
      z.string(),
      z.object({
        equals: z.string().optional(),
        contains: z.string().optional(),
        startsWith: z.string().optional(),
        endsWith: z.string().optional(),
        in: z.array(z.string()).optional(),
        notIn: z.array(z.string()).optional(),
        not: z.string().optional(),
      }),
    ])
    .optional(),
  createdAt: z
    .union([
      z.date(),
      z.object({
        equals: z.date().optional(),
        lt: z.date().optional(),
        lte: z.date().optional(),
        gt: z.date().optional(),
        gte: z.date().optional(),
        in: z.array(z.date()).optional(),
        notIn: z.array(z.date()).optional(),
        not: z.date().optional(),
      }),
    ])
    .optional(),
  AND: z.union([z.any(), z.array(z.any())]).optional(),
  OR: z.array(z.any()).optional(),
  NOT: z.union([z.any(), z.array(z.any())]).optional(),
});

// Extended filter schema with self-references
export const TagFilterSchema = TagFilterBaseSchema.extend({
  AND: z.array(TagFilterBaseSchema).optional(),
  OR: z.array(TagFilterBaseSchema).optional(),
  NOT: TagFilterBaseSchema.optional(),
});

// Alias for Prisma compatibility
export const TagWhereInputSchema = TagFilterSchema;

export const TagWhereUniqueInputSchema = z.object({
  id: z.string().optional(),
  name: z.string().optional(),
});

// Type exports
export type FlowTag = z.infer<typeof TagSchema>;
export type FlowTagCreate = z.infer<typeof TagCreateSchema>;
export type FlowTagUpdate = z.infer<typeof TagUpdateSchema>;
export type FlowTagFilter = z.infer<typeof TagFilterSchema>;
export type FlowTagWhere = z.infer<typeof TagWhereInputSchema>;
export type FlowTagWhereUnique = z.infer<typeof TagWhereUniqueInputSchema>;
