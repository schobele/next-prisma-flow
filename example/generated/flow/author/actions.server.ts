// @generated by next-prisma-flow-state-engine
// file: actions.server.ts

"use server";

import { prisma } from "../../../lib/prisma";
import { z } from "zod";
import { invalidateTags, keys, FlowCtx } from "../core";
import { canAuthor } from "../policies";
import { AuthorDeepSelect } from "./selects";
import { AuthorCreateSchema, AuthorUpdateSchema } from "./zod";
import type { FlowAuthorCreate, FlowAuthorUpdate } from "./zod";
import { transformAuthorCreate, transformAuthorUpdate } from "./writes";

export async function createAuthor(data: FlowAuthorCreate, ctx: FlowCtx) {
  const policy = await canAuthor("create", ctx);
  if (!policy.ok) return { ok: false, error: policy.message };

  const parsed = AuthorCreateSchema.safeParse(data);
  if (!parsed.success) {
    return { ok: false, error: "Invalid data", issues: parsed.error.issues };
  }

  try {
    const createData = transformAuthorCreate(parsed.data as any);
    const item = await prisma.author.create({
      data: { ...createData, ...policy.data },
      select: AuthorDeepSelect,
    });

    await invalidateTags([keys.m("Author").tag()]);
    return { ok: true, data: item };
  } catch (error) {
    console.error("Error creating Author:", error);
    return { ok: false, error: "Failed to create" };
  }
}

export async function updateAuthor(
  id: string,
  data: FlowAuthorUpdate,
  ctx: FlowCtx,
) {
  const policy = await canAuthor("update", ctx, id);
  if (!policy.ok) return { ok: false, error: policy.message };

  // Validate update payload against UpdateSchema (all fields optional)
  const parsedUpdate = AuthorUpdateSchema.safeParse(data);
  if (!parsedUpdate.success) {
    return {
      ok: false,
      error: "Invalid data",
      issues: parsedUpdate.error.issues,
    };
  }
  try {
    const updateData = transformAuthorUpdate(parsedUpdate.data as any);
    const item = await prisma.author.update({
      where: { id: id, ...policy.where },
      data: { ...updateData, ...policy.data },
      select: AuthorDeepSelect,
    });

    await invalidateTags([
      keys.m("Author").tag(),
      keys.m("Author").tag(String(id)),
    ]);
    return { ok: true, data: item };
  } catch (error) {
    console.error("Error updating Author:", error);
    return { ok: false, error: "Failed to update" };
  }
}

export async function deleteAuthor(id: string, ctx: FlowCtx) {
  const policy = await canAuthor("delete", ctx, id);
  if (!policy.ok) return { ok: false, error: policy.message };

  try {
    await prisma.author.delete({
      where: { id: id, ...policy.where },
    });

    await invalidateTags([
      keys.m("Author").tag(),
      keys.m("Author").tag(String(id)),
    ]);
    return { ok: true };
  } catch (error) {
    console.error("Error deleting Author:", error);
    return { ok: false, error: "Failed to delete" };
  }
}
