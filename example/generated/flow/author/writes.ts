// @generated by next-prisma-flow-state-engine
// file: writes.ts

import type { Prisma } from "@prisma/client";
import type { FlowAuthorWrite } from "./zod";
import { transformPostCreate, transformPostUpdate } from "../post/writes";
import {
  transformCommentCreate,
  transformCommentUpdate,
} from "../comment/writes";
import {
  transformOrganizationCreate,
  transformOrganizationUpdate,
} from "../organization/writes";

export function transformAuthorCreate(
  input: FlowAuthorWrite,
): Prisma.AuthorCreateInput {
  const result: any = {};

  result.email = input.email as any;
  if ("name" in input) {
    result.name = input.name as any;
  }
  if ("bio" in input) {
    result.bio = input.bio as any;
  }
  if ("createdAt" in input) {
    result.createdAt = input.createdAt as any;
  }
  if (input.posts !== undefined) {
    if (Array.isArray(input.posts)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];

      for (const item of input.posts) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformPostCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformPostCreate(createData),
            });
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformPostCreate(createData),
            });
          }
        }
      }

      result.posts = {};
      if (connects.length) result.posts.connect = connects;
      if (creates.length) result.posts.create = creates;
      if (connectOrCreates.length)
        result.posts.connectOrCreate = connectOrCreates;
    }
  }
  if (input.comments !== undefined) {
    if (Array.isArray(input.comments)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];

      for (const item of input.comments) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformCommentCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
          }
        }
      }

      result.comments = {};
      if (connects.length) result.comments.connect = connects;
      if (creates.length) result.comments.create = creates;
      if (connectOrCreates.length)
        result.comments.connectOrCreate = connectOrCreates;
    }
  }
  if (input.organizationId !== undefined && input.organization === undefined) {
    // Direct foreign key provided - use connect
    result.organization = { connect: { id: input.organizationId } };
  } else if (input.organization !== undefined) {
    const rel = input.organization;
    const strategy = rel.flowRelationStrategy;
    const data = { ...rel };
    delete data.flowRelationStrategy;

    switch (strategy) {
      case "connect": {
        const where: any = {};
        if (data.id) where.id = data.id;
        result.organization = { connect: where };
        break;
      }

      case "create": {
        result.organization = { create: transformOrganizationCreate(data) };
        break;
      }

      case "connectOrCreate": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const createData = { ...data };
        delete createData.id;
        result.organization = {
          connectOrCreate: {
            where,
            create: transformOrganizationCreate(createData),
          },
        };
        break;
      }

      default: {
        // Smart default based on available fields
        const where: any = {};
        if (data.id) where.id = data.id;

        const hasAllRequiredFields = true; // No required fields

        if (Object.keys(where).length === 0) {
          // No ID/unique fields - must create
          result.organization = { create: transformOrganizationCreate(data) };
        } else if (!hasAllRequiredFields) {
          // Has ID/unique but missing required fields - use connect
          result.organization = { connect: where };
        } else {
          // Has ID/unique AND all required fields - use connectOrCreate
          const createData = { ...data };
          delete createData.id;
          result.organization = {
            connectOrCreate: {
              where,
              create: transformOrganizationCreate(createData),
            },
          };
        }
      }
    }
  }

  return result as Prisma.AuthorCreateInput;
}

export function transformAuthorUpdate(
  input: Partial<FlowAuthorWrite>,
): Prisma.AuthorUpdateInput {
  const result: any = {};

  if ("email" in input) {
    result.email = input.email as any;
  }
  if ("name" in input) {
    result.name = input.name as any;
  }
  if ("bio" in input) {
    result.bio = input.bio as any;
  }
  if ("createdAt" in input) {
    result.createdAt = input.createdAt as any;
  }
  if (input.posts !== undefined) {
    if (Array.isArray(input.posts)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];
      const updates: any[] = [];
      const upserts: any[] = [];
      const deletes: any[] = [];
      let hasSet = false;

      for (const item of input.posts) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformPostCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformPostCreate(createData),
            });
            break;
          }

          case "update": {
            const where: any = {};
            if (data.id) where.id = data.id;
            updates.push({
              where,
              data: transformPostUpdate(data),
            });
            break;
          }

          case "set": {
            hasSet = true;
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "delete": {
            const where: any = {};
            if (data.id) where.id = data.id;
            deletes.push(where);
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformPostCreate(createData),
            });
          }
        }
      }

      result.posts = {};
      if (hasSet) result.posts.set = connects;
      else {
        if (connects.length) result.posts.connect = connects;
        if (creates.length) result.posts.create = creates;
        if (connectOrCreates.length)
          result.posts.connectOrCreate = connectOrCreates;
        if (updates.length) result.posts.updateMany = updates;
        if (deletes.length) result.posts.deleteMany = deletes;
      }
    }
  }
  if (input.comments !== undefined) {
    if (Array.isArray(input.comments)) {
      const connects: any[] = [];
      const creates: any[] = [];
      const connectOrCreates: any[] = [];
      const updates: any[] = [];
      const upserts: any[] = [];
      const deletes: any[] = [];
      let hasSet = false;

      for (const item of input.comments) {
        const strategy = item.flowRelationStrategy;
        const data = { ...item };
        delete data.flowRelationStrategy;

        switch (strategy) {
          case "connect": {
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "create": {
            creates.push(transformCommentCreate(data));
            break;
          }

          case "connectOrCreate": {
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
            break;
          }

          case "update": {
            const where: any = {};
            if (data.id) where.id = data.id;
            updates.push({
              where,
              data: transformCommentUpdate(data),
            });
            break;
          }

          case "set": {
            hasSet = true;
            const where: any = {};
            if (data.id) where.id = data.id;
            connects.push(where);
            break;
          }

          case "delete": {
            const where: any = {};
            if (data.id) where.id = data.id;
            deletes.push(where);
            break;
          }

          default: {
            // Default to connectOrCreate
            const where: any = {};
            if (data.id) where.id = data.id;
            const createData = { ...data };
            delete createData.id;
            connectOrCreates.push({
              where,
              create: transformCommentCreate(createData),
            });
          }
        }
      }

      result.comments = {};
      if (hasSet) result.comments.set = connects;
      else {
        if (connects.length) result.comments.connect = connects;
        if (creates.length) result.comments.create = creates;
        if (connectOrCreates.length)
          result.comments.connectOrCreate = connectOrCreates;
        if (updates.length) result.comments.updateMany = updates;
        if (deletes.length) result.comments.deleteMany = deletes;
      }
    }
  }
  if (input.organizationId !== undefined && input.organization === undefined) {
    // Direct foreign key provided - use connect
    result.organization = { connect: { id: input.organizationId } };
  } else if (input.organization !== undefined) {
    const rel = input.organization;
    const strategy = rel.flowRelationStrategy;
    const data = { ...rel };
    delete data.flowRelationStrategy;

    switch (strategy) {
      case "connect": {
        const where: any = {};
        if (data.id) where.id = data.id;
        result.organization = { connect: where };
        break;
      }

      case "create": {
        result.organization = { create: transformOrganizationCreate(data) };
        break;
      }

      case "connectOrCreate": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const createData = { ...data };
        delete createData.id;
        result.organization = {
          connectOrCreate: {
            where,
            create: transformOrganizationCreate(createData),
          },
        };
        break;
      }

      case "update": {
        result.organization = { update: transformOrganizationUpdate(data) };
        break;
      }

      case "upsert": {
        const where: any = {};
        if (data.id) where.id = data.id;
        const upsertData = { ...data };
        delete upsertData.id;
        result.organization = {
          upsert: {
            where,
            create: transformOrganizationCreate(upsertData),
            update: transformOrganizationUpdate(upsertData),
          },
        };
        break;
      }

      case "disconnect": {
        result.organization = { disconnect: true };
        break;
      }

      case "delete": {
        result.organization = { delete: true };
        break;
      }

      default: {
        // Smart default based on available fields
        const where: any = {};
        if (data.id) where.id = data.id;

        const hasAllRequiredFields = true; // No required fields

        if (Object.keys(where).length === 0) {
          // No ID/unique fields - must create
          result.organization = { create: transformOrganizationCreate(data) };
        } else if (!hasAllRequiredFields) {
          // Has ID/unique but missing required fields - use connect
          result.organization = { connect: where };
        } else {
          // Has ID/unique AND all required fields - use connectOrCreate
          const createData = { ...data };
          delete createData.id;
          result.organization = {
            connectOrCreate: {
              where,
              create: transformOrganizationCreate(createData),
            },
          };
        }
      }
    }
  }

  return result as Prisma.AuthorUpdateInput;
}
