// @generated by next-prisma-flow-state-engine
// file: forms.ts

"use client";

import { useCallback, useEffect, useRef, useState } from "react";
import { z } from "zod";
import { useForm, UseFormReturn, UseFormProps } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { AuthorCreateSchema, AuthorUpdateSchema } from "./zod";
import type {
  FlowAuthorWrite,
  FlowAuthorCreate,
  FlowAuthorUpdate,
} from "./zod";
import { useCreateAuthor, useUpdateAuthor } from "./hooks";

export function useAuthorForm(params?: {
  id?: string;
  mode?: "create" | "update";
  defaultValues?: Partial<FlowAuthorCreate> | Partial<FlowAuthorUpdate>;
  form?: Omit<UseFormProps<FlowAuthorWrite>, "resolver" | "defaultValues">;
  autosave?: boolean | { debounceMs?: number };
}) {
  const mode = params?.mode || "create";
  const id = params?.id as string | undefined;
  // Use mode-specific schemas for better client-side validation

  const schema =
    mode === "create"
      ? z.object({
          flowWriteMode: z.literal("create"),
          ...AuthorCreateSchema.shape,
        })
      : z.object({
          flowWriteMode: z.literal("update"),
          ...AuthorUpdateSchema.shape,
        });
  const refinedSchema = schema;
  const userFormOpts = params?.form || {};
  const normalizedFormOpts = {
    mode: (userFormOpts as any).mode ?? "all",
    ...userFormOpts,
  } as any;
  const mergedDefaults: any = {
    ...(normalizedFormOpts as any).defaultValues,
    ...(params?.defaultValues || {}),
  };
  mergedDefaults.flowWriteMode = mode;
  const form = useForm<FlowAuthorWrite>({
    ...normalizedFormOpts,
    resolver: zodResolver(refinedSchema),
    defaultValues: mergedDefaults,
  });
  const [serverError, setServerError] = useState<string | null>(null);
  const autosaveTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const createMutation = useCreateAuthor();
  const updateMutation = id ? useUpdateAuthor(id) : null;

  const onSubmit = useCallback(
    async (data: FlowAuthorWrite) => {
      try {
        setServerError(null);
        if (mode === "update" && updateMutation) {
          await updateMutation.mutateAsync(data);
        } else {
          await createMutation.mutateAsync(data);
        }
        form.reset();
      } catch (error: any) {
        console.error("Form submission error:", error);
        const msg =
          typeof error?.error === "string"
            ? error.error
            : error?.message || "Request failed";
        setServerError(msg);
      }
    },
    [mode, createMutation, updateMutation, form],
  );

  // Autosave support
  useEffect(() => {
    const enabled = !!params?.autosave;
    if (!enabled) return;
    const debounceMs =
      typeof params?.autosave === "object"
        ? (params!.autosave!.debounceMs ?? 600)
        : 600;
    const subscription = form.watch(() => {
      const hasTouched =
        Object.keys(form.formState.touchedFields || {}).length > 0;
      if (!hasTouched || !form.formState.isValid) return;
      if (autosaveTimerRef.current) clearTimeout(autosaveTimerRef.current);
      autosaveTimerRef.current = setTimeout(() => {
        form.handleSubmit(onSubmit as any)();
      }, debounceMs);
    });
    return () => {
      (subscription as any)?.unsubscribe?.();
      if (autosaveTimerRef.current) clearTimeout(autosaveTimerRef.current);
    };
  }, [form, onSubmit, params?.autosave]);

  return {
    form,
    onSubmit,
    isSubmitting:
      createMutation.isPending || (updateMutation?.isPending ?? false),
    mode,
    serverError,
  };
}

export type AuthorFormReturn = ReturnType<typeof useAuthorForm>;
